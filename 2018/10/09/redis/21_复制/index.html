<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Redis为了解决单点故障的问题，会将数据复制到多个从节点服务器中，通过复制，实现Redis的高可用。 1. 介绍复制使得slave服务器能够精确复制master服务器的数据，每当slave和master连接断开时，slave会自动重连到master，并且无论这期间master做了什么操作，slave都将尝试让自身成为master的精确副本。  当一个master和slave连接正常时，maste">
<meta name="keywords" content="redis">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis源码阅读(二十一) 复制">
<meta property="og:url" content="http://gxcbuf.github.io/2018/10/09/redis/21_复制/index.html">
<meta property="og:site_name" content="孰能生巧">
<meta property="og:description" content="Redis为了解决单点故障的问题，会将数据复制到多个从节点服务器中，通过复制，实现Redis的高可用。 1. 介绍复制使得slave服务器能够精确复制master服务器的数据，每当slave和master连接断开时，slave会自动重连到master，并且无论这期间master做了什么操作，slave都将尝试让自身成为master的精确副本。  当一个master和slave连接正常时，maste">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-10-09T08:53:46.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Redis源码阅读(二十一) 复制">
<meta name="twitter:description" content="Redis为了解决单点故障的问题，会将数据复制到多个从节点服务器中，通过复制，实现Redis的高可用。 1. 介绍复制使得slave服务器能够精确复制master服务器的数据，每当slave和master连接断开时，slave会自动重连到master，并且无论这期间master做了什么操作，slave都将尝试让自身成为master的精确副本。  当一个master和slave连接正常时，maste">






  <link rel="canonical" href="http://gxcbuf.github.io/2018/10/09/redis/21_复制/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Redis源码阅读(二十一) 复制 | 孰能生巧</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4aa8d6634642cbec4e6c0dd1c9f3ef00";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">孰能生巧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Practice makes Perfect.</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/10/09/redis/21_复制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/smile.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Redis源码阅读(二十一) 复制
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-09 16:53:45 / 修改时间：16:53:46" itemprop="dateCreated datePublished" datetime="2018-10-09T16:53:45+08:00">2018-10-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>Redis为了解决单点故障的问题，会将数据复制到多个从节点服务器中，通过复制，实现Redis的高可用。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>复制使得slave服务器能够精确复制master服务器的数据，每当slave和master连接断开时，slave会自动重连到master，并且无论这期间master做了什么操作，slave都将尝试让自身成为master的精确副本。</p>
<ul>
<li>当一个master和slave连接正常时，master会将所有的修改命令发送给slave。</li>
<li>当master和slave之间因为某些原因断开连接后，slave会重新连接到master并尝试进行部分重同步。</li>
<li>当无法进行部分同步时，slave会请求全量同步。</li>
</ul>
<p>Redis默认使用异步复制，即低延迟高性能，是绝大多Redis的自然复制模式。</p>
<p>配置Redis复制功能非常简单，只需加入下面内容到slave的配置文件即可，或在客户端中执行该命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令 主机ip地址 主机端口号</span><br><span class="line">slaveof 192.168.1.2 6379</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：通常完全重同步需要在磁盘上创建RDB文件，然后slave获取此RDB文件进行复制。但如果磁盘性能很低会对master造成很大压力，所以可以通过socket直接发送给slave而不存储到磁盘中。</p>
</blockquote>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>master使用复制ID和偏移量来标识当前复制的进度，复制ID用于标记数据集，偏移量用于标识此次复制中，master将多少字节已经发送给slave。而master自己则用于一块复制缓冲区域，用于缓存master产生的复制流。</p>
<p>当slave连接到master时，使用PSYNC命令发送旧的复制ID和已经处理的偏移量。如果复制ID与master匹配，且偏移量在复制积压缓冲区以内，则进行部分重同步；但否则的话，需要进行完全重同步。</p>
<p>复制ID标记数据集的历史记录，每次实例作为master重新启动或slave提升为master都会为其生成新的复制ID。</p>
<p>Redis实例拥有两个复制ID是因为到故障发生时，slave提升为master，slave需要记住过期的复制ID，该复制ID是之前的master，这样当其他slave与新master连接时，它们可以使用旧的复制ID尝试部分重同步。</p>
<h4 id="2-1-部分重同步"><a href="#2-1-部分重同步" class="headerlink" title="2.1 部分重同步"></a>2.1 部分重同步</h4><p>主节点在复制过程中，会将命令传递给从节点的同时保存在一个叫做复制积压缓冲区backlog的区域内，当从节点重新连接到主节点，会发送自己的复制ID和偏移量，如果偏移量在主节点的缓冲区范围内，则可以进行部分重同步，只是少量的数据，而不需要全部的RDB文件。</p>
<blockquote>
<p>复制积压缓冲区backlog是一个1M大小的循环队列，用于存储主节点传递的修改数据库的命令，也是部分重同步的重要部分，从节点通过偏移量和复制积压缓冲区就可以计算出与主节点的差异，如果在缓冲区中能找到则只需进行部分重同步，而无需完整的拷贝所有RDB文件</p>
</blockquote>
<h4 id="2-2-完全重同步"><a href="#2-2-完全重同步" class="headerlink" title="2.2 完全重同步"></a>2.2 完全重同步</h4><p>由于网络或其他原因，主从节点断线，当从节点重新连接到主节点时，主节点的复制积压缓冲区已经超过了从节点的偏移，此时无法进行部分重同步。</p>
<h4 id="2-3-心跳检测"><a href="#2-3-心跳检测" class="headerlink" title="2.3 心跳检测"></a>2.3 心跳检测</h4><p>为了保持master与slave之间的连接，它们之间会不时的进行通信以保持对方的在线状态：</p>
<ul>
<li>master节点每隔10s(默认)向slave节点发送PING命令，判断从节点连接状态</li>
<li>slave节点每秒发送<code>REPLCONF ACK &lt;offset&gt;</code>命令，给主节点报告自己当前复制偏移量</li>
</ul>
<h4 id="2-4-复制积压缓冲区backlog"><a href="#2-4-复制积压缓冲区backlog" class="headerlink" title="2.4 复制积压缓冲区backlog"></a>2.4 复制积压缓冲区backlog</h4><p>复制积压缓冲区backlog是一个1M大小的循环队列，用于存储主节点传递的修改数据库的命令，也是部分重同步的重要部分，从节点通过偏移量和复制积压缓冲区就可以计算出与主节点的差异，如果在缓冲区中能找到则只需进行部分重同步，而无需完整的拷贝所有RDB文件</p>
<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><ul>
<li><p>步骤1：设置主服务器的地址和端口</p>
<p>执行<code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code></p>
</li>
<li><p>步骤2：建立socket连接</p>
</li>
<li><p>步骤3：发送PING命令</p>
</li>
<li><p>步骤4：身份验证</p>
</li>
<li><p>步骤5：发送端口信息</p>
</li>
<li><p>步骤6：同步</p>
</li>
<li><p>步骤7：命令传递</p>
</li>
</ul>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>复制周期性任务</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replication cron function, called 1 time per second. */</span></span><br><span class="line"><span class="comment">// 复制周期函数，每秒调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> replication_cron_loops = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line">    <span class="comment">// 非阻塞连接已经超时，记录日志，并取消握手状态</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">        (server.repl_state == REPL_STATE_CONNECTING ||</span><br><span class="line">         slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">         (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">        cancelReplicationHandshake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line">    <span class="comment">// 接收RDB文件超时，记录日志，并取消握手状态</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">        cancelReplicationHandshake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line">    <span class="comment">// 主节点每10s向从节点发送PING，从节点每1秒向主节点发送PING</span></span><br><span class="line">    <span class="comment">// 主从节点已连接，但很久未接收到PING，则超时</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">        <span class="comment">// 释放主节点</span></span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we should connect to a MASTER */</span></span><br><span class="line">    <span class="comment">// 尝试连接master状态</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Connecting to MASTER %s:%d"</span>,</span><br><span class="line">            server.masterhost, server.masterport);</span><br><span class="line">        <span class="comment">// 连接master</span></span><br><span class="line">        <span class="keyword">if</span> (connectWithMaster() == C_OK) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"MASTER &lt;-&gt; SLAVE sync started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send ACK to master from time to time.</span></span><br><span class="line"><span class="comment">     * Note that we do not send periodic acks to masters that don't</span></span><br><span class="line"><span class="comment">     * support PSYNC and replication offsets. */</span></span><br><span class="line">    <span class="comment">// 发送ACK给主节点</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">        !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">        replicationSendAck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have attached slaves, PING them from time to time.</span></span><br><span class="line"><span class="comment">     * So slaves can implement an explicit timeout to masters, and will</span></span><br><span class="line"><span class="comment">     * be able to detect a link disconnection even if the TCP connection</span></span><br><span class="line"><span class="comment">     * will not actually go down. */</span></span><br><span class="line">    <span class="comment">// 如果服务器有从节点，定期发送PING</span></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    robj *ping_argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, send PING according to ping_slave_period. */</span></span><br><span class="line">    <span class="comment">// 首先, 根据配置的server.repl_ping_slave_period判断是否发送ACK，默认10秒主节点PING从节点</span></span><br><span class="line">    <span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listLength(server.slaves))</span><br><span class="line">    &#123;</span><br><span class="line">        ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">"PING"</span>,<span class="number">4</span>);</span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb,</span><br><span class="line">            ping_argv, <span class="number">1</span>);</span><br><span class="line">        decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second, send a newline to all the slaves in pre-synchronization</span></span><br><span class="line"><span class="comment">     * stage, that is, slaves waiting for the master to create the RDB file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also send the a newline to all the chained slaves we have, if we lost</span></span><br><span class="line"><span class="comment">     * connection from our master, to keep the slaves aware that their</span></span><br><span class="line"><span class="comment">     * master is online. This is needed since sub-slaves only receive proxied</span></span><br><span class="line"><span class="comment">     * data from top-level masters, so there is no explicit pinging in order</span></span><br><span class="line"><span class="comment">     * to avoid altering the replication offsets. This special out of band</span></span><br><span class="line"><span class="comment">     * pings (newlines) can be sent, they will have no effect in the offset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The newline will be ignored by the slave but will refresh the</span></span><br><span class="line"><span class="comment">     * last interaction timer preventing a timeout. In this case we ignore the</span></span><br><span class="line"><span class="comment">     * ping period and refresh the connection once per second since certain</span></span><br><span class="line"><span class="comment">     * timeouts are set at a few seconds (example: PSYNC response). */</span></span><br><span class="line">    <span class="comment">// 其次，发送一个换行符'\n'给所有准备同步：等待master创建RDB文件的从节点</span></span><br><span class="line">    <span class="comment">// 发送该换行符是为了确保slave知道他们的master在线，这样对偏移量也没有影响</span></span><br><span class="line">    <span class="comment">// 从节点会忽略该换行符，但会刷新最后一次交互时间，这种情况下，我们忽略ping周期并每秒刷新</span></span><br><span class="line">    <span class="comment">// 一次连接, 因为某些超时设置为几秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有从节点</span></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从节点的复制状态处于等待主节点创建RDB文件状态, 则发送一个'\n'用于ping</span></span><br><span class="line">        <span class="keyword">int</span> is_presync =</span><br><span class="line">            (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||</span><br><span class="line">            (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;</span><br><span class="line">             server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_presync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(slave-&gt;fd, <span class="string">"\n"</span>, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">/* Don't worry about socket errors, it's just a ping. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line">    <span class="comment">// 断开超时的从节点</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过未完成RDB文件传输的节点</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate != SLAVE_STATE_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">"Disconnecting timedout slave: %s"</span>,</span><br><span class="line">                    replicationGetSlaveName(slave));</span><br><span class="line">                freeClient(slave);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a master without attached slaves and there is a replication</span></span><br><span class="line"><span class="comment">     * backlog active, in order to reclaim memory we can free it after some</span></span><br><span class="line"><span class="comment">     * (configured) time. Note that this cannot be done for slaves: slaves</span></span><br><span class="line"><span class="comment">     * without sub-slaves attached should still accumulate data into the</span></span><br><span class="line"><span class="comment">     * backlog, in order to reply to PSYNC queries if they are turned into</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="comment">// 如果该主节点已经没有从节点，并且复制积压缓冲区存在，为了回收内存，</span></span><br><span class="line">    <span class="comment">// 我们可以在一段时间(可配置)之后释放它。</span></span><br><span class="line">    <span class="comment">// 注意：从节点无法执行该操作：没有附加从节点的从节点仍将数据累积下来，以便</span></span><br><span class="line">    <span class="comment">// 故障转移后将其转换为master时回复PSYNC</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp; server.repl_backlog_time_limit &amp;&amp;</span><br><span class="line">        server.repl_backlog &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算没有从节点开始有多久了</span></span><br><span class="line">        <span class="keyword">time_t</span> idle = server.unixtime - server.repl_no_slaves_since;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超过设定的限制，则释放积压缓冲区backlong</span></span><br><span class="line">        <span class="keyword">if</span> (idle &gt; server.repl_backlog_time_limit) &#123;</span><br><span class="line">            <span class="comment">/* When we free the backlog, we always use a new</span></span><br><span class="line"><span class="comment">             * replication ID and clear the ID2. This is needed</span></span><br><span class="line"><span class="comment">             * because when there is no backlog, the master_repl_offset</span></span><br><span class="line"><span class="comment">             * is not updated, but we would still retain our replication</span></span><br><span class="line"><span class="comment">             * ID, leading to the following problem:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. We are a master instance.</span></span><br><span class="line"><span class="comment">             * 2. Our slave is promoted to master. It's repl-id-2 will</span></span><br><span class="line"><span class="comment">             *    be the same as our repl-id.</span></span><br><span class="line"><span class="comment">             * 3. We, yet as master, receive some updates, that will not</span></span><br><span class="line"><span class="comment">             *    increment the master_repl_offset.</span></span><br><span class="line"><span class="comment">             * 4. Later we are turned into a slave, connecto to the new</span></span><br><span class="line"><span class="comment">             *    master that will accept our PSYNC request by second</span></span><br><span class="line"><span class="comment">             *    replication ID, but there will be data inconsistency</span></span><br><span class="line"><span class="comment">             *    because we received writes. */</span></span><br><span class="line">            changeReplicationId();</span><br><span class="line">            clearReplicationId2();</span><br><span class="line">            freeReplicationBacklog();</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replication backlog freed after %d seconds "</span></span><br><span class="line">                <span class="string">"without connected slaves."</span>,</span><br><span class="line">                (<span class="keyword">int</span>) server.repl_backlog_time_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If AOF is disabled and we no longer have attached slaves, we can</span></span><br><span class="line"><span class="comment">     * free our Replication Script Cache as there is no need to propagate</span></span><br><span class="line"><span class="comment">     * EVALSHA at all. */</span></span><br><span class="line">    <span class="comment">// 如果AOF关闭，且没有从节点，我们就释放复制脚本缓存，因为没有传递EVALSHA的必要</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.aof_state == AOF_OFF &amp;&amp;</span><br><span class="line">        listLength(server.repl_scriptcache_fifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start a BGSAVE good for replication if we have slaves in</span></span><br><span class="line"><span class="comment">     * WAIT_BGSAVE_START state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In case of diskless replication, we make sure to wait the specified</span></span><br><span class="line"><span class="comment">     * number of seconds (according to configuration) so that other slaves</span></span><br><span class="line"><span class="comment">     * have the time to arrive before we start streaming. */</span></span><br><span class="line">    <span class="comment">// 如果从节点处于WAIT_BGSAVE_START状态，则为了复制操作开始执行一个BGSAVE</span></span><br><span class="line">    <span class="comment">// 无盘复制情况下，等待指定秒数(可配置)，以确保其他从节点有时间在我们开始流式传输之前到达</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> idle, max_idle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slaves_waiting = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mincapa = <span class="number">-1</span>;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有从节点</span></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line">            <span class="comment">// 如果从节点复制状态为等待BGSAVE开始</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                <span class="comment">// 计算距离上一次交互时间差</span></span><br><span class="line">                idle = server.unixtime - slave-&gt;lastinteraction;</span><br><span class="line">                <span class="comment">// 记录最大空余时间</span></span><br><span class="line">                <span class="keyword">if</span> (idle &gt; max_idle) max_idle = idle;</span><br><span class="line">                <span class="comment">// 记录等待BGSAVE的节点数量</span></span><br><span class="line">                slaves_waiting++;</span><br><span class="line">                mincapa = (mincapa == <span class="number">-1</span>) ? slave-&gt;slave_capa :</span><br><span class="line">                                            (mincapa &amp; slave-&gt;slave_capa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要执行BGSAVE，BGSAVE会根据mincapa将RDB文件写到磁盘或socket</span></span><br><span class="line">        <span class="keyword">if</span> (slaves_waiting &amp;&amp;</span><br><span class="line">            (!server.repl_diskless_sync ||</span><br><span class="line">             max_idle &gt; server.repl_diskless_sync_delay))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Start the BGSAVE. The called function may start a</span></span><br><span class="line"><span class="comment">             * BGSAVE with socket target or disk target depending on the</span></span><br><span class="line"><span class="comment">             * configuration and slaves capabilities. */</span></span><br><span class="line">            startBgsaveForReplication(mincapa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</span></span><br><span class="line">    <span class="comment">// 更新延迟lag小于 min-slaves-max-lag的从节点数量</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    <span class="comment">// 更新cron函数执行次数</span></span><br><span class="line">    replication_cron_loops++; <span class="comment">/* Incremented with frequency 1 HZ. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SYNC和PSYNC命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SYNC和PSYNC命令实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ignore SYNC if already slave or in monitor mode */</span></span><br><span class="line">    <span class="comment">// 从节点忽略同步命令</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refuse SYNC requests if we are a slave but the link with our master</span></span><br><span class="line"><span class="comment">     * is not ok... */</span></span><br><span class="line">    <span class="comment">// 从节点未与主节点连接，则发送错误回复</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"-NOMASTERLINK Can't SYNC while not connected with my master\r\n"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SYNC can't be issued when the server has pending data to send to</span></span><br><span class="line"><span class="comment">     * the client about already issued commands. We need a fresh reply</span></span><br><span class="line"><span class="comment">     * buffer registering the differences between the BGSAVE and the current</span></span><br><span class="line"><span class="comment">     * dataset, so that we can copy to other slaves if needed. */</span></span><br><span class="line">    <span class="comment">// 如果指定的客户端回复缓冲区中海油数据，则不能执行同步</span></span><br><span class="line">    <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"SYNC and PSYNC are invalid with pending output"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Slave %s asks for synchronization"</span>,</span><br><span class="line">        replicationGetSlaveName(c));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try a partial resynchronization if this is a PSYNC command.</span></span><br><span class="line"><span class="comment">     * If it fails, we continue with usual full resynchronization, however</span></span><br><span class="line"><span class="comment">     * when this happens masterTryPartialResynchronization() already</span></span><br><span class="line"><span class="comment">     * replied with:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * +FULLRESYNC &lt;replid&gt; &lt;offset&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So the slave knows the new replid and offset to try a PSYNC later</span></span><br><span class="line"><span class="comment">     * if the connection with the master is lost. */</span></span><br><span class="line">    <span class="comment">// 尝试执行部分同步命令，回复"+FULLRESYNC &lt;replid&gt; &lt;offset&gt;", 失败则执行全量同步，</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"psync"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 主节点尝试执行部分重同步</span></span><br><span class="line">        <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">            <span class="comment">// 可执行PSYNC命令，计数+1</span></span><br><span class="line">            server.stat_sync_partial_ok++;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* No full resync needed, return. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不能执行PSYNC，则全量同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment stats for failed PSYNCs, but only if the</span></span><br><span class="line"><span class="comment">             * replid is not "?", as this is used by slaves to force a full</span></span><br><span class="line"><span class="comment">             * resync on purpose when they are not albe to partially</span></span><br><span class="line"><span class="comment">             * resync. */</span></span><br><span class="line">            <span class="comment">// 记录psync失败次数</span></span><br><span class="line">            <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">'?'</span>) server.stat_sync_partial_err++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If a slave uses SYNC, we are dealing with an old implementation</span></span><br><span class="line"><span class="comment">         * of the replication protocol (like redis-cli --slave). Flag the client</span></span><br><span class="line"><span class="comment">         * so that we don't expect to receive replicationSendAck ACK feedbacks. */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Full resynchronization. */</span></span><br><span class="line">    <span class="comment">// 全量同步计数</span></span><br><span class="line">    server.stat_sync_full++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the slave as one waiting for BGSAVE to start. The following code</span></span><br><span class="line"><span class="comment">     * paths will change the state if we handle the slave differently. */</span></span><br><span class="line">    <span class="comment">// 客户端状态为从节点服务器等待BGSAVE开始</span></span><br><span class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">    <span class="comment">// 执行SYNC命令后，是否关闭TCP_NODELAY</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_disable_tcp_nodelay)</span><br><span class="line">        anetDisableTcpNoDelay(<span class="literal">NULL</span>, c-&gt;fd); <span class="comment">/* Non critical if it fails. */</span></span><br><span class="line">    c-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">    listAddNodeTail(server.slaves,c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the replication backlog if needed. */</span></span><br><span class="line">    <span class="comment">// 根据需要创建一个backlog缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">1</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* When we create the backlog from scratch, we always use a new</span></span><br><span class="line"><span class="comment">         * replication ID and clear the ID2, since there is no valid</span></span><br><span class="line"><span class="comment">         * past history. */</span></span><br><span class="line">        changeReplicationId();</span><br><span class="line">        clearReplicationId2();</span><br><span class="line">        createReplicationBacklog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 1: BGSAVE is in progress, with disk target. */</span></span><br><span class="line">    <span class="comment">// 情况1：BGSAVE正在执行，同步到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Ok a background save is in progress. Let's check if it is a good</span></span><br><span class="line"><span class="comment">         * one for replication, i.e. if there is another slave that is</span></span><br><span class="line"><span class="comment">         * registering differences since the server forked to save. */</span></span><br><span class="line">        client *slave;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历从节点链表</span></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            slave = ln-&gt;value;</span><br><span class="line">            <span class="comment">// 从节点等待BGSAVE结束</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* To attach this slave, we check that it has at least all the</span></span><br><span class="line"><span class="comment">         * capabilities of the slave that triggered the current BGSAVE. */</span></span><br><span class="line">        <span class="comment">// 对与该节点，检测它是否具有触发当前BGSAVE操作的能力</span></span><br><span class="line">        <span class="keyword">if</span> (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</span><br><span class="line">            <span class="comment">/* Perfect, the server is already registering differences for</span></span><br><span class="line"><span class="comment">             * another slave. Set the right state, and copy the buffer. */</span></span><br><span class="line">            <span class="comment">// 将从节点输出缓冲区内容拷贝到客户端输出缓冲区</span></span><br><span class="line">            copyClientOutputBuffer(c,slave);</span><br><span class="line">            <span class="comment">// 设置全量同步状态，和部分重同步偏移量</span></span><br><span class="line">            replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Waiting for end of BGSAVE for SYNC"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* No way, we need to wait for the next BGSAVE in order to</span></span><br><span class="line"><span class="comment">             * register differences. */</span></span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Can't attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 2: BGSAVE is in progress, with socket target. */</span></span><br><span class="line">    <span class="comment">// 情况2： BGSAVE正在执行，同步到socket</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* There is an RDB child process but it is writing directly to</span></span><br><span class="line"><span class="comment">         * children sockets. We need to wait for the next BGSAVE</span></span><br><span class="line"><span class="comment">         * in order to synchronize. */</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 3: There is no BGSAVE is progress. */</span></span><br><span class="line">    <span class="comment">// 情况3：BGSAVE没有执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</span><br><span class="line">            <span class="comment">/* Diskless replication RDB child is created inside</span></span><br><span class="line"><span class="comment">             * replicationCron() since we want to delay its start a</span></span><br><span class="line"><span class="comment">             * few seconds to wait for more slaves to arrive. */</span></span><br><span class="line">            <span class="comment">// 无盘同步的子进程在replicationCron()中创建</span></span><br><span class="line">            <span class="keyword">if</span> (server.repl_diskless_sync_delay)</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"Delay next BGSAVE for diskless SYNC"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Target is disk (or the slave is not capable of supporting</span></span><br><span class="line"><span class="comment">             * diskless replication) and we don't have a BGSAVE in progress,</span></span><br><span class="line"><span class="comment">             * let's start one. */</span></span><br><span class="line">            <span class="comment">// 没有进行BGSAVE并且没有AOF，则开始为复制执行BGSAVE</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                startBgsaveForReplication(c-&gt;slave_capa);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">"No BGSAVE in progress, but an AOF rewrite is active. "</span></span><br><span class="line">                    <span class="string">"BGSAVE for replication delayed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/redis/" rel="tag"># redis</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/19/redis/20_服务器/" rel="next" title="Redis源码阅读(二十) 服务器">
                <i class="fa fa-chevron-left"></i> Redis源码阅读(二十) 服务器
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/10/24/redis/22_哨兵Sentinel/" rel="prev" title="Redis源码阅读(二十二) Sentinel哨兵">
                Redis源码阅读(二十二) Sentinel哨兵 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/smile.jpg"
                alt="郭欣成" />
            
              <p class="site-author-name" itemprop="name">郭欣成</p>
              <p class="site-description motion-element" itemprop="description">Persion & Developer</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/gxcbuf" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-介绍"><span class="nav-number">1.</span> <span class="nav-text">1. 介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-工作原理"><span class="nav-number">2.</span> <span class="nav-text">2. 工作原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-部分重同步"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 部分重同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-完全重同步"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 完全重同步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-心跳检测"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 心跳检测</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-复制积压缓冲区backlog"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 复制积压缓冲区backlog</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-实现"><span class="nav-number">3.</span> <span class="nav-text">3. 实现</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-源码剖析"><span class="nav-number">4.</span> <span class="nav-text">4. 源码剖析</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭欣成</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Pisces</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=6.3.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.3.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.3.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  





  

  

  

  
  

  
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>

    
  


  
  

  

  

  

  

  

</body>
</html>
