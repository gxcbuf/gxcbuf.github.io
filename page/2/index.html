<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Persion &amp; Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="孰能生巧">
<meta property="og:url" content="http://gxcbuf.github.io/page/2/index.html">
<meta property="og:site_name" content="孰能生巧">
<meta property="og:description" content="Persion &amp; Developer">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孰能生巧">
<meta name="twitter:description" content="Persion &amp; Developer">






  <link rel="canonical" href="http://gxcbuf.github.io/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>孰能生巧</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4aa8d6634642cbec4e6c0dd1c9f3ef00";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">孰能生巧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Practice makes Perfect.</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/29/redis/15_Redis数据库/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/29/redis/15_Redis数据库/" itemprop="url">
                  Redis源码阅读(十五) 数据库对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-29 12:42:31" itemprop="dateCreated datePublished" datetime="2018-08-29T12:42:31+08:00">2018-08-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-09-03 17:00:51" itemprop="dateModified" datetime="2018-09-03T17:00:51+08:00">2018-09-03</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li>Redis数据库结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">    <span class="comment">// 键值对字典，保存数据库对象中的所有键值对</span></span><br><span class="line">    dict *dict;                 <span class="comment">/* The keyspace for this DB */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 过期字典, 保存设置了过期时间的键和过期时间</span></span><br><span class="line">    dict *expires;              <span class="comment">/* Timeout of keys with a timeout set */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞键字典，保存着造成客户端组队的键和被阻塞的客户端</span></span><br><span class="line">    <span class="comment">// key为阻塞的键，value为该阻塞键造成阻塞的客户端双向链表</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞键字典，保存着收到PUSH命令的键，避免重复操作</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监控键字典，保存着被WATCH命令监控的键</span></span><br><span class="line">    dict *watched_keys;         <span class="comment">/* WATCHED keys for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库ID</span></span><br><span class="line">    <span class="keyword">int</span> id;                     <span class="comment">/* Database ID */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 平均生成周期，用于统计</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> avg_ttl;          <span class="comment">/* Average TTL, just for stats */</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Redis服务器</p>
<p>Redis服务器将所有数据库都保存在db数组中，通过dbnum来决定Redis数据库实例的个数。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// RedisDB对象数组，长度默认16，每个都存储了Redis数据库对象</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 服务器db对象的数量，服务器初始化时根据dbnum确定</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Redis客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前客户端指向的数据库对象</span></span><br><span class="line">    redisDb *db;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-Redis数据库"><a href="#2-Redis数据库" class="headerlink" title="2. Redis数据库"></a>2. Redis数据库</h3><h4 id="2-1-dict-键空间"><a href="#2-1-dict-键空间" class="headerlink" title="2.1 dict 键空间"></a>2.1 dict 键空间</h4><p>redisDb结构中dict属性保存了该数据库所有的键值对，被称之为键空间。</p>
<ul>
<li>每个键都是一个字符串，客户端所有设置key都存储在该字典中</li>
<li>每个值可以是字符串对象、列表对象、哈希对象、集合对象和有序集合对象中任意一种。</li>
</ul>
<h4 id="2-2-expires-过期字典"><a href="#2-2-expires-过期字典" class="headerlink" title="2.2 expires 过期字典"></a>2.2 expires 过期字典</h4><p>expires字典保存着当前数据库对象中键的过期时间</p>
<ul>
<li>每个键都是一个指针，指向dict中过期的键</li>
<li>每个值都是一个long long类型的整数，保存了dict中key的过期时间(毫秒精度的时间戳)</li>
</ul>
<h4 id="2-3-blocking-keys-阻塞键字典"><a href="#2-3-blocking-keys-阻塞键字典" class="headerlink" title="2.3 blocking_keys 阻塞键字典"></a>2.3 blocking_keys 阻塞键字典</h4><p>blocking_keys字典保存着造成客户端阻塞的键</p>
<ul>
<li>每个键都是一个指针，指向造成客户端阻塞的dict中的键</li>
<li>每个值都是一个双端链表，存储着被这个键阻塞的客户端指针</li>
</ul>
<h4 id="2-4-ready-keys"><a href="#2-4-ready-keys" class="headerlink" title="2.4 ready_keys"></a>2.4 ready_keys</h4><p>ready_keys字典保存着阻塞键的等待队列，用于避免重复的阻塞命令</p>
<ul>
<li>每个键都是一个指针，指向一个阻塞键</li>
<li>每个值都是NULL</li>
</ul>
<h4 id="2-5-watched-keys"><a href="#2-5-watched-keys" class="headerlink" title="2.5 watched_keys"></a>2.5 watched_keys</h4><p>watched_keys字典保存着被客户端WATCH命令监控的键</p>
<ul>
<li>每个键都是一个指针，指向被监控的键</li>
<li>每个值都是一个双向链表，存储着监控这个键的客户端</li>
</ul>
<h4 id="2-6-读写键的维护"><a href="#2-6-读写键的维护" class="headerlink" title="2.6 读写键的维护"></a>2.6 读写键的维护</h4><ul>
<li>读取一个键后，更新其LRU或者LFU，通过OBJECT idletime/freq 可以查询</li>
<li>读取一个键后，更新hits或者miss，通过INFO stats 可以查询统计</li>
<li>读取一个键时，发现其已经过期，会先删除这个键</li>
<li>修改一个键后，会对服务器dirty加1，这个计数器用于持久化和复制操作</li>
</ul>
<h3 id="3-Redis键过期策略"><a href="#3-Redis键过期策略" class="headerlink" title="3. Redis键过期策略"></a>3. Redis键过期策略</h3><h4 id="3-1-设置键的生存时间或过期时间"><a href="#3-1-设置键的生存时间或过期时间" class="headerlink" title="3.1 设置键的生存时间或过期时间"></a>3.1 设置键的生存时间或过期时间</h4><p>通过EXPIRE或PEXPIRE命令可以设置键的过期，redis底层过期存储的是毫秒数。</p>
<p>通过TTL命令或PTTL命令可以查询键还有多久过期。</p>
<h4 id="3-2-过期键删除"><a href="#3-2-过期键删除" class="headerlink" title="3.2 过期键删除"></a>3.2 过期键删除</h4><ul>
<li><p>惰性删除</p>
<p>过期键的惰性删除由expireIfNeed函数实现，所以读写键值对的命令都会调用该函数检查键是否过期。在集群模式中，master节点会对过期键直接删除，但在slave节点中，只是逻辑上的删除，实际仍然存在，只有在master通知slave节点删除时，过期键才会真正的删除。这样由master节点统一管理过期键，在一定程度上保持了一致性。</p>
</li>
<li><p>定时删除</p>
<p>定时过期删除由activeExpireCycle函数实现，当redis执行周期性操作时，该函数会被调用，在规定的时间内，分多次遍历多个数据库，从数据库expires中随机获取，检查过期并删除。</p>
</li>
</ul>
<blockquote>
<p>惰性删除中有dbAsyncDelete和dbSyncDelete两种策略，异步操作会将删除操作记录下来，积累到一定程度统一删除。</p>
</blockquote>
<h3 id="4-AOF、RDB和复制对过期键处理"><a href="#4-AOF、RDB和复制对过期键处理" class="headerlink" title="4. AOF、RDB和复制对过期键处理"></a>4. AOF、RDB和复制对过期键处理</h3><ul>
<li><p>生成RDB文件</p>
<p>在执行SAVE或BGSAVE命令创建一个RDB文件时，会对数据库中过期的键进行检查，已过期的不会保存。</p>
</li>
<li><p>载入RDB文件</p>
<p>启动服务器时，若开启RDB功能，那么会载入RDB文件，在集群模式中，master节点会对RDB中已经过期的键进行过滤，不加载，而slave节点则不会考虑该情况。</p>
</li>
<li><p>AOF文件写入</p>
<p>当过期键被删除时，回向AOF文件追加一条DEL指令，来表示键被删除</p>
</li>
</ul>
<h3 id="5-源码剖析"><a href="#5-源码剖析" class="headerlink" title="5. 源码剖析"></a>5. 源码剖析</h3><ul>
<li>检查键的过期</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取键的过期时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有过期时间返回0</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="comment">// 服务器加载时，不进行过期检查</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we pretend that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">    <span class="comment">// 获取当前时间，lua脚本则是脚本执行开始时间</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller,</span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">    <span class="comment">// 如果是从节点，尽快返回已经过期，但并未删除</span></span><br><span class="line">    <span class="comment">// 从节点键过期需要通过master节点发送DEL操作执行</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="comment">// 键未过期，返回0</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    <span class="comment">// 服务器过期键数+1</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传递过期信息给从节点和AOF文件</span></span><br><span class="line">    propagateExpire(db,key,server.lazyfree_lazy_expire);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// "expired" 事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 懒过期则异步删除，否则同步删除</span></span><br><span class="line">    <span class="keyword">return</span> server.lazyfree_lazy_expire ? dbAsyncDelete(db,key) :</span><br><span class="line">                                         dbSyncDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>keys命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">keysCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取pattern</span></span><br><span class="line">    sds pattern = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">int</span> plen = sdslen(pattern), allkeys;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> numkeys = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个空链表，用于回复客户端</span></span><br><span class="line">    <span class="keyword">void</span> *replylen = addDeferredMultiBulkLength(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典安全迭代器</span></span><br><span class="line">    di = dictGetSafeIterator(c-&gt;db-&gt;dict);</span><br><span class="line">    <span class="comment">// 所用的键</span></span><br><span class="line">    allkeys = (pattern[<span class="number">0</span>] == <span class="string">'*'</span> &amp;&amp; pattern[<span class="number">1</span>] == <span class="string">'\0'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历字典</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取字典中的key</span></span><br><span class="line">        sds key = dictGetKey(de);</span><br><span class="line">        robj *keyobj;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果返回所有键或匹配正则</span></span><br><span class="line">        <span class="keyword">if</span> (allkeys || stringmatchlen(pattern,plen,key,sdslen(key),<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="comment">// 创建字符串对象</span></span><br><span class="line">            keyobj = createStringObject(key,sdslen(key));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检查键对象是否过期，没过期则回复客户端</span></span><br><span class="line">            <span class="keyword">if</span> (expireIfNeeded(c-&gt;db,keyobj) == <span class="number">0</span>) &#123;</span><br><span class="line">                addReplyBulk(c,keyobj);</span><br><span class="line">                numkeys++;</span><br><span class="line">            &#125;</span><br><span class="line">            decrRefCount(keyobj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">    <span class="comment">// 设置回复客户端的长度</span></span><br><span class="line">    setDeferredMultiBulkLength(c,replylen,numkeys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>scan命令底层实现，利用字典的反向二进制扫描</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scanGenericCommand</span><span class="params">(client *c, robj *o, <span class="keyword">unsigned</span> <span class="keyword">long</span> cursor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="built_in">list</span> *keys = listCreate();</span><br><span class="line">    listNode *node, *nextnode;</span><br><span class="line">    <span class="keyword">long</span> count = <span class="number">10</span>;</span><br><span class="line">    sds pat = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> patlen = <span class="number">0</span>, use_pattern = <span class="number">0</span>;</span><br><span class="line">    dict *ht;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Object must be NULL (to iterate keys names), or the type of the object</span></span><br><span class="line"><span class="comment">     * must be Set, Sorted Set, or Hash. */</span></span><br><span class="line">    <span class="comment">// 必须是NULL(迭代key)，SET, ZSET 或者HASH</span></span><br><span class="line">    serverAssert(o == <span class="literal">NULL</span> || o-&gt;type == OBJ_SET || o-&gt;type == OBJ_HASH ||</span><br><span class="line">                o-&gt;type == OBJ_ZSET);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set i to the first option argument. The previous one is the cursor. */</span></span><br><span class="line">    <span class="comment">// 计算第一个选项参数的位置</span></span><br><span class="line">    i = (o == <span class="literal">NULL</span>) ? <span class="number">2</span> : <span class="number">3</span>; <span class="comment">/* Skip the key argument if needed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 1: Parse options. */</span></span><br><span class="line">    <span class="comment">// 第一步：解析选项</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; c-&gt;argc) &#123;</span><br><span class="line">        j = c-&gt;argc - i;</span><br><span class="line">        <span class="comment">// COUNT选项，用于用户迭代每次返回多少元素</span></span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"count"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取count参数</span></span><br><span class="line">            <span class="keyword">if</span> (getLongFromObjectOrReply(c, c-&gt;argv[i+<span class="number">1</span>], &amp;count, <span class="literal">NULL</span>)</span><br><span class="line">                != C_OK)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// count不能小于1</span></span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                addReply(c,shared.syntaxerr);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// match选项：命令只返回匹配的元素</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[i]-&gt;ptr, <span class="string">"match"</span>) &amp;&amp; j &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// pattern 字符串</span></span><br><span class="line">            pat = c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr;</span><br><span class="line">            patlen = sdslen(pat);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The pattern always matches if it is exactly "*", so it is</span></span><br><span class="line"><span class="comment">             * equivalent to disabling it. */</span></span><br><span class="line">            <span class="comment">// 如果是* 表示所有，不用正则匹配</span></span><br><span class="line">            use_pattern = !(pat[<span class="number">0</span>] == <span class="string">'*'</span> &amp;&amp; patlen == <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            i += <span class="number">2</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            addReply(c,shared.syntaxerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 2: Iterate the collection.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that if the object is encoded with a ziplist, intset, or any other</span></span><br><span class="line"><span class="comment">     * representation that is not a hash table, we are sure that it is also</span></span><br><span class="line"><span class="comment">     * composed of a small number of elements. So to avoid taking state we</span></span><br><span class="line"><span class="comment">     * just return everything inside the object in a single call, setting the</span></span><br><span class="line"><span class="comment">     * cursor to zero to signal the end of the iteration. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步：迭代集合</span></span><br><span class="line">    <span class="comment">// 注意：底层不是HASH，表示只含有少量元素，我们可以一次性全部返还，并将cursor设为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle the case of a hash table. */</span></span><br><span class="line">    <span class="comment">// 获取不同类型对象的哈希表</span></span><br><span class="line">    ht = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ht = c-&gt;db-&gt;dict;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH &amp;&amp; o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        ht = o-&gt;ptr;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET &amp;&amp; o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        zset *zs = o-&gt;ptr;</span><br><span class="line">        ht = zs-&gt;dict;</span><br><span class="line">        count *= <span class="number">2</span>; <span class="comment">/* We return key / value for this type. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ht) &#123;</span><br><span class="line">        <span class="keyword">void</span> *privdata[<span class="number">2</span>];</span><br><span class="line">        <span class="comment">/* We set the max number of iterations to ten times the specified</span></span><br><span class="line"><span class="comment">         * COUNT, so if the hash table is in a pathological state (very</span></span><br><span class="line"><span class="comment">         * sparsely populated) we avoid to block too much time at the cost</span></span><br><span class="line"><span class="comment">         * of returning no or very few elements. */</span></span><br><span class="line">        <span class="comment">// 最大迭代长度</span></span><br><span class="line">        <span class="keyword">long</span> maxiterations = count*<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* We pass two pointers to the callback: the list to which it will</span></span><br><span class="line"><span class="comment">         * add new elements, and the object containing the dictionary so that</span></span><br><span class="line"><span class="comment">         * it is possible to fetch more data in a type-dependent way. */</span></span><br><span class="line">        <span class="comment">// 回调函数scanCallback的参数</span></span><br><span class="line">        privdata[<span class="number">0</span>] = keys;</span><br><span class="line">        privdata[<span class="number">1</span>] = o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="comment">// 字典扫描，并返回cursor</span></span><br><span class="line">            cursor = dictScan(ht, cursor, scanCallback, <span class="literal">NULL</span>, privdata);</span><br><span class="line">        &#125; <span class="keyword">while</span> (cursor &amp;&amp;</span><br><span class="line">              maxiterations-- &amp;&amp;</span><br><span class="line">              listLength(keys) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)count);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">        <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int64_t</span> ll;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 整数集合全部获取返回</span></span><br><span class="line">        <span class="keyword">while</span>(intsetGet(o-&gt;ptr,pos++,&amp;ll))</span><br><span class="line">            listAddNodeTail(keys,createStringObjectFromLongLong(ll));</span><br><span class="line">        cursor = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH || o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = ziplistIndex(o-&gt;ptr,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vll;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 压缩列表遍历</span></span><br><span class="line">        <span class="keyword">while</span>(p) &#123;</span><br><span class="line">            <span class="comment">// 获取压缩列表结点的值</span></span><br><span class="line">            ziplistGet(p,&amp;vstr,&amp;vlen,&amp;vll);</span><br><span class="line">            listAddNodeTail(keys,</span><br><span class="line">                (vstr != <span class="literal">NULL</span>) ? createStringObject((<span class="keyword">char</span>*)vstr,vlen) :</span><br><span class="line">                                 createStringObjectFromLongLong(vll));</span><br><span class="line">            p = ziplistNext(o-&gt;ptr,p);</span><br><span class="line">        &#125;</span><br><span class="line">        cursor = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Not handled encoding in SCAN."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 3: Filter elements. */</span></span><br><span class="line">    <span class="comment">// 第三步：过滤元素（设置了match参数）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描key链表首地址</span></span><br><span class="line">    node = listFirst(keys);</span><br><span class="line">    <span class="keyword">while</span> (node) &#123;</span><br><span class="line">        <span class="comment">// 获取结点key</span></span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        <span class="comment">// 下一结点地址</span></span><br><span class="line">        nextnode = listNextNode(node);</span><br><span class="line">        <span class="keyword">int</span> filter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Filter element if it does not match the pattern. */</span></span><br><span class="line">        <span class="comment">// 过滤元素</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; use_pattern) &#123;</span><br><span class="line">            <span class="comment">// kobj是字符串对象，则直接比较</span></span><br><span class="line">            <span class="keyword">if</span> (sdsEncodedObject(kobj)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stringmatchlen(pat, patlen, kobj-&gt;ptr, sdslen(kobj-&gt;ptr), <span class="number">0</span>))</span><br><span class="line">                    filter = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// kobj是正数对象，则转换后比较</span></span><br><span class="line">                <span class="keyword">char</span> buf[LONG_STR_SIZE];</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">                serverAssert(kobj-&gt;encoding == OBJ_ENCODING_INT);</span><br><span class="line">                len = ll2string(buf,<span class="keyword">sizeof</span>(buf),(<span class="keyword">long</span>)kobj-&gt;ptr);</span><br><span class="line">                <span class="keyword">if</span> (!stringmatchlen(pat, patlen, buf, len, <span class="number">0</span>)) filter = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Filter element if it is an expired key. */</span></span><br><span class="line">        <span class="comment">// 过滤过期的键</span></span><br><span class="line">        <span class="keyword">if</span> (!filter &amp;&amp; o == <span class="literal">NULL</span> &amp;&amp; expireIfNeeded(c-&gt;db, kobj)) filter = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove the element and its associted value if needed. */</span></span><br><span class="line">        <span class="comment">// 过滤则删除keys链表中的结点</span></span><br><span class="line">        <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">            decrRefCount(kobj);</span><br><span class="line">            listDelNode(keys, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If this is a hash or a sorted set, we have a flat list of</span></span><br><span class="line"><span class="comment">         * key-value elements, so if this element was filtered, remove the</span></span><br><span class="line"><span class="comment">         * value, or skip it if it was not filtered: we only match keys. */</span></span><br><span class="line">        <span class="comment">// 如果迭代模板是有序集合或哈希对象</span></span><br><span class="line">        <span class="comment">// keys保存的是键值对，需要将值对象也过滤掉</span></span><br><span class="line">        <span class="keyword">if</span> (o &amp;&amp; (o-&gt;type == OBJ_ZSET || o-&gt;type == OBJ_HASH)) &#123;</span><br><span class="line">            node = nextnode;</span><br><span class="line">            <span class="comment">// 下一个结点地址</span></span><br><span class="line">            nextnode = listNextNode(node);</span><br><span class="line">            <span class="keyword">if</span> (filter) &#123;</span><br><span class="line">                <span class="comment">// 取出值对象</span></span><br><span class="line">                kobj = listNodeValue(node);</span><br><span class="line">                <span class="comment">// 释放引用</span></span><br><span class="line">                decrRefCount(kobj);</span><br><span class="line">                <span class="comment">// 删除keys中的结点</span></span><br><span class="line">                listDelNode(keys, node);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = nextnode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Step 4: Reply to the client. */</span></span><br><span class="line">    <span class="comment">// 第四步：回复客户端</span></span><br><span class="line"></span><br><span class="line">    addReplyMultiBulkLen(c, <span class="number">2</span>);</span><br><span class="line">    addReplyBulkLongLong(c,cursor);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复列表长度</span></span><br><span class="line">    addReplyMultiBulkLen(c, listLength(keys));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历回复列表，进行回复</span></span><br><span class="line">    <span class="keyword">while</span> ((node = listFirst(keys)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        robj *kobj = listNodeValue(node);</span><br><span class="line">        addReplyBulk(c, kobj);</span><br><span class="line">        decrRefCount(kobj);</span><br><span class="line">        listDelNode(keys, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    listSetFreeMethod(keys,decrRefCountVoid);</span><br><span class="line">    listRelease(keys);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>过期信息传递</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传递过期信息给从节点和AOF文件</span></span><br><span class="line"><span class="comment"> * 当master结点的键过期时，DEL操作会发送给所有的从节点和AOF文件</span></span><br><span class="line"><span class="comment"> * 这种键过期的方式在一个地方集中管理，并且保证了操作的顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">propagateExpire</span><span class="params">(redisDb *db, robj *key, <span class="keyword">int</span> lazy)</span> </span>&#123;</span><br><span class="line">    robj *argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造参数列表</span></span><br><span class="line">    argv[<span class="number">0</span>] = lazy ? shared.unlink : shared.del;</span><br><span class="line">    argv[<span class="number">1</span>] = key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加参数列表的引用计数</span></span><br><span class="line">    incrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    incrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// AOF状态开启，将del追加到AOF文件</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state != AOF_OFF)</span><br><span class="line">        feedAppendOnlyFile(server.delCommand,db-&gt;id,argv,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将argv命令发送给所有从节点</span></span><br><span class="line">    replicationFeedSlaves(server.slaves,db-&gt;id,argv,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放参数列表</span></span><br><span class="line">    decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">    decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/27/redis/14_有序集合对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/27/redis/14_有序集合对象/" itemprop="url">
                  Redis源码阅读(十四) 有序集合对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-27 17:01:41 / 修改时间：18:25:26" itemprop="dateCreated datePublished" datetime="2018-08-27T17:01:41+08:00">2018-08-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis 有序集合和集合一样也是string类型元素的集合，且不允许重复的成员，不同的是每个元素都会关联一个double类型的分数，redis通过分数来为集合中的成员进行从小到大的排序，有序集合的成员是唯一的,但分数(score)却可以重复。集合中最大的成员数为 2^32 - 1 。</p>
<h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h3><p>有序集合对象的编码可以是ZIPLIST或SKIPLIST。</p>
<p>ZIPLIST编码的有序集合对象使用压缩列表作为底层实现，每个元素使用两个挨在一起的结点保存，第一个保存成员member，第二个保存分数score。</p>
<p>SKIPLIST编码的有序集合对象使用ZSET结构作为底层实现，包括了一个跳跃表，一个字典。zsl跳跃表按照分数值从小到大保存了集合的成员，跳跃表结点object属性保存成员，score属性保存成员的分数值。dict字典保存了成员到分数的映射，每个键值对都是一个集合成员，字典的键保存成员，字典的值保存成员的分数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    <span class="comment">// 字典</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    <span class="comment">// 跳跃表</span></span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用字典和跳跃表保存有序集合成员是为了更好的优化操作。在获取成员和分数时，使用字典可以有效减少查询时间，在进行RANK等操作时，由于字典的无序，遍历查询效果很低，所以使用跳跃表的方式可以减少查询时间。</p>
</blockquote>
<h3 id="2-编码转换"><a href="#2-编码转换" class="headerlink" title="2. 编码转换"></a>2. 编码转换</h3><p>当有序集合对象满足下面条件时使用ZIPLIST编码：</p>
<ol>
<li>有序集合对象存储的所有元素成员长度小于64字节。</li>
<li>有序集合对象存储的元素个数不超过128.</li>
</ol>
<blockquote>
<p>配置文件中zset-max-ziplist-value和zset-max-ziplist-entries可以修改其上限</p>
</blockquote>
<h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3. 命令"></a>3. 命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td>ZCARD</td>
<td>获取有序集合的成员数</td>
</tr>
<tr>
<td>ZCOUNT</td>
<td>计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td>ZINCRBY</td>
<td>有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td>ZINTERSTORE</td>
<td>计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td>ZLEXCOUNT</td>
<td>在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>通过索引区间返回有序集合成指定区间内的成员</td>
</tr>
<tr>
<td>ZRANGEBYLEX</td>
<td>通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td>ZRANGEBYSCORE</td>
<td>通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td>ZRANK</td>
<td>返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td>ZREM</td>
<td>移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td>ZREMRANGEBYLEX</td>
<td>移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYRANK</td>
<td>移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td>ZREMRANGEBYSCORE</td>
<td>移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td>ZREVRANGE</td>
<td>返回有序集中指定区间内的成员，通过索引，分数从高到底</td>
</tr>
<tr>
<td>ZREVRANGEBYSCORE</td>
<td>返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td>ZREVRANK</td>
<td>返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td>ZSCORE</td>
<td>返回有序集中，成员的分数值</td>
</tr>
<tr>
<td>ZUNIONSTORE</td>
<td>计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td>ZSCAN</td>
<td>迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody>
</table>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>编码转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zsetConvert</span><span class="params">(robj *zobj, <span class="keyword">int</span> encoding)</span> </span>&#123;</span><br><span class="line">    zset *zs;</span><br><span class="line">    zskiplistNode *node, *next;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要转换</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == encoding) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ZIPLIST 转 SKIPLIST</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = zobj-&gt;ptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr, *sptr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *vstr;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> vlong;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoding != OBJ_ENCODING_SKIPLIST)</span><br><span class="line">            serverPanic(<span class="string">"Unknown target encoding"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分配跳跃表空间</span></span><br><span class="line">        zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">        <span class="comment">// 创建字典</span></span><br><span class="line">        zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 创建跳跃表</span></span><br><span class="line">        zs-&gt;zsl = zslCreate();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 首地址</span></span><br><span class="line">        eptr = ziplistIndex(zl,<span class="number">0</span>);</span><br><span class="line">        serverAssertWithInfo(<span class="literal">NULL</span>,zobj,eptr != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 分数地址</span></span><br><span class="line">        sptr = ziplistNext(zl,eptr);</span><br><span class="line">        serverAssertWithInfo(<span class="literal">NULL</span>,zobj,sptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        <span class="keyword">while</span> (eptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取分数</span></span><br><span class="line">            score = zzlGetScore(sptr);</span><br><span class="line">            serverAssertWithInfo(<span class="literal">NULL</span>,zobj,ziplistGet(eptr,&amp;vstr,&amp;vlen,&amp;vlong));</span><br><span class="line">            <span class="comment">// 创建分数字符串</span></span><br><span class="line">            <span class="keyword">if</span> (vstr == <span class="literal">NULL</span>)</span><br><span class="line">                ele = sdsfromlonglong(vlong);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ele = sdsnewlen((<span class="keyword">char</span>*)vstr,vlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 插入分数结点</span></span><br><span class="line">            node = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            <span class="comment">// 添加到字典</span></span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;node-&gt;score) == DICT_OK);</span><br><span class="line">            zzlNext(zl,&amp;eptr,&amp;sptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放之前的跳跃表</span></span><br><span class="line">        zfree(zobj-&gt;ptr);</span><br><span class="line">        <span class="comment">// 指向新的压缩列表</span></span><br><span class="line">        zobj-&gt;ptr = zs;</span><br><span class="line">        <span class="comment">// 编码修改</span></span><br><span class="line">        zobj-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// SKIPLIST 转 ZIPLIST</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (encoding != OBJ_ENCODING_ZIPLIST)</span><br><span class="line">            serverPanic(<span class="string">"Unknown target encoding"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Approach similar to zslFree(), since we want to free the skiplist at</span></span><br><span class="line"><span class="comment">         * the same time as creating the ziplist. */</span></span><br><span class="line">        <span class="comment">// 获取当前压缩列表地址</span></span><br><span class="line">        zs = zobj-&gt;ptr;</span><br><span class="line">        <span class="comment">// 释放字典</span></span><br><span class="line">        dictRelease(zs-&gt;dict);</span><br><span class="line">        <span class="comment">// 跳跃表头结点</span></span><br><span class="line">        node = zs-&gt;zsl-&gt;header-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">        <span class="comment">// 释放头结点</span></span><br><span class="line">        zfree(zs-&gt;zsl-&gt;header);</span><br><span class="line">        zfree(zs-&gt;zsl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历跳跃表</span></span><br><span class="line">        <span class="keyword">while</span> (node) &#123;</span><br><span class="line">            <span class="comment">// 插入新结点到压缩列表</span></span><br><span class="line">            zl = zzlInsertAt(zl,<span class="literal">NULL</span>,node-&gt;ele,node-&gt;score);</span><br><span class="line">            <span class="comment">// 下个结点</span></span><br><span class="line">            next = node-&gt;level[<span class="number">0</span>].forward;</span><br><span class="line">            <span class="comment">// 释放跳跃表结点</span></span><br><span class="line">            zslFreeNode(node);</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放跳跃表</span></span><br><span class="line">        zfree(zs);</span><br><span class="line">        <span class="comment">// 有序接对象指向压缩列表</span></span><br><span class="line">        zobj-&gt;ptr = zl;</span><br><span class="line">        <span class="comment">// 编码</span></span><br><span class="line">        zobj-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加成员</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetAdd</span><span class="params">(robj *zobj, <span class="keyword">double</span> score, sds ele, <span class="keyword">int</span> *flags, <span class="keyword">double</span> *newscore)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="keyword">int</span> incr = (*flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (*flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (*flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    *flags = <span class="number">0</span>; <span class="comment">/* We'll return our response flags. */</span></span><br><span class="line">    <span class="keyword">double</span> curscore;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NaN as input is an error regardless of all the other parameters. */</span></span><br><span class="line">    <span class="comment">// 判断分数释放合法</span></span><br><span class="line">    <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">        *flags = ZADD_NAN;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the sorted set according to its encoding. */</span></span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 压缩列表中查找结点</span></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,&amp;curscore)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="comment">// NX 表不存在则添加</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                <span class="comment">// 存在则直接返回</span></span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="comment">// 递增</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                <span class="comment">// 计算新分数</span></span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="comment">// 判断分数合法</span></span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 记录新分数</span></span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changed. */</span></span><br><span class="line">            <span class="comment">// 分数要更新</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                <span class="comment">// 删除原有成员和分数</span></span><br><span class="line">                zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">                <span class="comment">// 添加新的成员分数</span></span><br><span class="line">                zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line">                <span class="comment">// 标识更新</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            <span class="comment">/* Optimize: check if the element is too large or the list</span></span><br><span class="line"><span class="comment">             * becomes too long *before* executing zzlInsert. */</span></span><br><span class="line">            <span class="comment">// 压缩列表中直接插入</span></span><br><span class="line">            zobj-&gt;ptr = zzlInsert(zobj-&gt;ptr,ele,score);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据有序集合长度，判断是否需要转换编码</span></span><br><span class="line">            <span class="keyword">if</span> (zzlLength(zobj-&gt;ptr) &gt; server.zset_max_ziplist_entries)</span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">            <span class="keyword">if</span> (sdslen(ele) &gt; server.zset_max_ziplist_value)</span><br><span class="line">                zsetConvert(zobj,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 获取跳跃表</span></span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        zskiplistNode *znode;</span><br><span class="line">        dictEntry *de;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找跳跃表中的ele</span></span><br><span class="line">        de = dictFind(zs-&gt;dict,ele);</span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* NX? Return, same element already exists. */</span></span><br><span class="line">            <span class="comment">// 不存在才操作，存在则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (nx) &#123;</span><br><span class="line">                *flags |= ZADD_NOP;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取当前分数值</span></span><br><span class="line">            curscore = *(<span class="keyword">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Prepare the score for the increment if needed. */</span></span><br><span class="line">            <span class="comment">// 递增</span></span><br><span class="line">            <span class="keyword">if</span> (incr) &#123;</span><br><span class="line">                score += curscore;</span><br><span class="line">                <span class="keyword">if</span> (isnan(score)) &#123;</span><br><span class="line">                    *flags |= ZADD_NAN;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Remove and re-insert when score changes. */</span></span><br><span class="line">            <span class="comment">// 判断分数需要修改</span></span><br><span class="line">            <span class="keyword">if</span> (score != curscore) &#123;</span><br><span class="line">                zskiplistNode *node;</span><br><span class="line">                <span class="comment">// 删除原有结点</span></span><br><span class="line">                serverAssert(zslDelete(zs-&gt;zsl,curscore,ele,&amp;node));</span><br><span class="line">                <span class="comment">// 插入新的分数结点</span></span><br><span class="line">                znode = zslInsert(zs-&gt;zsl,score,node-&gt;ele);</span><br><span class="line">                <span class="comment">/* We reused the node-&gt;ele SDS string, free the node now</span></span><br><span class="line"><span class="comment">                 * since zslInsert created a new one. */</span></span><br><span class="line">                <span class="comment">// 释放之前的结点</span></span><br><span class="line">                node-&gt;ele = <span class="literal">NULL</span>;</span><br><span class="line">                zslFreeNode(node);</span><br><span class="line">                <span class="comment">/* Note that we did not removed the original element from</span></span><br><span class="line"><span class="comment">                 * the hash table representing the sorted set, so we just</span></span><br><span class="line"><span class="comment">                 * update the score. */</span></span><br><span class="line">                <span class="comment">// 更新结点的分数</span></span><br><span class="line">                dictGetVal(de) = &amp;znode-&gt;score; <span class="comment">/* Update score ptr. */</span></span><br><span class="line">                *flags |= ZADD_UPDATED;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!xx) &#123;</span><br><span class="line">            <span class="comment">// 复制成员字符串</span></span><br><span class="line">            ele = sdsdup(ele);</span><br><span class="line">            <span class="comment">// 添加新结点</span></span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,ele);</span><br><span class="line">            serverAssert(dictAdd(zs-&gt;dict,ele,&amp;znode-&gt;score) == DICT_OK);</span><br><span class="line">            *flags |= ZADD_ADDED;</span><br><span class="line">            <span class="keyword">if</span> (newscore) *newscore = score;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            *flags |= ZADD_NOP;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* Never reached. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除成员</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zsetDel</span><span class="params">(robj *zobj, sds ele)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *eptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找结点，并删除</span></span><br><span class="line">        <span class="keyword">if</span> ((eptr = zzlFind(zobj-&gt;ptr,ele,<span class="literal">NULL</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            zobj-&gt;ptr = zzlDelete(zobj-&gt;ptr,eptr);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (zobj-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">        <span class="comment">// 跳跃表</span></span><br><span class="line">        zset *zs = zobj-&gt;ptr;</span><br><span class="line">        dictEntry *de;</span><br><span class="line">        <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 软删除结点</span></span><br><span class="line">        de = dictUnlink(zs-&gt;dict,ele);</span><br><span class="line">        <span class="keyword">if</span> (de != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Get the score in order to delete from the skiplist later. */</span></span><br><span class="line">            <span class="comment">// 获取分数</span></span><br><span class="line">            score = *(<span class="keyword">double</span>*)dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Delete from the hash table and later from the skiplist.</span></span><br><span class="line"><span class="comment">             * Note that the order is important: deleting from the skiplist</span></span><br><span class="line"><span class="comment">             * actually releases the SDS string representing the element,</span></span><br><span class="line"><span class="comment">             * which is shared between the skiplist and the hash table, so</span></span><br><span class="line"><span class="comment">             * we need to delete from the skiplist as the final step. */</span></span><br><span class="line">            dictFreeUnlinkedEntry(zs-&gt;dict,de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Delete from skiplist. */</span></span><br><span class="line">            <span class="keyword">int</span> retval = zslDelete(zs-&gt;zsl,score,ele,<span class="literal">NULL</span>);</span><br><span class="line">            serverAssert(retval);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (htNeedsResize(zs-&gt;dict)) dictResize(zs-&gt;dict);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No such element found. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>ZADD命令底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zaddGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> *nanerr = <span class="string">"resulting score is not a number (NaN)"</span>;</span><br><span class="line">    robj *key = c-&gt;argv[<span class="number">1</span>];</span><br><span class="line">    robj *zobj;</span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score = <span class="number">0</span>, *scores = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> j, elements;</span><br><span class="line">    <span class="keyword">int</span> scoreidx = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* The following vars are used in order to track what the command actually</span></span><br><span class="line"><span class="comment">     * did during the execution, to reply to the client and to trigger the</span></span><br><span class="line"><span class="comment">     * notification of keyspace change. */</span></span><br><span class="line">    <span class="keyword">int</span> added = <span class="number">0</span>;      <span class="comment">/* Number of new elements added. */</span></span><br><span class="line">    <span class="keyword">int</span> updated = <span class="number">0</span>;    <span class="comment">/* Number of elements with updated score. */</span></span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;  <span class="comment">/* Number of elements processed, may remain zero with</span></span><br><span class="line"><span class="comment">                           options like XX. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Parse options. At the end 'scoreidx' is set to the argument position</span></span><br><span class="line"><span class="comment">     * of the score of the first score-element pair. */</span></span><br><span class="line">    <span class="comment">// 解析命令参数选项</span></span><br><span class="line">    scoreidx = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(scoreidx &lt; c-&gt;argc) &#123;</span><br><span class="line">        <span class="keyword">char</span> *opt = c-&gt;argv[scoreidx]-&gt;ptr;</span><br><span class="line">        <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"nx"</span>)) flags |= ZADD_NX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"xx"</span>)) flags |= ZADD_XX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"ch"</span>)) flags |= ZADD_CH;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(opt,<span class="string">"incr"</span>)) flags |= ZADD_INCR;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        scoreidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Turn options into simple to check vars. */</span></span><br><span class="line">    <span class="comment">// 设置flag对应的选项</span></span><br><span class="line">    <span class="keyword">int</span> incr = (flags &amp; ZADD_INCR) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nx = (flags &amp; ZADD_NX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> xx = (flags &amp; ZADD_XX) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ch = (flags &amp; ZADD_CH) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* After the options, we expect to have an even number of args, since</span></span><br><span class="line"><span class="comment">     * we expect any number of score-element pairs. */</span></span><br><span class="line">    <span class="comment">// 计算元素个数</span></span><br><span class="line">    elements = c-&gt;argc-scoreidx;</span><br><span class="line">    <span class="keyword">if</span> (elements % <span class="number">2</span> || !elements) &#123;</span><br><span class="line">        <span class="comment">// 回复客户端错误</span></span><br><span class="line">        addReply(c,shared.syntaxerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    elements /= <span class="number">2</span>; <span class="comment">/* Now this holds the number of score-element pairs. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check for incompatible options. */</span></span><br><span class="line">    <span class="comment">// 不合法的选项参数，回复客户端错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (nx &amp;&amp; xx) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">"XX and NX options at the same time are not compatible"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (incr &amp;&amp; elements &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,</span><br><span class="line">            <span class="string">"INCR option supports a single increment-element pair"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start parsing all the scores, we need to emit any syntax error</span></span><br><span class="line"><span class="comment">     * before executing additions to the sorted set, as the command should</span></span><br><span class="line"><span class="comment">     * either execute fully or nothing at all. */</span></span><br><span class="line">    <span class="comment">// 存储所有成员分数</span></span><br><span class="line">    scores = zmalloc(<span class="keyword">sizeof</span>(<span class="keyword">double</span>)*elements);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getDoubleFromObjectOrReply(c,c-&gt;argv[scoreidx+j*<span class="number">2</span>],&amp;scores[j],<span class="literal">NULL</span>)</span><br><span class="line">            != C_OK) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lookup the key and create the sorted set if does not exist. */</span></span><br><span class="line">    <span class="comment">// db中查询有序集合对象</span></span><br><span class="line">    zobj = lookupKeyWrite(c-&gt;db,key);</span><br><span class="line">    <span class="keyword">if</span> (zobj == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// xx标志(存在则继续)，直接回复客户端</span></span><br><span class="line">        <span class="keyword">if</span> (xx) <span class="keyword">goto</span> reply_to_client; <span class="comment">/* No key + XX option: nothing to do. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据配置参数判断有序集合底层编码</span></span><br><span class="line">        <span class="keyword">if</span> (server.zset_max_ziplist_entries == <span class="number">0</span> ||</span><br><span class="line">            server.zset_max_ziplist_value &lt; sdslen(c-&gt;argv[scoreidx+<span class="number">1</span>]-&gt;ptr))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// SKIPLIST</span></span><br><span class="line">            zobj = createZsetObject();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ZIPLIST</span></span><br><span class="line">            zobj = createZsetZiplistObject();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// db中添加有序集合对象</span></span><br><span class="line">        dbAdd(c-&gt;db,key,zobj);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到类型错误，则回复客户端</span></span><br><span class="line">        <span class="keyword">if</span> (zobj-&gt;type != OBJ_ZSET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历所有成员</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; elements; j++) &#123;</span><br><span class="line">        <span class="keyword">double</span> newscore;</span><br><span class="line">        <span class="comment">// 获取分数</span></span><br><span class="line">        score = scores[j];</span><br><span class="line">        <span class="keyword">int</span> retflags = flags;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取成员字符串</span></span><br><span class="line">        ele = c-&gt;argv[scoreidx+<span class="number">1</span>+j*<span class="number">2</span>]-&gt;ptr;</span><br><span class="line">        <span class="comment">// 添加成员和分数到有序集合</span></span><br><span class="line">        <span class="keyword">int</span> retval = zsetAdd(zobj, score, ele, &amp;retflags, &amp;newscore);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyError(c,nanerr);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据不同标识，计算不同操作的数量</span></span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_ADDED) added++;</span><br><span class="line">        <span class="keyword">if</span> (retflags &amp; ZADD_UPDATED) updated++;</span><br><span class="line">        <span class="keyword">if</span> (!(retflags &amp; ZADD_NOP)) processed++;</span><br><span class="line">        score = newscore;</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += (added+updated);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同命令直接回复客户端</span></span><br><span class="line">reply_to_client:</span><br><span class="line">    <span class="keyword">if</span> (incr) &#123; <span class="comment">/* ZINCRBY or INCR option. */</span></span><br><span class="line">        <span class="keyword">if</span> (processed)</span><br><span class="line">            addReplyDouble(c,score);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">/* ZADD. */</span></span><br><span class="line">        addReplyLongLong(c,ch ? added+updated : added);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清除分数数组</span></span><br><span class="line">cleanup:</span><br><span class="line">    zfree(scores);</span><br><span class="line">    <span class="comment">// 有添加或更新的则发送数据库有键发生修改</span></span><br><span class="line">    <span class="keyword">if</span> (added || updated) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,key);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_ZSET,</span><br><span class="line">            incr ? <span class="string">"zincr"</span> : <span class="string">"zadd"</span>, key, c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/23/redis/13_集合对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/23/redis/13_集合对象/" itemprop="url">
                  Redis源码阅读(十三) 集合对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-23 11:06:47 / 修改时间：11:06:49" itemprop="dateCreated datePublished" datetime="2018-08-23T11:06:47+08:00">2018-08-23</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis的集合是Sting类型的无序集合，集合成员唯一，集合中最大的成员数为 2^32 - 1 </p>
<h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h3><p>集合对象的编码可以是INTSET或HT。</p>
<p>INTSET编码的集合对象使用整数集合作为底层实现，集合对象的所有元素都存储在整数集合中。</p>
<p>HT编码的集合对象使用字典作为底层实现，每个字符串对象(字典的键)包含了一个集合元素，而字典的值为NULL。</p>
<h3 id="2-编码转换"><a href="#2-编码转换" class="headerlink" title="2. 编码转换"></a>2. 编码转换</h3><p>当集合对象满足下面条件时使用INTSET编码：</p>
<ol>
<li>集合对象存储的所有元素都为整数值。</li>
<li>集合对象存储的元素个数不超过512.</li>
</ol>
<blockquote>
<p>配置文件中set-max-intset-entries可以修改元素个数的上线</p>
</blockquote>
<p>当对INTSET编码的集合对象进行一些操作致使无法使用INTSET编码是，则将集合对象转换成HT编码，INTSET中保存的键值对会移动到新的字典中。</p>
<h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3. 命令"></a>3. 命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>向集合添加一个或多个成员</td>
</tr>
<tr>
<td>SCARD</td>
<td>获取集合的成员数</td>
</tr>
<tr>
<td>SDIFF</td>
<td>返回给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE</td>
<td>返回给定所有集合的差集并存储在 dst 中</td>
</tr>
<tr>
<td>SINTER</td>
<td>返回给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE</td>
<td>返回给定所有集合的交集并存储在 dst 中</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>判断 member 元素是否是集合 key 的成员</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合中的所有成员</td>
</tr>
<tr>
<td>SMOVE</td>
<td>将 member 元素从 src 集合移动到 dst 集合</td>
</tr>
<tr>
<td>SPOP</td>
<td>移除并返回集合中的一个随机元素</td>
</tr>
<tr>
<td>SRANDMEMBER</td>
<td>返回集合中一个或多个随机数</td>
</tr>
<tr>
<td>SREM</td>
<td>移除集合中一个或多个成员</td>
</tr>
<tr>
<td>SUNION</td>
<td>返回所有给定集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE</td>
<td>所有给定集合的并集存储在 dst 集合中</td>
</tr>
<tr>
<td>SSCAN</td>
<td>迭代集合中的元素</td>
</tr>
</tbody>
</table>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>编码转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTypeConvert</span><span class="params">(robj *setobj, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    setTypeIterator *si;</span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,setobj,setobj-&gt;type == OBJ_SET &amp;&amp;</span><br><span class="line">                             setobj-&gt;encoding == OBJ_ENCODING_INTSET);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="keyword">int64_t</span> intele;</span><br><span class="line">        <span class="comment">// 创建字典对象</span></span><br><span class="line">        dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">        sds element;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Presize the dict to avoid rehashing */</span></span><br><span class="line">        <span class="comment">// 根据集合元素个数扩容</span></span><br><span class="line">        dictExpand(d,intsetLen(setobj-&gt;ptr));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* To add the elements we extract integers and create redis objects */</span></span><br><span class="line">        <span class="comment">// 迭代整数集合</span></span><br><span class="line">        si = setTypeInitIterator(setobj);</span><br><span class="line">        <span class="keyword">while</span> (setTypeNext(si,&amp;element,&amp;intele) != <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 转换值为long long</span></span><br><span class="line">            element = sdsfromlonglong(intele);</span><br><span class="line">            <span class="comment">// 存储在字典中</span></span><br><span class="line">            serverAssert(dictAdd(d,element,<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放迭代器</span></span><br><span class="line">        setTypeReleaseIterator(si);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置编码</span></span><br><span class="line">        setobj-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">        <span class="comment">// 释放整数集合内存空间</span></span><br><span class="line">        zfree(setobj-&gt;ptr);</span><br><span class="line">        <span class="comment">// 集合对象新的底层结构为字典</span></span><br><span class="line">        setobj-&gt;ptr = d;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unsupported set conversion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加成员</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SADD key member1 [member2] </span></span><br><span class="line"><span class="comment"> * 向集合添加一个或多个成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, added = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找指定key的集合对象</span></span><br><span class="line">    <span class="built_in">set</span> = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">set</span> == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 集合对象不存在，则创建一个</span></span><br><span class="line">        <span class="built_in">set</span> = setTypeCreate(c-&gt;argv[<span class="number">2</span>]-&gt;ptr);</span><br><span class="line">        <span class="comment">// 添加集合对象到db</span></span><br><span class="line">        dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="built_in">set</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 集合存在但类型不对，回复客户端</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">set</span>-&gt;type != OBJ_SET) &#123;</span><br><span class="line">            addReply(c,shared.wrongtypeerr);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 变量参数列表，添加成员到集合对象中</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (setTypeAdd(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) added++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有添加的则通知数据库有key发生改变，并发送"sadd"事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (added) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"sadd"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += added;</span><br><span class="line">    addReplyLongLong(c,added);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加成员底层处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setTypeAdd</span><span class="params">(robj *subject, sds value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据不同编码进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_HT) &#123; <span class="comment">// HT编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取集合对象哈希表</span></span><br><span class="line">        dict *ht = subject-&gt;ptr;</span><br><span class="line">        <span class="comment">// 添加字典entry</span></span><br><span class="line">        dictEntry *de = dictAddRaw(ht,value,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 设置字典的值</span></span><br><span class="line">            dictSetKey(ht,de,sdsdup(value));</span><br><span class="line">            dictSetVal(ht,de,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (subject-&gt;encoding == OBJ_ENCODING_INTSET) &#123; <span class="comment">// INTSET编码</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果要添加的值可以用long long表示</span></span><br><span class="line">        <span class="keyword">if</span> (isSdsRepresentableAsLongLong(value,&amp;llval) == C_OK) &#123;</span><br><span class="line">            <span class="keyword">uint8_t</span> success = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 添加到整数集合intset</span></span><br><span class="line">            subject-&gt;ptr = intsetAdd(subject-&gt;ptr,llval,&amp;success);</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                <span class="comment">/* Convert to regular set when the intset contains</span></span><br><span class="line"><span class="comment">                 * too many entries. */</span></span><br><span class="line">                <span class="keyword">if</span> (intsetLen(subject-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Failed to get integer from object, convert to regular set. */</span></span><br><span class="line">            <span class="comment">// 否则转换为HT编码</span></span><br><span class="line">            setTypeConvert(subject,OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The set *was* an intset and this value is not integer</span></span><br><span class="line"><span class="comment">             * encodable, so dictAdd should always work. */</span></span><br><span class="line">            <span class="comment">// 进行value添加</span></span><br><span class="line">            serverAssert(dictAdd(subject-&gt;ptr,sdsdup(value),<span class="literal">NULL</span>) == DICT_OK);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除成员</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SREM key member1 [member2]</span></span><br><span class="line"><span class="comment"> * 移除集合中一个或多个成员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sremCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    robj *<span class="built_in">set</span>;</span><br><span class="line">    <span class="keyword">int</span> j, deleted = <span class="number">0</span>, keyremoved = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找指定key的集合对象，并判断类型</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">set</span> = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.czero)) == <span class="literal">NULL</span> ||</span><br><span class="line">        checkType(c,<span class="built_in">set</span>,OBJ_SET)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历要移除的参数列表</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 从集合对象中移除成员</span></span><br><span class="line">        <span class="keyword">if</span> (setTypeRemove(<span class="built_in">set</span>,c-&gt;argv[j]-&gt;ptr)) &#123;</span><br><span class="line">            deleted++;</span><br><span class="line">            <span class="comment">// 若集合对象为空，则从db中删除该集合对象</span></span><br><span class="line">            <span class="keyword">if</span> (setTypeSize(<span class="built_in">set</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">                keyremoved = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除成员，需要通知数据库key发生变化，并发送"srem"事件</span></span><br><span class="line">    <span class="keyword">if</span> (deleted) &#123;</span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_SET,<span class="string">"srem"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果删除了集合对象，需要发送"del"事件</span></span><br><span class="line">        <span class="keyword">if</span> (keyremoved)</span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,c-&gt;argv[<span class="number">1</span>],</span><br><span class="line">                                c-&gt;db-&gt;id);</span><br><span class="line">        server.dirty += deleted;</span><br><span class="line">    &#125;</span><br><span class="line">    addReplyLongLong(c,deleted);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/22/redis/12_哈希对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/22/redis/12_哈希对象/" itemprop="url">
                  Redis源码阅读(十二) 哈希对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-22 12:46:13" itemprop="dateCreated datePublished" datetime="2018-08-22T12:46:13+08:00">2018-08-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-23 10:50:12" itemprop="dateModified" datetime="2018-08-23T10:50:12+08:00">2018-08-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis的哈希对象是一个string类型的field和value的映射表，特别适合用于存储对象，每个 hash 可以存储 2^32 - 1 键值对。</p>
<h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h3><p>Redis中哈希对象的编码有ZIPLIST和HT。</p>
<p>ziplist编码的哈希对象使用压缩列表作为底层实现，有新的键值对插入时，现将键插入的压缩列表尾部，再将值插入的压缩列表尾部，这样键值对总是紧密挨在一起的。</p>
<p>hashtable编码的哈希对象使用字典作为底层实现，每个键值对都用字典的键值对保存。</p>
<h3 id="2-编码转换"><a href="#2-编码转换" class="headerlink" title="2. 编码转换"></a>2. 编码转换</h3><p>当哈希对象满足以下条件时，使用ZIPLIST编码：</p>
<ol>
<li>哈希对象保存的所有键值对的字符串长度小于64字节。</li>
<li>哈希对象保存的键值对个数小于512</li>
</ol>
<blockquote>
<p>这两个参数可以通过hash-max-ziplist-value和hash-max-ziplist-entries修改。</p>
</blockquote>
<p>当对ziplist编码的哈希对象进行一些操作致使无法使用ziplist编码是，则将哈希对象转换成HT编码，ziplist中保存的键值对会移动到新的字典中。</p>
<blockquote>
<p>目前仅实现了ZIPLIST ==&gt; HT的编码转换</p>
</blockquote>
<h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3. 命令"></a>3. 命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HDEL</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HEXISTS</td>
<td>查看哈希表 key 中，指定的字段是否存在</td>
</tr>
<tr>
<td>HGET</td>
<td>获取存储在哈希表中指定字段的值</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td>HINCRBY</td>
<td>为哈希表 key 中的指定字段的整数值加上增量 increment</td>
</tr>
<tr>
<td>HINCRBYFLOAT</td>
<td>为哈希表 key 中的指定字段的浮点数值加上增量 increment</td>
</tr>
<tr>
<td>HKEYS</td>
<td>获取所有哈希表中的字段</td>
</tr>
<tr>
<td>HLEN</td>
<td>获取哈希表中字段的数量</td>
</tr>
<tr>
<td>HMGET</td>
<td>获取所有给定字段的值</td>
</tr>
<tr>
<td>HMSET</td>
<td>同时将多个 field-value (域-值)对设置到哈希表 key 中</td>
</tr>
<tr>
<td>HSET</td>
<td>将哈希表 key 中的字段 field 的值设为 value</td>
</tr>
<tr>
<td>HSETNX</td>
<td>只有在字段 field 不存在时，设置哈希表字段的值</td>
</tr>
<tr>
<td>HSTRLEN</td>
<td>获取哈希表字段值的长度</td>
</tr>
<tr>
<td>HVALS</td>
<td>获取哈希表中所有值</td>
</tr>
<tr>
<td>HSCAN</td>
<td>迭代哈希表中的键值对</td>
</tr>
</tbody>
</table>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>哈希表中添加键值对</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeSet</span><span class="params">(robj *o, sds field, sds value, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据编码的不同进行处理</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 获取ziplist的头结点指针</span></span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找field的位置</span></span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">                vptr = ziplistNext(zl, fptr);</span><br><span class="line">                serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">                <span class="comment">// 找到该field</span></span><br><span class="line">                update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Delete value */</span></span><br><span class="line">                <span class="comment">// 删除ziplist中的field</span></span><br><span class="line">                zl = ziplistDelete(zl, &amp;vptr);</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* Insert new value */</span></span><br><span class="line">                <span class="comment">// 插入新的值</span></span><br><span class="line">                zl = ziplistInsert(zl, vptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</span><br><span class="line">                        sdslen(value));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是更新，则插入新的field和value到ziplist尾部</span></span><br><span class="line">        <span class="keyword">if</span> (!update) &#123;</span><br><span class="line">            <span class="comment">/* Push new field/value pair onto the tail of the ziplist */</span></span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">            zl = ziplistPush(zl, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value, sdslen(value),</span><br><span class="line">                    ZIPLIST_TAIL);</span><br><span class="line">        &#125;</span><br><span class="line">        o-&gt;ptr = zl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Check if the ziplist needs to be converted to a hash table */</span></span><br><span class="line">        <span class="comment">// 检查是否需要将ziplist转换为哈希表</span></span><br><span class="line">        <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找field结点</span></span><br><span class="line">        dictEntry *de = dictFind(o-&gt;ptr,field);</span><br><span class="line">        <span class="keyword">if</span> (de) &#123;</span><br><span class="line">            <span class="comment">// 找到则先释放之前的内容</span></span><br><span class="line">            sdsfree(dictGetVal(de));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// HASH_SET_TAKE_VALUE 表示拿走value的值</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                dictGetVal(de) = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 其他的则是复制value</span></span><br><span class="line">                dictGetVal(de) = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            update = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sds f,v;</span><br><span class="line">            <span class="comment">// HASH_SET_TAKE_FIELD 表示拿走field</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD) &#123;</span><br><span class="line">                f = field;</span><br><span class="line">                field = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 复制field</span></span><br><span class="line">                f = sdsdup(field);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE) &#123;</span><br><span class="line">                <span class="comment">// 拿走value</span></span><br><span class="line">                v = value;</span><br><span class="line">                value = <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 复制value</span></span><br><span class="line">                v = sdsdup(value);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加新结点</span></span><br><span class="line">            dictAdd(o-&gt;ptr,f,v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free SDS strings we did not referenced elsewhere if the flags</span></span><br><span class="line"><span class="comment">     * want this function to be responsible. */</span></span><br><span class="line">    <span class="comment">// 根据flags判断是否需要释放内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_FIELD &amp;&amp; field) sdsfree(field);</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; HASH_SET_TAKE_VALUE &amp;&amp; value) sdsfree(value);</span><br><span class="line">    <span class="keyword">return</span> update;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>哈希表中删除键值对</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeDelete</span><span class="params">(robj *o, sds field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> deleted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, *fptr;</span><br><span class="line"></span><br><span class="line">        zl = o-&gt;ptr;</span><br><span class="line">        <span class="comment">// 头结点地址</span></span><br><span class="line">        fptr = ziplistIndex(zl, ZIPLIST_HEAD);</span><br><span class="line">        <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 查找field的位置</span></span><br><span class="line">            fptr = ziplistFind(fptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field, sdslen(field), <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (fptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 找到则删除key和value</span></span><br><span class="line">                zl = ziplistDelete(zl,&amp;fptr); <span class="comment">/* Delete the key. */</span></span><br><span class="line">                zl = ziplistDelete(zl,&amp;fptr); <span class="comment">/* Delete the value. */</span></span><br><span class="line">                o-&gt;ptr = zl;</span><br><span class="line">                deleted = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// 删除字典中field</span></span><br><span class="line">        <span class="keyword">if</span> (dictDelete((dict*)o-&gt;ptr, field) == C_OK) &#123;</span><br><span class="line">            deleted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Always check if the dictionary needs a resize after a delete. */</span></span><br><span class="line">            <span class="comment">// 判断字典是否需要进行resize</span></span><br><span class="line">            <span class="keyword">if</span> (htNeedsResize(o-&gt;ptr)) dictResize(o-&gt;ptr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deleted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>迭代哈希表</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashTypeNext</span><span class="params">(hashTypeIterator *hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *fptr, *vptr;</span><br><span class="line"></span><br><span class="line">        zl = hi-&gt;subject-&gt;ptr;</span><br><span class="line">        fptr = hi-&gt;fptr;</span><br><span class="line">        vptr = hi-&gt;vptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ZIPLIST编码则获取cursor</span></span><br><span class="line">        <span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">/* Initialize cursor */</span></span><br><span class="line">            serverAssert(vptr == <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 初始化头部</span></span><br><span class="line">            fptr = ziplistIndex(zl, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Advance cursor */</span></span><br><span class="line">            serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line">            <span class="comment">// 获取下一个地址</span></span><br><span class="line">            fptr = ziplistNext(zl, vptr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代完成返回C_ERR</span></span><br><span class="line">        <span class="keyword">if</span> (fptr == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Grab pointer to the value (fptr points to the field) */</span></span><br><span class="line">        <span class="comment">// fptr指向key，获取对应的内容地址</span></span><br><span class="line">        vptr = ziplistNext(zl, fptr);</span><br><span class="line">        serverAssert(vptr != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* fptr, vptr now point to the first or next pair */</span></span><br><span class="line">        hi-&gt;fptr = fptr;</span><br><span class="line">        hi-&gt;vptr = vptr;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hi-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        <span class="comment">// HT编码直接进行字典迭代</span></span><br><span class="line">        <span class="keyword">if</span> ((hi-&gt;de = dictNext(hi-&gt;di)) == <span class="literal">NULL</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>哈希对象编码转换</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hashTypeConvertZiplist</span><span class="params">(robj *o, <span class="keyword">int</span> enc)</span> </span>&#123;</span><br><span class="line">    serverAssert(o-&gt;encoding == OBJ_ENCODING_ZIPLIST);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (enc == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">        <span class="comment">/* Nothing to do... */</span></span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (enc == OBJ_ENCODING_HT) &#123;</span><br><span class="line">        hashTypeIterator *hi;</span><br><span class="line">        dict *dict;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化哈希对象迭代器</span></span><br><span class="line">        hi = hashTypeInitIterator(o);</span><br><span class="line">        <span class="comment">// 创建新的字典对象</span></span><br><span class="line">        dict = dictCreate(&amp;hashDictType, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历当前哈希对象</span></span><br><span class="line">        <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">            sds key, value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 创建新的key</span></span><br><span class="line">            key = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_KEY);</span><br><span class="line">            <span class="comment">// 创建新的value</span></span><br><span class="line">            value = hashTypeCurrentObjectNewSds(hi,OBJ_HASH_VALUE);</span><br><span class="line">            <span class="comment">// 添加kv到字典</span></span><br><span class="line">            ret = dictAdd(dict, key, value);</span><br><span class="line">            <span class="keyword">if</span> (ret != DICT_OK) &#123;</span><br><span class="line">                <span class="comment">// 添加失败则返回错误日志信息</span></span><br><span class="line">                serverLogHexDump(LL_WARNING,<span class="string">"ziplist with dup elements dump"</span>,</span><br><span class="line">                    o-&gt;ptr,ziplistBlobLen(o-&gt;ptr));</span><br><span class="line">                serverPanic(<span class="string">"Ziplist corruption detected"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放迭代器</span></span><br><span class="line">        hashTypeReleaseIterator(hi);</span><br><span class="line">        zfree(o-&gt;ptr);</span><br><span class="line">        <span class="comment">// 修改编码</span></span><br><span class="line">        o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">        <span class="comment">// 指向新的字典</span></span><br><span class="line">        o-&gt;ptr = dict;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HGETALL底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">genericHgetallCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line">    hashTypeIterator *hi;</span><br><span class="line">    <span class="keyword">int</span> multiplier = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> length, count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定key的哈希对象</span></span><br><span class="line">    <span class="keyword">if</span> ((o = lookupKeyReadOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.emptymultibulk)) == <span class="literal">NULL</span></span><br><span class="line">        || checkType(c,o,OBJ_HASH)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算一对键值对要返回的个数</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY) multiplier++;</span><br><span class="line">    <span class="keyword">if</span> (flags &amp; OBJ_HASH_VALUE) multiplier++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算整个哈希对象所有键值对返回的个数</span></span><br><span class="line">    length = hashTypeLength(o) * multiplier;</span><br><span class="line">    <span class="comment">// 回复客户端要返回的个数</span></span><br><span class="line">    addReplyMultiBulkLen(c, length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化迭代器</span></span><br><span class="line">    hi = hashTypeInitIterator(o);</span><br><span class="line">    <span class="comment">// 迭代并回去结点，回复客户端</span></span><br><span class="line">    <span class="keyword">while</span> (hashTypeNext(hi) != C_ERR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; OBJ_HASH_KEY) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, OBJ_HASH_KEY);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; OBJ_HASH_VALUE) &#123;</span><br><span class="line">            addHashIteratorCursorToReply(c, hi, OBJ_HASH_VALUE);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    hashTypeReleaseIterator(hi);</span><br><span class="line">    serverAssert(count == length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HSET命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hsetCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, created = <span class="number">0</span>;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;argc % <span class="number">2</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"wrong number of arguments for HMSET"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定key的哈希对象，不存在则创建</span></span><br><span class="line">    <span class="keyword">if</span> ((o = hashTypeLookupWriteOrCreate(c,c-&gt;argv[<span class="number">1</span>])) == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否需要编码转换</span></span><br><span class="line">    hashTypeTryConversion(o,c-&gt;argv,<span class="number">2</span>,c-&gt;argc<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加多个kv对</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">2</span>; i &lt; c-&gt;argc; i += <span class="number">2</span>)</span><br><span class="line">        created += !hashTypeSet(o,c-&gt;argv[i]-&gt;ptr,c-&gt;argv[i+<span class="number">1</span>]-&gt;ptr,HASH_SET_COPY);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* HMSET (deprecated) and HSET return value is different. */</span></span><br><span class="line">    <span class="comment">// 实现了HMSET和HSET</span></span><br><span class="line">    <span class="keyword">char</span> *cmdname = c-&gt;argv[<span class="number">0</span>]-&gt;ptr;</span><br><span class="line">    <span class="keyword">if</span> (cmdname[<span class="number">1</span>] == <span class="string">'s'</span> || cmdname[<span class="number">1</span>] == <span class="string">'S'</span>) &#123;</span><br><span class="line">        <span class="comment">/* HSET */</span></span><br><span class="line">        addReplyLongLong(c, created);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* HMSET */</span></span><br><span class="line">        addReply(c, shared.ok);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通知数据库有key发生修改</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送"hset"事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_HASH,<span class="string">"hset"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    server.dirty++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/21/redis/11_列表对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/redis/11_列表对象/" itemprop="url">
                  Redis源码阅读(十一) 列表对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-21 12:58:57" itemprop="dateCreated datePublished" datetime="2018-08-21T12:58:57+08:00">2018-08-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-23 10:40:05" itemprop="dateModified" datetime="2018-08-23T10:40:05+08:00">2018-08-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis列表对象是简单的字符串列表，按照插入顺序排序，可以添加一个元素到头部或尾部，一个列表键最多可包含2^32-1个元素。</p>
<h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h3><p>Redis列表键的底层编码是QUICKLIST，而quicklist本质上就是以ziplist为结点的双端链表。</p>
<h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>LINDEX</td>
<td>根据索引index获取列表key中的元素</td>
</tr>
<tr>
<td>LINSERT</td>
<td>在列表key指定的元素pivot的前/后插入元素</td>
</tr>
<tr>
<td>LLEN</td>
<td>获取列表key的长度</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表key中移除第一个元素</td>
</tr>
<tr>
<td>LPUSH</td>
<td>在列表key中的头部插入一个或多个元素</td>
</tr>
<tr>
<td>LPUSHX</td>
<td>插入一个元素value到已经存在的列表key</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表key指定范围start,end的元素</td>
</tr>
<tr>
<td>LREM</td>
<td>移除列表元素</td>
</tr>
<tr>
<td>LSET</td>
<td>通过索引index设置列表中的元素</td>
</tr>
<tr>
<td>LTRIM</td>
<td>对一个列表进行修剪(trim)，就是说，让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除。</td>
</tr>
<tr>
<td>RPOP</td>
<td>移除并获取列表最后一个元素</td>
</tr>
<tr>
<td>RPOPLPUSH</td>
<td>移除列表的最后一个元素，并将该元素添加到另一个列表并返回</td>
</tr>
<tr>
<td>RPUSH</td>
<td>在列表中添加一个或多个值</td>
</tr>
<tr>
<td>RPUSHX</td>
<td>为已存在的列表添加值</td>
</tr>
</tbody>
</table>
<h3 id="3-阻塞命令"><a href="#3-阻塞命令" class="headerlink" title="3. 阻塞命令"></a>3. 阻塞命令</h3><p>Redis定义了阻塞状态，而每个客户端都有这样的一个状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">blockingState</span> &#123;</span>                                                                          </span><br><span class="line">    <span class="comment">/* Generic fields. */</span>     </span><br><span class="line">    <span class="comment">// 阻塞的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> timeout;       <span class="comment">/* Blocking operation timeout. If UNIX current time                         </span></span><br><span class="line"><span class="comment">                             * is &gt; timeout then the operation timed out. */</span>                            </span><br><span class="line">                                                                                                        </span><br><span class="line">    <span class="comment">/* BLOCKED_LIST */</span>      </span><br><span class="line">    <span class="comment">// 造成阻塞的键</span></span><br><span class="line">    dict *keys;             <span class="comment">/* The keys we are waiting to terminate a blocking                          </span></span><br><span class="line"><span class="comment">                             * operation such as BLPOP. Otherwise NULL. */</span> </span><br><span class="line">    <span class="comment">// 保存PUSH进来的元素，用于BRPOPLPUSH命令</span></span><br><span class="line">    robj *target;           <span class="comment">/* The key that should receive the element,                                 </span></span><br><span class="line"><span class="comment">                             * for BRPOPLPUSH. */</span>                                                       </span><br><span class="line">                                                                                                        </span><br><span class="line">    <span class="comment">/* BLOCKED_WAIT */</span>   </span><br><span class="line">    <span class="keyword">int</span> numreplicas;        <span class="comment">/* Number of replicas we are waiting for ACK. */</span>                            </span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> reploffset;   <span class="comment">/* Replication offset to reach. */</span>                                          </span><br><span class="line">                                                                                                        </span><br><span class="line">    <span class="comment">/* BLOCKED_MODULE */</span>                                                                                </span><br><span class="line">    <span class="keyword">void</span> *module_blocked_handle; <span class="comment">/* RedisModuleBlockedClient structure.                                 </span></span><br><span class="line"><span class="comment">                                    which is opaque for the Redis core, only                            </span></span><br><span class="line"><span class="comment">                                    handled in module.c. */</span>                                             </span><br><span class="line">&#125; blockingState; </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 保存着当前客户端的阻塞状态</span></span><br><span class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span>       </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span></span><br><span class="line">   	<span class="comment">// 处于阻塞状态的键</span></span><br><span class="line">    dict *blocking_keys;        <span class="comment">/* Keys with clients waiting for data (BLPOP)*/</span> </span><br><span class="line">    <span class="comment">// 收到PUSH操作时保存的键，避免重复操作</span></span><br><span class="line">    dict *ready_keys;           <span class="comment">/* Blocked keys that received a PUSH */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>blocking_keys</p>
<p>保存处于阻塞状态key的字典，每个key都是一个阻塞的键，而值是一个双端链表，表示被这个key所阻塞的客户端</p>
</li>
<li><p>bpop.keys</p>
<p>bpop是每个客户端保存的阻塞状态结构，其中key表示的是造成这个客户端阻塞的键。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>BLPOP</td>
<td>移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOP</td>
<td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
<tr>
<td>BRPOPLPUSH</td>
<td>从列表中弹出一个值，将弹出的元素插入到另外一个列表中并返回它； 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止。</td>
</tr>
</tbody>
</table>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>阻塞客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">blockForKeys</span><span class="params">(client *c, robj **keys, <span class="keyword">int</span> numkeys, <span class="keyword">mstime_t</span> timeout, robj *target)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 超时时间，和目标对象</span></span><br><span class="line">    c-&gt;bpop.timeout = timeout;</span><br><span class="line">    c-&gt;bpop.target = target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若target不为空，则增加其对象引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (target != <span class="literal">NULL</span>) incrRefCount(target);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历给定的keys</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numkeys; j++) &#123;</span><br><span class="line">        <span class="comment">/* If the key already exists in the dict ignore it. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将要阻塞的key放入bpop.keys字典中</span></span><br><span class="line">        <span class="keyword">if</span> (dictAdd(c-&gt;bpop.keys,keys[j],<span class="literal">NULL</span>) != DICT_OK) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 增加当前key的引用计数</span></span><br><span class="line">        incrRefCount(keys[j]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* And in the other "side", to map keys -&gt; clients */</span></span><br><span class="line">        <span class="comment">// db-&gt;blocking_keys, 是一个字典，键是阻塞key，值是一个双端链表，存储着被这个key阻塞的客户端</span></span><br><span class="line">        de = dictFind(c-&gt;db-&gt;blocking_keys,keys[j]);</span><br><span class="line">        <span class="keyword">if</span> (de == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* For every key we take a list of clients blocked for it */</span></span><br><span class="line">            <span class="comment">// 创建新的链表</span></span><br><span class="line">            l = listCreate();</span><br><span class="line">            <span class="comment">// 添加字典并存储阻塞key和这个链表</span></span><br><span class="line">            retval = dictAdd(c-&gt;db-&gt;blocking_keys,keys[j],l);</span><br><span class="line">            incrRefCount(keys[j]);</span><br><span class="line">            serverAssertWithInfo(c,keys[j],retval == DICT_OK);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l = dictGetVal(de);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 链表中添加该client</span></span><br><span class="line">        listAddNodeTail(l,c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞客户端</span></span><br><span class="line">    blockClient(c,BLOCKED_LIST);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解除阻塞</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * c-&gt;bpop.keys存储了客户端阻塞的键 </span></span><br><span class="line"><span class="comment"> * c-&gt;db-&gt;blocking_keys存储了当前DB对象阻塞的键</span></span><br><span class="line"><span class="comment"> * 要解除一个客户端的阻塞需要先遍历客户端阻塞的键，</span></span><br><span class="line"><span class="comment"> * 然后在DB中找到该键，删除其中存储的阻塞客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unblockClientWaitingData</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    <span class="built_in">list</span> *l;</span><br><span class="line"></span><br><span class="line">    serverAssertWithInfo(c,<span class="literal">NULL</span>,dictSize(c-&gt;bpop.keys) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字典迭代器，指向造成客户端阻塞的键的字段</span></span><br><span class="line">    di = dictGetIterator(c-&gt;bpop.keys);</span><br><span class="line">    <span class="comment">/* The client may wait for multiple keys, so unblock it for every key. */</span></span><br><span class="line">    <span class="comment">// 遍历阻塞键字典，因为同一个客户端可能被多个key阻塞</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取这个阻塞key</span></span><br><span class="line">        robj *key = dictGetKey(de);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove this client from the list of clients waiting for this key. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据阻塞的key，在 block_key ==&gt; client中查询阻塞客户端链表</span></span><br><span class="line">        l = dictFetchValue(c-&gt;db-&gt;blocking_keys,key);</span><br><span class="line">        serverAssertWithInfo(c,key,l != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查找并删除阻塞客户端链表中的客户端</span></span><br><span class="line">        listDelNode(l,listSearchKey(l,c));</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the list is empty we need to remove it to avoid wasting memory */</span></span><br><span class="line">        <span class="comment">// 链表为空后释放这个映射</span></span><br><span class="line">        <span class="keyword">if</span> (listLength(l) == <span class="number">0</span>)</span><br><span class="line">            dictDelete(c-&gt;db-&gt;blocking_keys,key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放迭代器</span></span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup the client structure */</span></span><br><span class="line">    <span class="comment">// 清除该客户端的阻塞key字典</span></span><br><span class="line">    dictEmpty(c-&gt;bpop.keys,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (c-&gt;bpop.target) &#123;</span><br><span class="line">        decrRefCount(c-&gt;bpop.target);</span><br><span class="line">        c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>PUSH命令底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pushGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j, pushed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key的对象</span></span><br><span class="line">    robj *lobj = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须是LIST类型</span></span><br><span class="line">    <span class="keyword">if</span> (lobj &amp;&amp; lobj-&gt;type != OBJ_LIST) &#123;</span><br><span class="line">        addReply(c,shared.wrongtypeerr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">2</span>; j &lt; c-&gt;argc; j++) &#123;</span><br><span class="line">        <span class="comment">// 若未找到该key，则创建新的quicklist, 并添加key到db</span></span><br><span class="line">        <span class="keyword">if</span> (!lobj) &#123;</span><br><span class="line">            lobj = createQuicklistObject();</span><br><span class="line">            <span class="comment">// 设置ziplist最大长度和压缩程度，又配置文件指定</span></span><br><span class="line">            quicklistSetOptions(lobj-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                                server.list_compress_depth);</span><br><span class="line">            <span class="comment">// 添加新的key对象和优化过编码的value</span></span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],lobj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// push一个value</span></span><br><span class="line">        listTypePush(lobj,c-&gt;argv[j],where);</span><br><span class="line">        pushed++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 回复客户端</span></span><br><span class="line">    addReplyLongLong(c, (lobj ? listTypeLength(lobj) : <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (pushed) &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">"lpush"</span> : <span class="string">"rpush"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知数据库有键修改</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送"lpush|rpush"事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">    &#125;</span><br><span class="line">    server.dirty += pushed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>POP命令底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">popGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> where)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取key列表对象</span></span><br><span class="line">    robj *o = lookupKeyWriteOrReply(c,c-&gt;argv[<span class="number">1</span>],shared.nullbulk);</span><br><span class="line">    <span class="comment">// 不存在或类型不匹配直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="literal">NULL</span> || checkType(c,o,OBJ_LIST)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pop出一个值</span></span><br><span class="line">    robj *value = listTypePop(o,where);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 为空直接回复客户端</span></span><br><span class="line">        addReply(c,shared.nullbulk);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> *event = (where == LIST_HEAD) ? <span class="string">"lpop"</span> : <span class="string">"rpop"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不为空回复客户端pop出的value</span></span><br><span class="line">        addReplyBulk(c,value);</span><br><span class="line">        decrRefCount(value);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送"lpop|rpop"事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(NOTIFY_LIST,event,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (listTypeLength(o) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 判断key列表对象是否要删除</span></span><br><span class="line">            <span class="comment">// 删除则发生"del"事件通知</span></span><br><span class="line">            notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="string">"del"</span>,</span><br><span class="line">                                c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line">            <span class="comment">// 从db对象中删除该列表对象</span></span><br><span class="line">            dbDelete(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 通知数据库有key修改</span></span><br><span class="line">        signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line">        server.dirty++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/16/redis/10_字符串对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/redis/10_字符串对象/" itemprop="url">
                  Redis源码阅读(十) 字符串对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-16 15:32:10" itemprop="dateCreated datePublished" datetime="2018-08-16T15:32:10+08:00">2018-08-16</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-23 10:40:11" itemprop="dateModified" datetime="2018-08-23T10:40:11+08:00">2018-08-23</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-编码"><a href="#1-编码" class="headerlink" title="1. 编码"></a>1. 编码</h3><p>字符串对象的编码可以是int、raw、embstr三种。</p>
<ul>
<li><p>int: 对象保存的是整数值，并且可以使用long类型进行表示，那么ptr中存储的就是这个long的地址，并将编码设置为int，[0, 10000)范围的可以使用共享整数。</p>
</li>
<li><p>raw: 对象保存的是字符串，且长度大于44字节，使用raw编码。</p>
</li>
<li><p>embstr: 对象保存的是字符串，若长度小等于44字节，则使用embstr类型编码，embstr是一种sds字符串，使用固定的SDS_TYPE_8进行存储，只进行一次内存分配，分配redis对象内存空间和sds对象内存空间，它们是连续存储的。</p>
</li>
</ul>
<blockquote>
<p>Redis中浮点类型作为字符串值来保存。</p>
</blockquote>
<h3 id="2-命令"><a href="#2-命令" class="headerlink" title="2. 命令"></a>2. 命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET</td>
<td>设置指定 key 的值 NX:仅key不存在 XX: 仅key存在 EX: 过期秒数 PX: 过期毫秒数</td>
</tr>
<tr>
<td>GET</td>
<td>获取指定 key 的值。</td>
</tr>
<tr>
<td>SETNX</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>SETEX</td>
<td>设置key的值，并给定过期时间seconds</td>
</tr>
<tr>
<td>GETSET</td>
<td>将给定 key 的值设为 value ，并返回 key 的旧值(old value)</td>
</tr>
<tr>
<td>SETRANGE</td>
<td>用 value 参数覆写给定 key 所储存的字符串值，从偏移量 offset 开始</td>
</tr>
<tr>
<td>GETRANGE</td>
<td>获取key 中字符串值的[start,end]的值</td>
</tr>
<tr>
<td>MSET</td>
<td>同时设置一个或多个 key-value 对</td>
</tr>
<tr>
<td>HGET</td>
<td>获取所有(一个或多个)给定 key 的值</td>
</tr>
<tr>
<td>INCR</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>INCRBY</td>
<td>将 key 所储存的值加上给定的增量值（increment）</td>
</tr>
<tr>
<td>INCRBYFLOAT</td>
<td>将 key 所储存的值加上给定的浮点增量值（increment）</td>
</tr>
<tr>
<td>DECR</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>DECRBY</td>
<td>key 所储存的值减去给定的减量值（decrement）</td>
</tr>
<tr>
<td>APPEND</td>
<td>追加value到key所存储字符串的后面，key不存在则添加</td>
</tr>
<tr>
<td>STRLEN</td>
<td>获取key所存储字符串的长度</td>
</tr>
</tbody>
</table>
<ul>
<li>相同命令不同的编码区分</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">int 编码</th>
<th style="text-align:center">embstr编码</th>
<th style="text-align:center">raw编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">底层使用整数值进行存储，[0,1000)使用共享整数存储</td>
<td style="text-align:center">使用简单动态字符串存储，SDS_TYPE_8</td>
<td style="text-align:center">使用简单动态字符串存储，长度超过44字节时使用</td>
</tr>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">拷贝底层存储的整数值，将其转换为字符串后返回给客户端</td>
<td style="text-align:center">直接返回字符串给客户端</td>
<td style="text-align:center">直接返回字符串给客户端</td>
</tr>
<tr>
<td style="text-align:center">INCR</td>
<td style="text-align:center">对整数值进行加法，计算结果仍能用在整数值范围，则直接存储，否则转换编码方式为RAW</td>
<td style="text-align:center">取出字符串并尝试转换成long long类型，失败则告诉客户端，成功则创建新的字符串保存</td>
<td style="text-align:center">取出字符串并尝试转换成long long类型，失败则告诉客户端，成功则创建新的字符串保存</td>
</tr>
<tr>
<td style="text-align:center">INCRBYFLOAT</td>
<td style="text-align:center">取出整数转换成long double，对齐进行浮点操作后，创建新的字符串对象保存起来</td>
<td style="text-align:center">取出整数转换成long double，对齐进行浮点操作后，创建新的字符串对象保存起来</td>
<td style="text-align:center">取出整数转换成long double，对齐进行浮点操作后，创建新的字符串对象保存起来</td>
</tr>
<tr>
<td style="text-align:center">APPEND</td>
<td style="text-align:center">调用 sdscatlen 函数，将字符串添加到末尾</td>
<td style="text-align:center">调用 sdscatlen 函数，将字符串添加到末尾</td>
<td style="text-align:center">调用 sdscatlen 函数，将字符串添加到末尾</td>
</tr>
<tr>
<td style="text-align:center">STRLEN</td>
<td style="text-align:center">直接获取字符串的长度</td>
<td style="text-align:center">直接获取字符串的长度</td>
<td style="text-align:center">直接获取字符串的长度</td>
</tr>
</tbody>
</table>
<blockquote>
<p>若对象进行了共享，那么修改对象的操作则会拷贝一个新的对象，而不是用原来的共享对象</p>
</blockquote>
<h3 id="3-源码剖析"><a href="#3-源码剖析" class="headerlink" title="3. 源码剖析"></a>3. 源码剖析</h3><ul>
<li>创建字符串对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据创建的字符串长度，判断是否使用OBJ_ENCODING_EMBSTR编码</span></span><br><span class="line"><span class="comment"> * 使用jemalloc分配内存，会分配2的幂次方字节，所以我们会分配64字节</span></span><br><span class="line"><span class="comment"> * redisOob大小16字节，sdshdr8大小3字节，加1字节结束标识，共20字节</span></span><br><span class="line"><span class="comment"> * 所以embstr的限制为64-20 = 44字节</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR_SIZE_LIMIT 44</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 超过44字节使用RAW编码方式，否则使用EMBSTR编码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">robj *<span class="title">createStringObject</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ptr, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT)</span><br><span class="line">        <span class="keyword">return</span> createEmbeddedStringObject(ptr,len);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> createRawStringObject(ptr,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过long long类型创建字符串对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createStringObjectFromLongLong</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// [0, 10000) 范围内整数共享</span></span><br><span class="line">    <span class="keyword">if</span> (value &gt;= <span class="number">0</span> &amp;&amp; value &lt; OBJ_SHARED_INTEGERS) &#123;</span><br><span class="line">        <span class="comment">// 添加整数的引用计数</span></span><br><span class="line">        incrRefCount(shared.integers[value]);</span><br><span class="line">        <span class="comment">// 获取整数值</span></span><br><span class="line">        o = shared.integers[value];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不在整数共享范围</span></span><br><span class="line">        <span class="comment">// [LONG_MIN, LONG_MAX], 使用字符串对象，编码使用OBJ_ENCODING_INT</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX) &#123;</span><br><span class="line">            o = createObject(OBJ_STRING, <span class="literal">NULL</span>);</span><br><span class="line">            o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">            <span class="comment">// 直接指向整数值</span></span><br><span class="line">            o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 不在[LONG_MIN,LONG_MAX] 范围则使用sds动态字符串存储, 编码OBJ_ENCODING_RAW</span></span><br><span class="line">            o = createObject(OBJ_STRING,sdsfromlonglong(value));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>尝试对字符串对象进行编码优化</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">tryObjectEncoding</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value;</span><br><span class="line">    sds s = o-&gt;ptr;</span><br><span class="line">    <span class="keyword">size_t</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure this is a string object, the only type we encode</span></span><br><span class="line"><span class="comment">     * in this function. Other types use encoded memory efficient</span></span><br><span class="line"><span class="comment">     * representations but are handled by the commands implementing</span></span><br><span class="line"><span class="comment">     * the type. */</span></span><br><span class="line">    serverAssertWithInfo(<span class="literal">NULL</span>,o,o-&gt;type == OBJ_STRING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We try some specialized encoding only for objects that are</span></span><br><span class="line"><span class="comment">     * RAW or EMBSTR encoded, in other words objects that are still</span></span><br><span class="line"><span class="comment">     * in represented by an actually array of chars. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有是RAW或EMBSTR编码是，才尝试重新编码</span></span><br><span class="line">    <span class="keyword">if</span> (!sdsEncodedObject(o)) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It's not safe to encode shared objects: shared objects can be shared</span></span><br><span class="line"><span class="comment">     * everywhere in the "object space" of Redis and may end in places where</span></span><br><span class="line"><span class="comment">     * they are not handled. We handle them only as values in the keyspace. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码共享对象是不安全的</span></span><br><span class="line">    <span class="comment">// 若对象是共享的，则不进行编码</span></span><br><span class="line">     <span class="keyword">if</span> (o-&gt;refcount &gt; <span class="number">1</span>) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we can represent this string as a long integer.</span></span><br><span class="line"><span class="comment">     * Note that we are sure that a string larger than 20 chars is not</span></span><br><span class="line"><span class="comment">     * representable as a 32 nor 64 bit integer. */</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">// 判断字符串是否可以用整数表示</span></span><br><span class="line">     <span class="comment">// 注意：超过20位的字符串则无法用整数表示</span></span><br><span class="line">    len = sdslen(s);</span><br><span class="line">    <span class="keyword">if</span> (len &lt;= <span class="number">20</span> &amp;&amp; string2l(s,len,&amp;value)) &#123;</span><br><span class="line">        <span class="comment">/* This object is encodable as a long. Try to use a shared object.</span></span><br><span class="line"><span class="comment">         * Note that we avoid using shared integers when maxmemory is used</span></span><br><span class="line"><span class="comment">         * because every object needs to have a private LRU field for the LRU</span></span><br><span class="line"><span class="comment">         * algorithm to work well. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// [0, 10000) 尝试使用共享整数</span></span><br><span class="line">        <span class="keyword">if</span> ((server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">            !(server.maxmemory_policy &amp; MAXMEMORY_FLAG_NO_SHARED_INTEGERS)) &amp;&amp;</span><br><span class="line">            value &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">            value &lt; OBJ_SHARED_INTEGERS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 是否之前的对象</span></span><br><span class="line">            decrRefCount(o);</span><br><span class="line">            incrRefCount(shared.integers[value]);</span><br><span class="line">            <span class="keyword">return</span> shared.integers[value];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则使用OBJ_ENCODING_INT编码</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW) sdsfree(o-&gt;ptr);</span><br><span class="line">            o-&gt;encoding = OBJ_ENCODING_INT;</span><br><span class="line">            o-&gt;ptr = (<span class="keyword">void</span>*) value;</span><br><span class="line">            <span class="keyword">return</span> o;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the string is small and is still RAW encoded,</span></span><br><span class="line"><span class="comment">     * try the EMBSTR encoding which is more efficient.</span></span><br><span class="line"><span class="comment">     * In this representation the object and the SDS string are allocated</span></span><br><span class="line"><span class="comment">     * in the same chunk of memory to save space and cache misses. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若字符串长度小于EMBSTR的限制</span></span><br><span class="line">    <span class="keyword">if</span> (len &lt;= OBJ_ENCODING_EMBSTR_SIZE_LIMIT) &#123;</span><br><span class="line">        robj *emb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编码是EMBSTR则返回</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_EMBSTR) <span class="keyword">return</span> o;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则使用EMBSTR编码</span></span><br><span class="line">        emb = createEmbeddedStringObject(s,sdslen(s));</span><br><span class="line">        <span class="comment">// 释放之前的对象</span></span><br><span class="line">        decrRefCount(o);</span><br><span class="line">        <span class="keyword">return</span> emb;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We can't encode the object...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Do the last try, and at least optimize the SDS string inside</span></span><br><span class="line"><span class="comment">     * the string object to require little space, in case there</span></span><br><span class="line"><span class="comment">     * is more than 10% of free space at the end of the SDS string.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * We do that only for relatively large strings as this branch</span></span><br><span class="line"><span class="comment">     * is only entered if the length of the string is greater than</span></span><br><span class="line"><span class="comment">     * OBJ_ENCODING_EMBSTR_SIZE_LIMIT. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无法进行编码优化，但若空间浪费过多(有1/10的空间未使用)，则释放未使用的内存空间</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_RAW &amp;&amp;</span><br><span class="line">        sdsavail(s) &gt; len/<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        o-&gt;ptr = sdsRemoveFreeSpace(o-&gt;ptr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return the original object. */</span></span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SET命令底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGenericCommand</span><span class="params">(client *c, <span class="keyword">int</span> flags, robj *key, robj *val, robj *expire, <span class="keyword">int</span> unit, robj *ok_reply, robj *abort_reply)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> milliseconds = <span class="number">0</span>; <span class="comment">/* initialized to avoid any harmness warning */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若存在过期时间对象, 则取出过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) &#123;</span><br><span class="line">        <span class="comment">// 从exprie对象中获取long long类型的过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (getLongLongFromObjectOrReply(c, expire, &amp;milliseconds, <span class="literal">NULL</span>) != C_OK)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (milliseconds &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            addReplyErrorFormat(c,<span class="string">"invalid expire time in %s"</span>,c-&gt;cmd-&gt;name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// redis实际以毫秒形式保存过期时间</span></span><br><span class="line">        <span class="comment">// 若输入时间为秒，则转换为毫秒</span></span><br><span class="line">        <span class="keyword">if</span> (unit == UNIT_SECONDS) milliseconds *= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NX：表示key不存在</span></span><br><span class="line">    <span class="comment">// XX：表示key存在</span></span><br><span class="line">    <span class="comment">// 若使用NX，但找到给key；若使用XX，但未找到该key</span></span><br><span class="line">    <span class="comment">// 回复错误给客户端</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; OBJ_SET_NX &amp;&amp; lookupKeyWrite(c-&gt;db,key) != <span class="literal">NULL</span>) ||</span><br><span class="line">        (flags &amp; OBJ_SET_XX &amp;&amp; lookupKeyWrite(c-&gt;db,key) == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        addReply(c, abort_reply ? abort_reply : shared.nullbulk);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加键值对到当前db</span></span><br><span class="line">    setKey(c-&gt;db,key,val);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置数据库为脏(dirty)，每次修改key后，都会dirty++</span></span><br><span class="line">    server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置key的过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (expire) setExpire(c,c-&gt;db,key,mstime()+milliseconds);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送"set"事件通知，用于发布订阅模式，通知客户端接收消息</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"set"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送"expire"事件通知</span></span><br><span class="line">    <span class="keyword">if</span> (expire) notifyKeyspaceEvent(NOTIFY_GENERIC,</span><br><span class="line">        <span class="string">"expire"</span>,key,c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复客户端</span></span><br><span class="line">    addReply(c, ok_reply ? ok_reply : shared.ok);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>INCR和DECR底层实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">incrDecrCommand</span><span class="params">(client *c, <span class="keyword">long</span> <span class="keyword">long</span> incr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value, oldvalue;</span><br><span class="line">    robj *o, *<span class="keyword">new</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻址key对象</span></span><br><span class="line">    o = lookupKeyWrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若未找到或不是字符串对象则返回</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="literal">NULL</span> &amp;&amp; checkType(c,o,OBJ_STRING)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出对象的整数值，保存在value中</span></span><br><span class="line">    <span class="keyword">if</span> (getLongLongFromObjectOrReply(c,o,&amp;value,<span class="literal">NULL</span>) != C_OK) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否有溢出发生</span></span><br><span class="line">    oldvalue = value;</span><br><span class="line">    <span class="keyword">if</span> ((incr &lt; <span class="number">0</span> &amp;&amp; oldvalue &lt; <span class="number">0</span> &amp;&amp; incr &lt; (LLONG_MIN-oldvalue)) ||</span><br><span class="line">        (incr &gt; <span class="number">0</span> &amp;&amp; oldvalue &gt; <span class="number">0</span> &amp;&amp; incr &gt; (LLONG_MAX-oldvalue))) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"increment or decrement would overflow"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新值</span></span><br><span class="line">    value += incr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象未共享，且超过共享整数编码范围或用long可以表示, 直接存储</span></span><br><span class="line">    <span class="keyword">if</span> (o &amp;&amp; o-&gt;refcount == <span class="number">1</span> &amp;&amp; o-&gt;encoding == OBJ_ENCODING_INT &amp;&amp;</span><br><span class="line">        (value &lt; <span class="number">0</span> || value &gt;= OBJ_SHARED_INTEGERS) &amp;&amp;</span><br><span class="line">        value &gt;= LONG_MIN &amp;&amp; value &lt;= LONG_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">new</span> = o;</span><br><span class="line">        o-&gt;ptr = (<span class="keyword">void</span>*)((<span class="keyword">long</span>)value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 新建字符串对象</span></span><br><span class="line">        <span class="keyword">new</span> = createStringObjectFromLongLong(value);</span><br><span class="line">        <span class="keyword">if</span> (o) &#123;</span><br><span class="line">            dbOverwrite(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dbAdd(c-&gt;db,c-&gt;argv[<span class="number">1</span>],<span class="keyword">new</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向数据库发送键被修改的信号</span></span><br><span class="line">    signalModifiedKey(c-&gt;db,c-&gt;argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送"incrby"事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(NOTIFY_STRING,<span class="string">"incrby"</span>,c-&gt;argv[<span class="number">1</span>],c-&gt;db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器为脏</span></span><br><span class="line">    server.dirty++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复客户端</span></span><br><span class="line">    addReply(c,shared.colon);</span><br><span class="line">    addReply(c,<span class="keyword">new</span>);</span><br><span class="line">    addReply(c,shared.crlf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/15/redis/9_对象系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/15/redis/9_对象系统/" itemprop="url">
                  Redis源码阅读(九) 对象系统
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-15 17:25:58" itemprop="dateCreated datePublished" datetime="2018-08-15T17:25:58+08:00">2018-08-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-27 18:26:32" itemprop="dateModified" datetime="2018-08-27T18:26:32+08:00">2018-08-27</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis定义了一些基本了数据类型，如简单动态字符串、字典、跳跃表、压缩列表等等，但并未使用这些结构作为对象存储，而是定义了一套对象系统，底层使用这些数据结构进行存储，这个对象系统包括了字符串对象、列表对象、哈希对象、集合对象、有序集合对象，Redis针对不同的使用场景，设置不同的数据结构，优化其使用效率。</p>
<p>Redis通过对象引用计数进行内存的自动回收，并通过引用计数实现对象共享机制，Redis对象还保存了最近一次访问的时间(或历史访问频率)，通过LRU(LFU)算法对其进行优化。</p>
<h3 id="1-redis对象定义"><a href="#1-redis对象定义" class="headerlink" title="1. redis对象定义"></a>1. redis对象定义</h3><ul>
<li>redis对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span>                                                                            </span><br><span class="line">    <span class="comment">// 4bit，表示对象类型, OBJ_STRING ...                                                              </span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;                                                                                    </span><br><span class="line">    <span class="comment">// 4bit，表示编码类型, OBJ_ENCODING_RAE ...                                                        </span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;                                                                                </span><br><span class="line">    <span class="comment">// LRU最后一次被访问的时间; LFU历史访问频次                                                                            </span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or                                </span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency                              </span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span>                             </span><br><span class="line">    <span class="comment">// 对象引用计数                                                                                     </span></span><br><span class="line">    <span class="keyword">int</span> refcount;                                                                                       </span><br><span class="line">    <span class="comment">// 实际存储地址                                                                                     </span></span><br><span class="line">    <span class="keyword">void</span> *ptr;                                                                                          </span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>
<h3 id="2-对象类型"><a href="#2-对象类型" class="headerlink" title="2. 对象类型"></a>2. 对象类型</h3><p>redis对象使用type(4bit)字段表示该对象的类型，Redis数据库中键总是一个字符串对象，而值可以是字符串对象、列表对象、哈希对象、集合对象、有序集合对象和模块对象。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">对象</th>
<th style="text-align:center">TYPE命令输出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJ_STRING 0</td>
<td style="text-align:center">字符串对象</td>
<td style="text-align:center">“string”</td>
</tr>
<tr>
<td style="text-align:center">OBJ_LIST 1</td>
<td style="text-align:center">列表对象</td>
<td style="text-align:center">“list”</td>
</tr>
<tr>
<td style="text-align:center">OBJ_SET 2</td>
<td style="text-align:center">集合对象</td>
<td style="text-align:center">“set”</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ZSET 3</td>
<td style="text-align:center">有序集合对象</td>
<td style="text-align:center">“zset”</td>
</tr>
<tr>
<td style="text-align:center">OBJ_HASH 4</td>
<td style="text-align:center">哈希对象</td>
<td style="text-align:center">“hash”</td>
</tr>
<tr>
<td style="text-align:center">OBJ_MODULE 5</td>
<td style="text-align:center">模块对象（特殊的类型）</td>
<td style="text-align:center">模块名称</td>
</tr>
</tbody>
</table>
<h3 id="3-对象编码"><a href="#3-对象编码" class="headerlink" title="3. 对象编码"></a>3. 对象编码</h3><p>redis对象的ptr属性指向底层的数据结构，这些数据结构由encoding属性决定。</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量</th>
<th style="text-align:center">底层数据结构</th>
<th style="text-align:center">encoding 命令输出</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">OBJ_ENCODING_RAW 0</td>
<td style="text-align:center">简单动态字符串</td>
<td style="text-align:center">“raw”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_INT 1</td>
<td style="text-align:center">long类型的整数</td>
<td style="text-align:center">“int”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_HT 2</td>
<td style="text-align:center">字典</td>
<td style="text-align:center">“hashtable”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_ZIPMAP 3</td>
<td style="text-align:center">压缩字典</td>
<td style="text-align:center">—</td>
<td style="text-align:center">不会单独使用</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_LINKEDLIST 4</td>
<td style="text-align:center">双端链表</td>
<td style="text-align:center">—</td>
<td style="text-align:center">不再用于列表对象</td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_ZIPLIST 5</td>
<td style="text-align:center">压缩列表</td>
<td style="text-align:center">“ziplist”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_INTSET 6</td>
<td style="text-align:center">整数集合</td>
<td style="text-align:center">“intset”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_SKIPLIST 7</td>
<td style="text-align:center">跳跃表</td>
<td style="text-align:center">“skiplist”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_EMBSTR 8</td>
<td style="text-align:center">embstr类型sds</td>
<td style="text-align:center">“embstr”</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">OBJ_ENCODING_QUICKLIST 9</td>
<td style="text-align:center">快速列表</td>
<td style="text-align:center">“quicklist”</td>
</tr>
</tbody>
</table>
<p>每种对象都存在不同的编码方式。</p>
<table>
<thead>
<tr>
<th style="text-align:center">对象类型</th>
<th style="text-align:center">编码类型</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">STRING</td>
<td style="text-align:center">INT</td>
<td style="text-align:center">使用数值存储</td>
</tr>
<tr>
<td style="text-align:center">STRING</td>
<td style="text-align:center">EMBSTR</td>
<td style="text-align:center">不被修改的字符串，并且不能超过44字节</td>
</tr>
<tr>
<td style="text-align:center">STRING</td>
<td style="text-align:center">RAW</td>
<td style="text-align:center">超过44字节的一般字符串</td>
</tr>
<tr>
<td style="text-align:center">LIST</td>
<td style="text-align:center">QUICKLIST</td>
<td style="text-align:center">列表对象的编码仅使用QUICKLIST</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">HT</td>
<td style="text-align:center">字典编码的哈希对象</td>
</tr>
<tr>
<td style="text-align:center">HASH</td>
<td style="text-align:center">ZIPLIST</td>
<td style="text-align:center">压缩列表编码的哈希对象</td>
</tr>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">HT</td>
<td style="text-align:center">字典编码的集合对象</td>
</tr>
<tr>
<td style="text-align:center">SET</td>
<td style="text-align:center">INTSET</td>
<td style="text-align:center">整数集合编码的集合对象</td>
</tr>
<tr>
<td style="text-align:center">ZSET</td>
<td style="text-align:center">QUICKLIST</td>
<td style="text-align:center">跳跃表编码有序集合对象</td>
</tr>
<tr>
<td style="text-align:center">ZSET</td>
<td style="text-align:center">ZIPLIST</td>
<td style="text-align:center">压缩列表编码有序集合对象</td>
</tr>
</tbody>
</table>
<h3 id="4-内存优化"><a href="#4-内存优化" class="headerlink" title="4. 内存优化"></a>4. 内存优化</h3><h4 id="4-1-引用计数"><a href="#4-1-引用计数" class="headerlink" title="4.1 引用计数"></a>4.1 引用计数</h4><p>C语言没有垃圾回收机制(GC)，所以Redis自己实现了基于引用计数的内存回收，通过跟踪引用计数，在适当的时候释放内存空间，优化性能。</p>
<p>对象的引用计数会随对象的使用而发生改变</p>
<ul>
<li>创建新对象时，引用计数+1</li>
<li>对象被使用时，引用计数+1</li>
<li>对象不在被使用时，引用计数-1</li>
<li>引用计数减为0时，释放占用内存空间</li>
<li>[0, 10000)范围的整数引用计数设为INT_MAX，用做整数共享</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">incrRefCount</td>
<td>对象引用计数+1</td>
</tr>
<tr>
<td style="text-align:left">decrRefCount</td>
<td>对象引用计数-1，当计数为0时，根据其编码释放底层内存空间</td>
</tr>
<tr>
<td style="text-align:left">resetRefCount</td>
<td>对象引用计数设置为0，但不释放内存，通常用在 创建对象后调用会增加引用计数的函</td>
</tr>
</tbody>
</table>
<h4 id="4-2-对象共享"><a href="#4-2-对象共享" class="headerlink" title="4.2 对象共享"></a>4.2 对象共享</h4><p>Redis通过引用计数实现了对象共享的机制，如[0, 10000)范围的数字就是共享整数，若redis中的值在此范围内，则会通过指针指向这些整数。</p>
<blockquote>
<p>当服务器将共享对象设置为值的时候，需要检查共享对象和目标对象是否完全相同，只有完全相同才会进行共享，检查对象完全相同的代价取决于对象的复杂程度，基础类型耗时很少，但越复杂的对象则需要越大的代价，尽管可以节省内存，但CPU耗时会增加，所以Redis目前只共享整数</p>
</blockquote>
<h4 id="4-3-命令"><a href="#4-3-命令" class="headerlink" title="4.3 命令"></a>4.3 命令</h4><p>Redis使用了LRU和LFU算法记录对象被访问的情况，默认开启LRU算法，LFU算法需通过配置文件开启。</p>
<p>使用OBJECT命令可以获取对象内存有关的信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取对象的信息</span></span><br><span class="line">-OBJECT [refcount|encoding|idletime|freq] key</span><br><span class="line">	- refcount：获取对象的引用计数</span><br><span class="line">	- encoding：获取对象的编码类型</span><br><span class="line">	- idletime：获取对象已经存在的时间，LFU算法下不可使用</span><br><span class="line">	- freq：获取对象被访问的频次，LFU算法下可用</span><br></pre></td></tr></table></figure>
<p>使用TYPE命令可以获取对象的类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取key对象的类型，string, list, set, zset, hash</span></span><br><span class="line">-TYPE key</span><br></pre></td></tr></table></figure>
<h3 id="5-源码剖析"><a href="#5-源码剖析" class="headerlink" title="5. 源码剖析"></a>5. 源码剖析</h3><ul>
<li>减少对象引用计数，当引用计数为0时释放该对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrRefCount</span><span class="params">(robj *o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o-&gt;refcount == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(o-&gt;type) &#123;</span><br><span class="line">        <span class="keyword">case</span> OBJ_STRING: freeStringObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_LIST: freeListObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_SET: freeSetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_ZSET: freeZsetObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_HASH: freeHashObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> OBJ_MODULE: freeModuleObject(o); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: serverPanic(<span class="string">"Unknown object type"</span>); <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        zfree(o);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount &lt;= <span class="number">0</span>) serverPanic(<span class="string">"decrRefCount against refcount &lt;= 0"</span>);</span><br><span class="line">        <span class="keyword">if</span> (o-&gt;refcount != OBJ_SHARED_REFCOUNT) o-&gt;refcount--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个redis对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createObject</span><span class="params">(<span class="keyword">int</span> type, <span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    robj *o = zmalloc(<span class="keyword">sizeof</span>(*o));</span><br><span class="line">    <span class="comment">// 对象类型</span></span><br><span class="line">    o-&gt;type = type;</span><br><span class="line">    <span class="comment">// 对象编码</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_RAW;</span><br><span class="line">    <span class="comment">// 对象实际存储指针</span></span><br><span class="line">    o-&gt;ptr = ptr;</span><br><span class="line">    <span class="comment">// 对象引用计数</span></span><br><span class="line">    o-&gt;refcount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the LRU to the current lruclock (minutes resolution), or</span></span><br><span class="line"><span class="comment">     * alternatively the LFU counter. */</span></span><br><span class="line">    <span class="comment">// 使用LRU或者LFU算法,用于内存淘汰</span></span><br><span class="line">    <span class="keyword">if</span> (server.maxmemory_policy &amp; MAXMEMORY_FLAG_LFU) &#123;</span><br><span class="line">        o-&gt;lru = (LFUGetTimeInMinutes()&lt;&lt;<span class="number">8</span>) | LFU_INIT_VAL;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        o-&gt;lru = LRU_CLOCK();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个quicklist列表对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建新的quicklist</span></span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    <span class="comment">// 创建列表对象</span></span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    <span class="comment">// 编码方式QUICKLIST</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个dict集合对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个字典</span></span><br><span class="line">    dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建集合对象</span></span><br><span class="line">    robj *o = createObject(OBJ_SET,d);</span><br><span class="line">    <span class="comment">// 编码方式OBJ_ENCODING_HT</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个intset集合对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123; <span class="comment">// 创建一个整数结合</span></span><br><span class="line">    <span class="comment">// 创建整数集合</span></span><br><span class="line">    intset *is = intsetNew();</span><br><span class="line">    <span class="comment">// 创建集合对象</span></span><br><span class="line">    robj *o = createObject(OBJ_SET,is);</span><br><span class="line">    <span class="comment">// 编码方式OBJ_ENCODING_INTSET</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个ziplist哈希对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    <span class="comment">// 创建哈希对象</span></span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    <span class="comment">// 编码方式 OBJ_ENCODING_ZIPLIST</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个skiplist有序集合对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分配内存空间</span></span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建哈希表</span></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 创建跳跃表</span></span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    <span class="comment">// 创建有序集合对象</span></span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    <span class="comment">// 编码方式 OBJ_ENCODING_SKIPLIST</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个ziplist有序集合对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建ziplist</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    <span class="comment">// 创建有序集合对象</span></span><br><span class="line">    robj *o = createObject(OBJ_ZSET,zl);</span><br><span class="line">    <span class="comment">// 编码方式OBJ_ENCODING_ZIPLIST</span></span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/14/redis/8_快速列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/14/redis/8_快速列表/" itemprop="url">
                  Redis源码阅读(八) 快速列表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-14 12:46:11" itemprop="dateCreated datePublished" datetime="2018-08-14T12:46:11+08:00">2018-08-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-08-15 14:23:00" itemprop="dateModified" datetime="2018-08-15T14:23:00+08:00">2018-08-15</time>
              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快速列表quicklist是一个由压缩列表ziplist组成的双端链表，链表中每个结点都有一个ziplist，每个ziplist有多个entry，主要用于列表键的底层实现，替换了原有的双端链表adlist。</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><ul>
<li><p>快速列表结点</p>
<p>结点进行压缩后，zl指向的是压缩后的LZF结构体，其中compressd中存储的压缩的内容</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> &#123;</span>                                                                                  </span><br><span class="line">    <span class="comment">// 快速列表前驱结点                                                                                </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">prev</span>;</span>                                                                        </span><br><span class="line">	<span class="comment">// 快速列表后继节点                                                                                </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">quicklistNode</span> *<span class="title">next</span>;</span>                                                                        </span><br><span class="line">    <span class="comment">// 指向ziplist或者quicklistLZF(LZF压缩后)                                                          </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl;                                                                                 </span><br><span class="line">    <span class="comment">// ziplist使用内存字节数                                                                           </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;             <span class="comment">/* ziplist size in bytes */</span>                                           </span><br><span class="line">    <span class="comment">// ziplist中的结点个数，占16bits，不超过32k                                                        </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count : <span class="number">16</span>;     <span class="comment">/* count of items in ziplist */</span>                                       </span><br><span class="line">    <span class="comment">// 2bits, 表示是否采用LZF压缩算法压缩结点，1表示不压缩，2表示压缩                                  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> encoding : <span class="number">2</span>;   <span class="comment">/* RAW==1 or LZF==2 */</span>                                                </span><br><span class="line">    <span class="comment">// 2bits, 表示是否采用ziplist结构保存结点，1表示不采用，2表示使用                                  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> container : <span class="number">2</span>;  <span class="comment">/* NONE==1 or ZIPLIST==2 */</span>                                           </span><br><span class="line">    <span class="comment">// 1bit, true时表示曾经临时解压过，需要被压缩                                                         </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> recompress : <span class="number">1</span>; <span class="comment">/* was this node previous compressed? */</span>                           </span><br><span class="line">    <span class="comment">// 测试时使用，结点太小时不能压缩                                                               </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> attempted_compress : <span class="number">1</span>; <span class="comment">/* node can't compress; too small */</span>                       </span><br><span class="line">    <span class="comment">// 额外扩展位，10bits                                                                           </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> extra : <span class="number">10</span>; <span class="comment">/* more bits to steal for future usage */</span>                              </span><br><span class="line">&#125; quicklistNode;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速列表LZF算法压缩ziplist</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistLZF</span> &#123;</span>                                                                                  </span><br><span class="line">    <span class="comment">// LZF压缩过后的ziplist大小                                                                     </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz; <span class="comment">/* LZF size in bytes*/</span>                                                         </span><br><span class="line">    <span class="comment">// 保存压缩后的ziplist                                                                          </span></span><br><span class="line">    <span class="keyword">char</span> compressed[];                                                                              </span><br><span class="line">&#125; quicklistLZF;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>快速列表</p>
<ul>
<li><p>head，tail：头尾结点</p>
</li>
<li><p>count：所有结点中ziplist中entry的总和</p>
</li>
<li><p>len：quicklistNode结点个数</p>
</li>
<li><p>fill：16bit，表示ziplist的大小限制【redis.conf中list-max-ziplist-size可配置】</p>
<ul>
<li><p>负数表示每个快速列表结点中ziplist的大小限制</p>
<p>-1: 4KB、-2: 8KB(默认) 、-3: 16KB  、-4: 32KB  -5: 64KB</p>
</li>
<li><p>正数表示每个快速列表结点中ziplist包含最多entry的个数，最大2^15</p>
</li>
</ul>
</li>
<li><p>compress：16bit，表示列表两端不需要压缩的结点数【redis.conf中list-compress-depth可配置】</p>
<ul>
<li>0表示不压缩</li>
<li>1表示列表前后两端各有1个结点不压缩</li>
<li>2表示列表前后两端各有2个结点不压缩</li>
<li>……</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklist</span> &#123;</span></span><br><span class="line">    <span class="comment">// 头结点                                                                                       </span></span><br><span class="line">    quicklistNode *head;</span><br><span class="line">    <span class="comment">// 尾结点                                                                                       </span></span><br><span class="line">    quicklistNode *tail;                                                                            </span><br><span class="line">    <span class="comment">// ziplist所有条目的数量                                                                        </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> count;        <span class="comment">/* total count of all entries in all ziplists */</span>                    </span><br><span class="line">    <span class="comment">// quicklist结点个数                                                                            </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;          <span class="comment">/* number of quicklistNodes */</span>                                      </span><br><span class="line">    <span class="comment">// 16bits，用户设置(或默认)，单个ziplist的大小限制                                              </span></span><br><span class="line">    <span class="comment">// 小于0时表示ziplist的大小限制，大于0时表示最多结点个数                                        </span></span><br><span class="line">    <span class="keyword">int</span> fill : <span class="number">16</span>;              <span class="comment">/* fill factor for individual nodes */</span>                              </span><br><span class="line">    <span class="comment">// 列表两端不被要是的结点数                                    </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> compress : <span class="number">16</span>; <span class="comment">/* depth of end nodes not to compress;0=off */</span>                      </span><br><span class="line">&#125; quicklist;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速列表迭代器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistIter</span> &#123;</span>                                                                      </span><br><span class="line">    <span class="comment">// 迭代器指向的列表                                                                             </span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist;                                                                     </span><br><span class="line">    <span class="comment">// 迭代器指向列表的当前结点                                                                     </span></span><br><span class="line">    quicklistNode *current;                                                                         </span><br><span class="line">    <span class="comment">// 迭代器指向列表的ziplist中的结点                                                              </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;                                                                              </span><br><span class="line">    <span class="comment">// ziplist的偏移量                                                                              </span></span><br><span class="line">    <span class="keyword">long</span> offset; <span class="comment">/* offset in current ziplist */</span>                                                    </span><br><span class="line">    <span class="comment">// 迭代器方向                                                                                   </span></span><br><span class="line">    <span class="keyword">int</span> direction;                                                                                  </span><br><span class="line">&#125; quicklistIter;</span><br></pre></td></tr></table></figure>
<ul>
<li>快速列表结点entry</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">quicklistEntry</span> &#123;</span>                                                                     </span><br><span class="line">    <span class="comment">// 所属的快速列表                                                                               </span></span><br><span class="line">    <span class="keyword">const</span> quicklist *quicklist;                                                                     </span><br><span class="line">    <span class="comment">// quicklistNode结点                                                                            </span></span><br><span class="line">    quicklistNode *node;                                                                            </span><br><span class="line">    <span class="comment">// 指向的ziplist                                                                           </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi;                                                                              </span><br><span class="line">    <span class="comment">// ziplist结点的字符串value                                                                     </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *value;                                                                           </span><br><span class="line">    <span class="comment">// ziplist结点的整数value                                                                       </span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> longval;                                                                              </span><br><span class="line">    <span class="comment">// 当前ziplist结构的字节数大小                                                                  </span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sz;                                                                                </span><br><span class="line">    <span class="comment">// ziplist的相对偏移量                                                                          </span></span><br><span class="line">    <span class="keyword">int</span> offset;                                                                                     </span><br><span class="line">&#125; quicklistEntry;</span><br></pre></td></tr></table></figure>
<h3 id="2-源码剖析"><a href="#2-源码剖析" class="headerlink" title="2. 源码剖析"></a>2. 源码剖析</h3><ul>
<li><p>entry插入</p>
<p>由于每个结点中的ziplist有大小限制，所以在node结点满的情况下，会做特殊处理</p>
<ol>
<li>插入结点未满则插入结点的ziplist中</li>
<li>插入结点已满，则根据插入的位置判断前驱或后继是否已满，若未满则插入前驱或后继的ziplist</li>
<li>插入结点已满，前驱和后继也已满，则创建新的结点，插入到新结点的ziplist，并将该结点插入到快速列表中</li>
</ol>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line">REDIS_STATIC <span class="keyword">void</span> _quicklistInsert(quicklist *quicklist, quicklistEntry *entry,</span><br><span class="line">                                   <span class="keyword">void</span> *value, <span class="keyword">const</span> <span class="keyword">size_t</span> sz, <span class="keyword">int</span> after) &#123;</span><br><span class="line">    <span class="keyword">int</span> full = <span class="number">0</span>, at_tail = <span class="number">0</span>, at_head = <span class="number">0</span>, full_next = <span class="number">0</span>, full_prev = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> fill = quicklist-&gt;fill;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// entry的quicklistNode结点</span></span><br><span class="line">    quicklistNode *node = entry-&gt;node;</span><br><span class="line">    quicklistNode *new_node = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若entry没有quicklistNode结点，则需要创建新的</span></span><br><span class="line">    <span class="keyword">if</span> (!node) &#123;</span><br><span class="line">        <span class="comment">/* we have no reference node, so let's create only node in the list */</span></span><br><span class="line">        D(<span class="string">"No node given!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新的结点</span></span><br><span class="line">        new_node = quicklistCreateNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// value插入到ziplist的头部</span></span><br><span class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结点插入到quicklist中</span></span><br><span class="line">        __quicklistInsertNode(quicklist, <span class="literal">NULL</span>, new_node, after);</span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line">        quicklist-&gt;count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Populate accounting flags for easier boolean checks later */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// node结点已经没有空间</span></span><br><span class="line">    <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node, fill, sz)) &#123;</span><br><span class="line">        D(<span class="string">"Current node is full with count %d with requested fill %lu"</span>,</span><br><span class="line">          node-&gt;count, fill);</span><br><span class="line">        full = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的位置是tail</span></span><br><span class="line">    <span class="keyword">if</span> (after &amp;&amp; (entry-&gt;offset == node-&gt;count)) &#123;</span><br><span class="line">        D(<span class="string">"At Tail of current ziplist"</span>);</span><br><span class="line">        at_tail = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;next, fill, sz)) &#123;</span><br><span class="line">            D(<span class="string">"Next node is full too."</span>);</span><br><span class="line">            full_next = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 插入的位置是head</span></span><br><span class="line">    <span class="keyword">if</span> (!after &amp;&amp; (entry-&gt;offset == <span class="number">0</span>)) &#123;</span><br><span class="line">        D(<span class="string">"At Head"</span>);</span><br><span class="line">        at_head = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!_quicklistNodeAllowInsert(node-&gt;prev, fill, sz)) &#123;</span><br><span class="line">            D(<span class="string">"Prev node is full too."</span>);</span><br><span class="line">            full_prev = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Now determine where and how to insert the new element */</span></span><br><span class="line">    <span class="keyword">if</span> (!full &amp;&amp; after) &#123; <span class="comment">// 结点可插入，并且是结点之后</span></span><br><span class="line">        D(<span class="string">"Not full, inserting after current position."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// node临时解压</span></span><br><span class="line">        quicklistDecompressNodeForUse(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算要插入的位置</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *next = ziplistNext(node-&gt;zl, entry-&gt;zi);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123; <span class="comment">// 插入尾部</span></span><br><span class="line">            node-&gt;zl = ziplistPush(node-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 插入next位置</span></span><br><span class="line">            node-&gt;zl = ziplistInsert(node-&gt;zl, next, value, sz);</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;count++;</span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line">        quicklistRecompressOnly(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!full &amp;&amp; !after) &#123; <span class="comment">// 结点可插入，并且是结点之前</span></span><br><span class="line">        D(<span class="string">"Not full, inserting before current position."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时解压</span></span><br><span class="line">        quicklistDecompressNodeForUse(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入结点到ziplist</span></span><br><span class="line">        node-&gt;zl = ziplistInsert(node-&gt;zl, entry-&gt;zi, value, sz);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计数</span></span><br><span class="line">        node-&gt;count++;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更新内存大小</span></span><br><span class="line">        quicklistNodeUpdateSz(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新压缩</span></span><br><span class="line">        quicklistRecompressOnly(quicklist, node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_tail &amp;&amp; node-&gt;next &amp;&amp; !full_next &amp;&amp; after) &#123;</span><br><span class="line">        <span class="comment">// node结点已满，要插入尾部，并且node的后继未满，则插入后继的头部</span></span><br><span class="line">        <span class="comment">/* If we are: at tail, next has free space, and inserting after:</span></span><br><span class="line"><span class="comment">         *   - insert entry at head of next node. */</span></span><br><span class="line">        D(<span class="string">"Full and tail, but next isn't full; inserting next node head"</span>);</span><br><span class="line">        <span class="comment">// 后继节点</span></span><br><span class="line">        new_node = node-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时解压node-&gt;next结点</span></span><br><span class="line">        quicklistDecompressNodeForUse(new_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到node-&gt;next的头部位置</span></span><br><span class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更改计数</span></span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新quicklist大小</span></span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新压缩</span></span><br><span class="line">        quicklistRecompressOnly(quicklist, new_node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; at_head &amp;&amp; node-&gt;prev &amp;&amp; !full_prev &amp;&amp; !after) &#123;</span><br><span class="line">        <span class="comment">// node结点已满，要插入头部，并且node的前驱未满，则插入前驱的尾部</span></span><br><span class="line">        <span class="comment">/* If we are: at head, previous has free space, and inserting before:</span></span><br><span class="line"><span class="comment">         *   - insert entry at tail of previous node. */</span></span><br><span class="line">        D(<span class="string">"Full and head, but prev isn't full, inserting prev node tail"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前驱结点</span></span><br><span class="line">        new_node = node-&gt;prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时解药</span></span><br><span class="line">        quicklistDecompressNodeForUse(new_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到前驱的尾部</span></span><br><span class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz, ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计数</span></span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存大小</span></span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新压缩</span></span><br><span class="line">        quicklistRecompressOnly(quicklist, new_node);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full &amp;&amp; ((at_tail &amp;&amp; node-&gt;next &amp;&amp; full_next &amp;&amp; after) ||</span><br><span class="line">                        (at_head &amp;&amp; node-&gt;prev &amp;&amp; full_prev &amp;&amp; !after))) &#123;</span><br><span class="line">        <span class="comment">// node结点已满</span></span><br><span class="line">        <span class="comment">// 1. 插入尾部，但后继已满; 2. 插入头部，但前驱已满</span></span><br><span class="line">        <span class="comment">// 所以创建新结点</span></span><br><span class="line">        <span class="comment">/* If we are: full, and our prev/next is full, then:</span></span><br><span class="line"><span class="comment">         *   - create new node and attach to quicklist */</span></span><br><span class="line">        D(<span class="string">"\tprovisioning new node..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建新结点</span></span><br><span class="line">        new_node = quicklistCreateNode();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到新结点ziplist的头部</span></span><br><span class="line">        new_node-&gt;zl = ziplistPush(ziplistNew(), value, sz, ZIPLIST_HEAD);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新计数</span></span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存大小</span></span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入新结点到quicklist</span></span><br><span class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (full) &#123;</span><br><span class="line">        <span class="comment">// node结点已满，需要分割结点</span></span><br><span class="line">        <span class="comment">/* else, node is full we need to split it. */</span></span><br><span class="line">        <span class="comment">/* covers both after and !after cases */</span></span><br><span class="line">        D(<span class="string">"\tsplitting node..."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 临时解压</span></span><br><span class="line">        quicklistDecompressNodeForUse(node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分割结点</span></span><br><span class="line">        new_node = _quicklistSplitNode(node, entry-&gt;offset, after);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入到新结点</span></span><br><span class="line">        new_node-&gt;zl = ziplistPush(new_node-&gt;zl, value, sz,</span><br><span class="line">                                   after ? ZIPLIST_HEAD : ZIPLIST_TAIL);</span><br><span class="line">        <span class="comment">// 更新计数</span></span><br><span class="line">        new_node-&gt;count++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更新内存大小</span></span><br><span class="line">        quicklistNodeUpdateSz(new_node);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 插入分割后的新结点</span></span><br><span class="line">        __quicklistInsertNode(quicklist, node, new_node, after);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并</span></span><br><span class="line">        _quicklistMergeNodes(quicklist, node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新quicklist计数</span></span><br><span class="line">    quicklist-&gt;count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>entry删除</p>
<p>根据范围进行删除，若结点中ziplist全部删除，则需要删除该结点</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quicklistDelRange</span><span class="params">(quicklist *quicklist, <span class="keyword">const</span> <span class="keyword">long</span> start,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的个数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extent = count; <span class="comment">/* range is inclusive of start position */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start &gt;= <span class="number">0</span> &amp;&amp; extent &gt; (quicklist-&gt;count - start)) &#123;</span><br><span class="line">        <span class="comment">// start 是正数，正向删除</span></span><br><span class="line">        <span class="comment">/* if requesting delete more elements than exist, limit to list size. */</span></span><br><span class="line">        extent = quicklist-&gt;count - start;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt; <span class="number">0</span> &amp;&amp; extent &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(-start)) &#123;</span><br><span class="line">        <span class="comment">// start 是负数，反向删除</span></span><br><span class="line">        <span class="comment">/* else, if at negative offset, limit max size to rest of list. */</span></span><br><span class="line">        extent = -start; <span class="comment">/* c.f. LREM -29 29; just delete until end. */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    quicklistEntry entry;</span><br><span class="line">    <span class="keyword">if</span> (!quicklistIndex(quicklist, start, &amp;entry))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    D(<span class="string">"Quicklist delete request for start %ld, count %ld, extent: %ld"</span>, start,</span><br><span class="line">      count, extent);</span><br><span class="line">    quicklistNode *node = entry.node;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* iterate over next nodes until everything is deleted. */</span></span><br><span class="line">    <span class="comment">// 遍历要删除的个数</span></span><br><span class="line">    <span class="keyword">while</span> (extent) &#123;</span><br><span class="line">        <span class="comment">// 备份下一结点</span></span><br><span class="line">        quicklistNode *next = node-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> del;</span><br><span class="line">        <span class="keyword">int</span> delete_entire_node = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (entry.offset == <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 偏移量为0，删除个数大于总个数，表示全部删除</span></span><br><span class="line">            <span class="comment">/* If we are deleting more than the count of this node, we</span></span><br><span class="line"><span class="comment">             * can just delete the entire node without ziplist math. */</span></span><br><span class="line">            delete_entire_node = <span class="number">1</span>;</span><br><span class="line">            del = node-&gt;count;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &gt;= <span class="number">0</span> &amp;&amp; extent &gt;= node-&gt;count) &#123;</span><br><span class="line">            <span class="comment">// 偏移量不为0，删除个数大于总个数，表示总偏移量开始删除所有</span></span><br><span class="line">            <span class="comment">/* If deleting more nodes after this one, calculate delete based</span></span><br><span class="line"><span class="comment">             * on size of current node. */</span></span><br><span class="line">            del = node-&gt;count - entry.offset;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 偏移量为负数，从尾结点向前删除</span></span><br><span class="line">            <span class="comment">/* If offset is negative, we are in the first run of this loop</span></span><br><span class="line"><span class="comment">             * and we are deleting the entire range</span></span><br><span class="line"><span class="comment">             * from this start offset to end of list.  Since the Negative</span></span><br><span class="line"><span class="comment">             * offset is the number of elements until the tail of the list,</span></span><br><span class="line"><span class="comment">             * just use it directly as the deletion count. */</span></span><br><span class="line">            del = -entry.offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the positive offset is greater than the remaining extent,</span></span><br><span class="line"><span class="comment">             * we only delete the remaining extent, not the entire offset.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (del &gt; extent)</span><br><span class="line">                del = extent;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 删除的结点在中间</span></span><br><span class="line">            <span class="comment">/* else, we are deleting less than the extent of this node, so</span></span><br><span class="line"><span class="comment">             * use extent directly. */</span></span><br><span class="line">            del = extent;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        D(<span class="string">"[%ld]: asking to del: %ld because offset: %d; (ENTIRE NODE: %d), "</span></span><br><span class="line">          <span class="string">"node count: %u"</span>,</span><br><span class="line">          extent, del, entry.offset, delete_entire_node, node-&gt;count);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 表示该结点的全部删除</span></span><br><span class="line">        <span class="keyword">if</span> (delete_entire_node) &#123;</span><br><span class="line">            __quicklistDelNode(quicklist, node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 临时解压</span></span><br><span class="line">            quicklistDecompressNodeForUse(node);</span><br><span class="line">            <span class="comment">// 删除ziplist的一段范围</span></span><br><span class="line">            node-&gt;zl = ziplistDeleteRange(node-&gt;zl, entry.offset, del);</span><br><span class="line">            <span class="comment">// 更新计数</span></span><br><span class="line">            quicklistNodeUpdateSz(node);</span><br><span class="line">            node-&gt;count -= del;</span><br><span class="line">            quicklist-&gt;count -= del;</span><br><span class="line">            <span class="comment">// 删除为空的node</span></span><br><span class="line">            quicklistDeleteIfEmpty(quicklist, node);</span><br><span class="line">            <span class="keyword">if</span> (node)</span><br><span class="line">                <span class="comment">// node未删除，则重新压缩</span></span><br><span class="line">                quicklistRecompressOnly(quicklist, node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        extent -= del;</span><br><span class="line">        node = next;</span><br><span class="line">        entry.offset = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/09/redis/7_压缩字典/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/redis/7_压缩字典/" itemprop="url">
                  Redis源码阅读(七) 压缩字典
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-09 16:39:42 / 修改时间：16:39:49" itemprop="dateCreated datePublished" datetime="2018-08-09T16:39:42+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p>zipmap是为了优化string==&gt;string的映射而实现的特殊编码结构，它由7部分组成，zmlen,klen,key,vlen,free,val,end，但实际上讲只有4部分，zmlen,len(klen,vlen,end),data(key,val),free。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">zmlen</td>
<td style="text-align:center">1字节大小，存储了压缩字典中kv对的个数，当超过254时，需要遍历才能获取结点数</td>
</tr>
<tr>
<td style="text-align:center">klen</td>
<td style="text-align:center">key的长度，0~253时使用1字节，254表示由后4字节表示长度</td>
</tr>
<tr>
<td style="text-align:center">key</td>
<td style="text-align:center">字典的key值</td>
</tr>
<tr>
<td style="text-align:center">vlen</td>
<td style="text-align:center">val的长度，0~253时使用1字节，254表示由后4字节表示长度</td>
</tr>
<tr>
<td style="text-align:center">free</td>
<td style="text-align:center">1字节大小，value数据缩小后，产生的内存空间剩余</td>
</tr>
<tr>
<td style="text-align:center">val</td>
<td style="text-align:center">结点的val值</td>
</tr>
<tr>
<td style="text-align:center">end</td>
<td style="text-align:center">结束标志，实际上是len属性，当len=255时表示压缩字典结束</td>
</tr>
</tbody>
</table>
<p>zipmap并没有像ziplist连锁更新之类的特殊操作，只是对内存进行一些移动，扩展，收缩等待。</p>
<h3 id="2-源码剖析"><a href="#2-源码剖析" class="headerlink" title="2. 源码剖析"></a>2. 源码剖析</h3><ul>
<li>查找结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据key查询zipmap中的kv结点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapLookupRaw</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">int</span> *totlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zm+<span class="number">1</span>, *k = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> l,llen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历zipmap中的结点</span></span><br><span class="line">    <span class="keyword">while</span>(*p != ZIPMAP_END) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Match or skip the key */</span></span><br><span class="line">        <span class="comment">// 当前结点的长度</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算存储该长度需要的字节数</span></span><br><span class="line">        llen = zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (key != <span class="literal">NULL</span> &amp;&amp; k == <span class="literal">NULL</span> &amp;&amp; l == klen &amp;&amp; !<span class="built_in">memcmp</span>(p+llen,key,l)) &#123;</span><br><span class="line">            <span class="comment">/* Only return when the user doesn't care</span></span><br><span class="line"><span class="comment">             * for the total length of the zipmap. */</span></span><br><span class="line">            <span class="comment">// 我们不需要关系zipmap的长度时直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                k = p;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取value的地址</span></span><br><span class="line">        p += llen+l;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Skip the value as well */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取value的长度</span></span><br><span class="line">        l = zipmapDecodeLength(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过value，指向下一个地址</span></span><br><span class="line">        p += zipmapEncodeLength(<span class="literal">NULL</span>,l);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取value后剩余未使用空间大小</span></span><br><span class="line">        <span class="built_in">free</span> = p[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// +l表示跳过value结点长度</span></span><br><span class="line">        <span class="comment">// +1表示跳过存储free长度</span></span><br><span class="line">        <span class="comment">// +free表示跳过value剩余空间</span></span><br><span class="line">        p += l+<span class="number">1</span>+<span class="built_in">free</span>; <span class="comment">/* +1 to skip the free byte */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录总长度</span></span><br><span class="line">    <span class="keyword">if</span> (totlen != <span class="literal">NULL</span>) *totlen = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(p-zm)+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在压缩字典中添加kv对</span></span><br><span class="line"><span class="comment"> * 若update不为NULL，那么key存在在update=1，否则为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapSet</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">unsigned</span> <span class="keyword">char</span> *val, <span class="keyword">unsigned</span> <span class="keyword">int</span> vlen, <span class="keyword">int</span> *update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, offset;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> freelen, reqlen = zipmapRequiredLength(klen,vlen);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> empty, vempty;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储kv对总共需要多少字节</span></span><br><span class="line">    freelen = reqlen;</span><br><span class="line">    <span class="keyword">if</span> (update) *update = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找key是否存在，并存储总字节数</span></span><br><span class="line">    p = zipmapLookupRaw(zm,key,klen,&amp;zmlen);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* Key not found: enlarge */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不存在扩展内存空间</span></span><br><span class="line">        zm = zipmapResize(zm, zmlen+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 压缩列表末尾处</span></span><br><span class="line">        p = zm+zmlen<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 扩展后的总字节数</span></span><br><span class="line">        zmlen = zmlen+reqlen;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Increase zipmap length (this is an insert) */</span></span><br><span class="line">        <span class="comment">// &lt;zmlen&gt; 存储kv个数，kv个数+1</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]++;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Key found. Is there enough space for the new value? */</span></span><br><span class="line">        <span class="comment">/* Compute the total length: */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到该key，则判断是否有空间存储下value</span></span><br><span class="line">        <span class="keyword">if</span> (update) *update = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算结点总字节数</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p);</span><br><span class="line">        <span class="keyword">if</span> (freelen &lt; reqlen) &#123;</span><br><span class="line">            <span class="comment">/* Store the offset of this key within the current zipmap, so</span></span><br><span class="line"><span class="comment">             * it can be resized. Then, move the tail backwards so this</span></span><br><span class="line"><span class="comment">             * pair fits at the current position. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储不下，则需要扩展内存</span></span><br><span class="line">            offset = p-zm;</span><br><span class="line">            zm = zipmapResize(zm, zmlen-freelen+reqlen);</span><br><span class="line">            p = zm+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* The +1 in the number of bytes to be moved is caused by the</span></span><br><span class="line"><span class="comment">             * end-of-zipmap byte. Note: the *original* zmlen is used. */</span></span><br><span class="line">            memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">            zmlen = zmlen-freelen+reqlen;</span><br><span class="line">            freelen = reqlen;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We now have a suitable block where the key/value entry can</span></span><br><span class="line"><span class="comment">     * be written. If there is too much free space, move the tail</span></span><br><span class="line"><span class="comment">     * of the zipmap a few bytes to the front and shrink the zipmap,</span></span><br><span class="line"><span class="comment">     * as we want zipmaps to be very space efficient. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 此时已经有足够的空间存储</span></span><br><span class="line">    <span class="comment">// 计算剩余空间,若大于最大free，则缩小其内存</span></span><br><span class="line">    empty = freelen-reqlen;</span><br><span class="line">    <span class="keyword">if</span> (empty &gt;= ZIPMAP_VALUE_MAX_FREE) &#123;</span><br><span class="line">        <span class="comment">/* First, move the tail &lt;empty&gt; bytes to the front, then resize</span></span><br><span class="line"><span class="comment">         * the zipmap to be &lt;empty&gt; bytes smaller. */</span></span><br><span class="line">        offset = p-zm;</span><br><span class="line">        memmove(p+reqlen, p+freelen, zmlen-(offset+freelen+<span class="number">1</span>));</span><br><span class="line">        zmlen -= empty;</span><br><span class="line">        zm = zipmapResize(zm, zmlen);</span><br><span class="line">        p = zm+offset;</span><br><span class="line">        vempty = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        vempty = empty;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Just write the key + value and we are done. */</span></span><br><span class="line">    <span class="comment">/* Key: */</span></span><br><span class="line">    <span class="comment">// 添加kv数据到压缩字典中中</span></span><br><span class="line">    p += zipmapEncodeLength(p,klen);</span><br><span class="line">    <span class="built_in">memcpy</span>(p,key,klen);</span><br><span class="line">    p += klen;</span><br><span class="line">    <span class="comment">/* Value: */</span></span><br><span class="line">    p += zipmapEncodeLength(p,vlen);</span><br><span class="line">    *p++ = vempty;</span><br><span class="line">    <span class="built_in">memcpy</span>(p,val,vlen);</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span> *<span class="title">zipmapDel</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zm, <span class="keyword">unsigned</span> <span class="keyword">char</span> *key, <span class="keyword">unsigned</span> <span class="keyword">int</span> klen, <span class="keyword">int</span> *deleted)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> zmlen, freelen;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查找key结点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *p = zipmapLookupRaw(zm,key,klen,&amp;zmlen);</span><br><span class="line">    <span class="keyword">if</span> (p) &#123;</span><br><span class="line">        <span class="comment">// 计算该key+value的内存大小</span></span><br><span class="line">        freelen = zipmapRawEntryLength(p);</span><br><span class="line">        <span class="comment">// 删除kv数据</span></span><br><span class="line">        memmove(p, p+freelen, zmlen-((p-zm)+freelen+<span class="number">1</span>));</span><br><span class="line">        zm = zipmapResize(zm, zmlen-freelen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Decrease zipmap length */</span></span><br><span class="line">        <span class="keyword">if</span> (zm[<span class="number">0</span>] &lt; ZIPMAP_BIGLEN) zm[<span class="number">0</span>]--;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (deleted) *deleted = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/08/08/redis/6_压缩列表/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/redis/6_压缩列表/" itemprop="url">
                  Redis源码阅读(六) 压缩列表
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-08-08 15:57:45 / 修改时间：16:03:37" itemprop="dateCreated datePublished" datetime="2018-08-08T15:57:45+08:00">2018-08-08</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>压缩列表是Redis为了节省内存而设计的特殊编码的双端链表，可以存储字符串和整数，整数值保存为实际的整数而不是字符数组，它允许在链表两端进行push和pop操作，时间复杂度为O(1)，很多的操作需要对内存进行重新分配，所以实际情况还与内存使用的大小有关。</p>
<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><h4 id="1-1-压缩列表"><a href="#1-1-压缩列表" class="headerlink" title="1.1 压缩列表"></a>1.1 压缩列表</h4><p>从本质上来说，ziplist就是一串按照某种固定方式存储的字节数组，不依赖c语言的strcut，完全是内存的一些约束和操作，它包括5个组成部分zlbytes, zltail, zllen, entries,  zlend。</p>
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">类型</th>
<th style="text-align:center">长度</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">zlbytes</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">整个压缩列表使用的总字节数</td>
</tr>
<tr>
<td style="text-align:center">zltail</td>
<td style="text-align:center">uint32_t</td>
<td style="text-align:center">4字节</td>
<td style="text-align:center">尾结点到压缩列表头部有多少字节</td>
</tr>
<tr>
<td style="text-align:center">zllen</td>
<td style="text-align:center">uint16_t</td>
<td style="text-align:center">2字节</td>
<td style="text-align:center">结点的数量，超过UINT16_MAX则需要变量列表计算数量</td>
</tr>
<tr>
<td style="text-align:center">entries</td>
<td style="text-align:center">entry</td>
<td style="text-align:center">长度不定</td>
<td style="text-align:center">压缩列表的结点，多个结点间分割边界，通过结点属性值区分</td>
</tr>
<tr>
<td style="text-align:center">zlend</td>
<td style="text-align:center">uint8_t</td>
<td style="text-align:center">1字节</td>
<td style="text-align:center">结束标识符0XFF（255），表示压缩列表的结尾</td>
</tr>
</tbody>
</table>
<h4 id="1-2-压缩列表结点"><a href="#1-2-压缩列表结点" class="headerlink" title="1.2 压缩列表结点"></a>1.2 压缩列表结点</h4><p>结点可以存储字符串或在整数。</p>
<ul>
<li>字符串<ul>
<li>长度(1 ~ 2^6-1) 的字节数组</li>
<li>长度(1 ~ 2^14-1) 的字节数组</li>
<li>长度(1 ~ 2^32-1) 的字节数组</li>
</ul>
</li>
<li>整数值<ul>
<li>长度4bit，介于0 ~ 12的无符号整数</li>
<li>长度1字节，有符号整数</li>
<li>长度3字节，有符号整数</li>
<li>int16_t类型整数</li>
<li>int32_t类型整数</li>
<li>int64_t类型整数</li>
</ul>
</li>
</ul>
<p>每个结点由三部分组成，prevlen，encoding，entry-data</p>
<ul>
<li><p>prevlen</p>
<p>该属性表示当前结点的前驱结点的长度。</p>
<ul>
<li>若前驱结点长度小于254字节，使用1byte存储prevlen</li>
<li>若前驱结点长度大于等于254字节，使用5byte存储prevlen，其中第一字节被设置为0XFE，表示长度由后4字节表示。</li>
</ul>
<p>因为每个结点都保存了前一个结点的长度，所以可以通过地址计算出上一个结点的地址。</p>
</li>
<li><p>encoding</p>
<p>该属性表示当前结点保存数据所需要的类型和长度，有时候encoding也表示数据本身（小的整数值）</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>编码</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>00pppppp（1字节）</td>
<td>使用6bit存储字符串长度</td>
</tr>
<tr>
<td>01pppppp qqqqqqqq （2字节）</td>
<td>使用14bit存储字符串长度</td>
</tr>
<tr>
<td>10000000 xxxxx……..（5字节）</td>
<td>使用32bit存储字符串长度</td>
</tr>
<tr>
<td>11000000（1字节）</td>
<td>使用2字节表示int16_t</td>
</tr>
<tr>
<td>11010000（1字节）</td>
<td>使用4字节表示int32_t</td>
</tr>
<tr>
<td>11100000（1字节）</td>
<td>使用8字节表示int64_t</td>
</tr>
<tr>
<td>11110000（1字节）</td>
<td>使用3字节表示24位有符号整数</td>
</tr>
<tr>
<td>11111110（1字节）</td>
<td>使用1字节表示8位有符号整数</td>
</tr>
<tr>
<td>1111xxxx（1字节）</td>
<td>使用4bit表示 0 ~ 12无符号整数</td>
</tr>
<tr>
<td>11111111（1字节）</td>
<td>0xFF表示ziplist结束标识</td>
</tr>
</tbody>
</table>
<ul>
<li><p>entry-data</p>
<p>结点的数据值可以是一个字节数组或者整数，类型有encoding决定。</p>
</li>
</ul>
<h3 id="2-连锁更新"><a href="#2-连锁更新" class="headerlink" title="2. 连锁更新"></a>2. 连锁更新</h3><p>压缩列表中使用prevlen保存前驱结点的长度，长度小于254需要一个字节存储prevlen，但若长度大于254则需要5个字节进行存储，那么可能会存在这样的一种情况：</p>
<p>​    在一个ziplist中，存在多个连续的结点，大小介于250~253字节，如结点 A,B,C,D,E,F,…。这时，要插入一个大于254结点的O到B结点之前，由于B结点之前的prevlen保存的是A结点的长度(小于254)，所以只需要1个字节，但要保存结点O的话需要扩展prevlen为5个字节，这样导致B结点的大小大于了254，而C结点也需要扩展，如此产生连锁更新的效应。</p>
<p>添加结点可能触发压缩列表的连锁更新操作，这个操作的开销还是比较大的，在最坏的情况下需要执行N次重新分配内存操作。</p>
<blockquote>
<p>删除结点也可能导致这种情况发生，但为了防止一会扩展，一会缩小的抖动发生，当删除结点时出现这种情况并不进行处理。</p>
<p>实际情况中，这种极端情况比较少见，所以并不会对性能造成很大影响。</p>
</blockquote>
<h3 id="3-源码剖析"><a href="#3-源码剖析" class="headerlink" title="3. 源码剖析"></a>3. 源码剖析</h3><ul>
<li>连锁更新</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当一个结点插入时，我们需要设置下一个结点的prevlen等于插入结点的大小。</span></span><br><span class="line"><span class="comment"> * 这样会导致1个字节无法存储插入结点的长度，所以需要扩展到5个字节存储prevlen。</span></span><br><span class="line"><span class="comment"> * 但是，当多个连续结点的大小接近ZIP_BIG_PREVLEN时，当插入结点长度大于ZIP_BIG_PREVLEN，</span></span><br><span class="line"><span class="comment"> * 就需要扩展后一个结点的prevlen为5字节，但后一个结点的长度本来是253，加4字节后大于了254,</span></span><br><span class="line"><span class="comment"> * 这就导致后一个字节也需要扩展，如此进行下去，连续接近254字节的结点都需要更新</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 反之来说，长度变小引起的连续缩小也是有可能的，但为了避免反复扩展-缩小，</span></span><br><span class="line"><span class="comment"> * 我们并不处理缩小的情况。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistCascadeUpdate(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), rawlen, rawlensize;</span><br><span class="line">    <span class="keyword">size_t</span> offset, noffset, extra;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *np;</span><br><span class="line">    zlentry cur, next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历ziplist</span></span><br><span class="line">    <span class="keyword">while</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个结点</span></span><br><span class="line">        zipEntry(p, &amp;cur);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 结点长度</span></span><br><span class="line">        rawlen = cur.headersize + cur.len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储结点长度所需字节数</span></span><br><span class="line">        rawlensize = zipStorePrevEntryLength(<span class="literal">NULL</span>,rawlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort if there is no next entry. */</span></span><br><span class="line">        <span class="comment">// 结尾标识则退出</span></span><br><span class="line">        <span class="keyword">if</span> (p[rawlen] == ZIP_END) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下一个结点，存储在next中</span></span><br><span class="line">        zipEntry(p+rawlen, &amp;next);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Abort when "prevlen" has not changed. */</span></span><br><span class="line">        <span class="comment">// 结点不需要改变prevlen，表示当前结点空间足够</span></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlen == rawlen) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next.prevrawlensize &lt; rawlensize) &#123;</span><br><span class="line">            <span class="comment">/* The "prevlen" field of "next" needs more bytes to hold</span></span><br><span class="line"><span class="comment">             * the raw length of "cur". */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 表示next的prevlen存储不了cur的结点长度</span></span><br><span class="line">            <span class="comment">// 所以程序需要对next结点的header部分进行扩展</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录偏移量</span></span><br><span class="line">            offset = p-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 计算需要扩展的字节大小</span></span><br><span class="line">            extra = rawlensize-next.prevrawlensize;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 扩展zl的空间大小</span></span><br><span class="line">            zl = ziplistResize(zl,curlen+extra);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 还原p指针的位置</span></span><br><span class="line">            p = zl+offset;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Current pointer and offset for next element. */</span></span><br><span class="line">            <span class="comment">// 记录下个结点的偏移量</span></span><br><span class="line">            np = p+rawlen;</span><br><span class="line">            noffset = np-zl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update tail offset when next element is not the tail element. */</span></span><br><span class="line">            <span class="comment">// 更新ziplist的tail结点，如果next是tail则不用更新</span></span><br><span class="line">            <span class="keyword">if</span> ((zl+intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))) != np) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                    intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+extra);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move the tail to the back. */</span></span><br><span class="line">            <span class="comment">// 移动插入位置之后的数据到尾部，为cur留出空间</span></span><br><span class="line">            memmove(np+rawlensize,</span><br><span class="line">                np+next.prevrawlensize,</span><br><span class="line">                curlen-noffset-next.prevrawlensize<span class="number">-1</span>);</span><br><span class="line">            zipStorePrevEntryLength(np,rawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Advance the cursor */</span></span><br><span class="line">            <span class="comment">// p指针指向下一个结点，当前ziplist的总字节数</span></span><br><span class="line">            p += rawlen;</span><br><span class="line">            curlen += extra;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// next结点的prevlen存储大于cur结点的大小，但不需要缩小，以防止抖动的发生</span></span><br><span class="line">            <span class="keyword">if</span> (next.prevrawlensize &gt; rawlensize) &#123;</span><br><span class="line">                <span class="comment">/* This would result in shrinking, which we want to avoid.</span></span><br><span class="line"><span class="comment">                 * So, set "rawlen" in the available bytes. */</span></span><br><span class="line">                <span class="comment">// 此处表示存储rawlen需要1字节，而next的prevlen有5字节</span></span><br><span class="line">                <span class="comment">// 但为防止抖动发生，不进行缩小操作，只把rawlen存储到next的prevlen中即可</span></span><br><span class="line">                zipStorePrevEntryLengthLarge(p+rawlen,rawlen);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// cur的rawlen刚好可以存储到next的prevlen中</span></span><br><span class="line">                zipStorePrevEntryLength(p+rawlen,rawlen);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Stop here, as the raw length of "next" has not changed. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistInsert(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">char</span> *s, <span class="keyword">unsigned</span> <span class="keyword">int</span> slen) &#123;</span><br><span class="line">    <span class="keyword">size_t</span> curlen = intrev32ifbe(ZIPLIST_BYTES(zl)), reqlen;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> prevlensize, prevlen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> value = <span class="number">123456789</span>; <span class="comment">/* initialized to avoid warning. Using a value</span></span><br><span class="line"><span class="comment">                                    that is easy to see if for some reason</span></span><br><span class="line"><span class="comment">                                    we use it uninitialized. */</span></span><br><span class="line">    zlentry tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Find out prevlen for the entry that is inserted. */</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123; <span class="comment">// 插入在表中间</span></span><br><span class="line">        ZIP_DECODE_PREVLEN(p, prevlensize, prevlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 插入表尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取表尾结点地址</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *ptail = ZIPLIST_ENTRY_TAIL(zl);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取一个结点的长度，用于插入结点的prevlen</span></span><br><span class="line">        <span class="keyword">if</span> (ptail[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">            prevlen = zipRawEntryLength(ptail);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* See if the entry can be encoded */</span></span><br><span class="line">    <span class="comment">// 转换字符串s为整数值，如可以，则存储在value中，编码方式存储在encoding中</span></span><br><span class="line">    <span class="keyword">if</span> (zipTryEncoding(s,slen,&amp;value,&amp;encoding)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 'encoding' is set to the appropriate integer encoding */</span></span><br><span class="line">        <span class="comment">// 保存encoding所需的字节数</span></span><br><span class="line">        reqlen = zipIntSize(encoding);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* 'encoding' is untouched, however zipStoreEntryEncoding will use the</span></span><br><span class="line"><span class="comment">         * string length to figure out how to encode it. */</span></span><br><span class="line">        <span class="comment">// 不能转换为整数，则长度为slen</span></span><br><span class="line">        reqlen = slen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need space for both the length of the previous entry and</span></span><br><span class="line"><span class="comment">     * the length of the payload. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算存储前驱结点长度所需要的字节数</span></span><br><span class="line">    reqlen += zipStorePrevEntryLength(<span class="literal">NULL</span>,prevlen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算存储当前结点长度所需要的字节数</span></span><br><span class="line">    reqlen += zipStoreEntryEncoding(<span class="literal">NULL</span>,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When the insert position is not equal to the tail, we need to</span></span><br><span class="line"><span class="comment">     * make sure that the next entry can hold this entry's length in</span></span><br><span class="line"><span class="comment">     * its prevlen field. */</span></span><br><span class="line">    <span class="keyword">int</span> forcelarge = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当插入的位置不是尾部，我们需要检查下个结点的prevlen是否足够</span></span><br><span class="line">    nextdiff = (p[<span class="number">0</span>] != ZIP_END) ? zipPrevLenByteDiff(p,reqlen) : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (nextdiff == <span class="number">-4</span> &amp;&amp; reqlen &lt; <span class="number">4</span>) &#123;</span><br><span class="line">        nextdiff = <span class="number">0</span>;</span><br><span class="line">        forcelarge = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Store offset because a realloc may change the address of zl. */</span></span><br><span class="line">    <span class="comment">// 计算偏移offset，因为realloc可能改变ziplist的地址</span></span><br><span class="line">    offset = p-zl;</span><br><span class="line">    zl = ziplistResize(zl,curlen+reqlen+nextdiff);</span><br><span class="line">    p = zl+offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Apply memory move when necessary and update tail offset. */</span></span><br><span class="line">    <span class="comment">// 如果移动了tail偏移量，则需要移动内存</span></span><br><span class="line">    <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123;</span><br><span class="line">        <span class="comment">/* Subtract one because of the ZIP_END bytes */</span></span><br><span class="line">        <span class="comment">// 为新结点留出空间</span></span><br><span class="line">        memmove(p+reqlen,p-nextdiff,curlen-offset<span class="number">-1</span>+nextdiff);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Encode this entry's raw length in the next entry. */</span></span><br><span class="line">        <span class="comment">// 下个结点的prevlen扩展并存储</span></span><br><span class="line">        <span class="keyword">if</span> (forcelarge)</span><br><span class="line">            zipStorePrevEntryLengthLarge(p+reqlen,reqlen);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            zipStorePrevEntryLength(p+reqlen,reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update offset for tail */</span></span><br><span class="line">        <span class="comment">// 更新尾部偏移</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">            intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+reqlen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">         * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">         * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">        <span class="comment">// 当尾部包括超过1个结点时，我们需要计算nextdiff差值，否则就不够存储</span></span><br><span class="line">        zipEntry(p+reqlen, &amp;tail);</span><br><span class="line">        <span class="keyword">if</span> (p[reqlen+tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* This element will be the new tail. */</span></span><br><span class="line">        <span class="comment">// 插入在尾部，新结点就是尾结点</span></span><br><span class="line">        ZIPLIST_TAIL_OFFSET(zl) = intrev32ifbe(p-zl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">     * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">    <span class="comment">// 若nextdiff不为0，可能发生连锁更新</span></span><br><span class="line">    <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) &#123;</span><br><span class="line">        offset = p-zl;</span><br><span class="line">        zl = __ziplistCascadeUpdate(zl,p+reqlen);</span><br><span class="line">        p = zl+offset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the entry */</span></span><br><span class="line">    <span class="comment">// 前驱结点的长度写入到插入结点的prevlen</span></span><br><span class="line">    p += zipStorePrevEntryLength(p,prevlen);</span><br><span class="line">    <span class="comment">// 插入接的的长度写入到插入节点的encoding</span></span><br><span class="line">    p += zipStoreEntryEncoding(p,encoding,slen);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据编码方式，将结点值写入value</span></span><br><span class="line">    <span class="keyword">if</span> (ZIP_IS_STR(encoding)) &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(p,s,slen);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        zipSaveInteger(p,value,encoding);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ziplist结点个数+1</span></span><br><span class="line">    ZIPLIST_INCR_LENGTH(zl,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>删除结点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> *__ziplistDelete(<span class="keyword">unsigned</span> <span class="keyword">char</span> *zl, <span class="keyword">unsigned</span> <span class="keyword">char</span> *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> num) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i, totlen, deleted = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> offset;</span><br><span class="line">    <span class="keyword">int</span> nextdiff = <span class="number">0</span>;</span><br><span class="line">    zlentry first, tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算要删除的结点个数和占用内存字节数</span></span><br><span class="line">    zipEntry(p, &amp;first);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; p[<span class="number">0</span>] != ZIP_END &amp;&amp; i &lt; num; i++) &#123;</span><br><span class="line">        p += zipRawEntryLength(p);</span><br><span class="line">        deleted++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要删除的字节数</span></span><br><span class="line">    totlen = p-first.p; <span class="comment">/* Bytes taken by the element(s) to delete. */</span></span><br><span class="line">    <span class="keyword">if</span> (totlen &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p[<span class="number">0</span>] != ZIP_END) &#123; <span class="comment">// p不是结束符</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Storing `prevrawlen` in this entry may increase or decrease the</span></span><br><span class="line"><span class="comment">             * number of bytes required compare to the current `prevrawlen`.</span></span><br><span class="line"><span class="comment">             * There always is room to store this, because it was previously</span></span><br><span class="line"><span class="comment">             * stored by an entry that is now being deleted. */</span></span><br><span class="line">            <span class="comment">// 由于删除结点后，下个结点的prevlen可能无法表示前驱结点的长度</span></span><br><span class="line">            <span class="comment">// 所以需要提前计算出其差值</span></span><br><span class="line">            nextdiff = zipPrevLenByteDiff(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Note that there is always space when p jumps backward: if</span></span><br><span class="line"><span class="comment">             * the new previous entry is large, one of the deleted elements</span></span><br><span class="line"><span class="comment">             * had a 5 bytes prevlen header, so there is for sure at least</span></span><br><span class="line"><span class="comment">             * 5 bytes free and we need just 4. */</span></span><br><span class="line">            <span class="comment">// p指针后移nextdiff差值，减少删除的字节数来存放多余的差值</span></span><br><span class="line">            p -= nextdiff;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将first的prevlen扩展到p</span></span><br><span class="line">            zipStorePrevEntryLength(p,first.prevrawlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Update offset for tail */</span></span><br><span class="line">            <span class="comment">// 更新表头偏移量tail_offset成员</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))-totlen);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When the tail contains more than one entry, we need to take</span></span><br><span class="line"><span class="comment">             * "nextdiff" in account as well. Otherwise, a change in the</span></span><br><span class="line"><span class="comment">             * size of prevlen doesn't have an effect on the *tail* offset. */</span></span><br><span class="line">            <span class="comment">// 记录当前p执行的结点，存储到tail中</span></span><br><span class="line">            zipEntry(p, &amp;tail);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 若删除的不是尾结点，表尾的偏移量需要加上nextdiff这个差值</span></span><br><span class="line">            <span class="keyword">if</span> (p[tail.headersize+tail.len] != ZIP_END) &#123;</span><br><span class="line">                ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                   intrev32ifbe(intrev32ifbe(ZIPLIST_TAIL_OFFSET(zl))+nextdiff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Move tail to the front of the ziplist */</span></span><br><span class="line">            <span class="comment">// 移动内存</span></span><br><span class="line">            memmove(first.p,p,</span><br><span class="line">                intrev32ifbe(ZIPLIST_BYTES(zl))-(p-zl)<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* The entire tail was deleted. No need to move memory. */</span></span><br><span class="line">            <span class="comment">// 由于是表尾结点，所以直接更新tail_offset</span></span><br><span class="line">            ZIPLIST_TAIL_OFFSET(zl) =</span><br><span class="line">                intrev32ifbe((first.p-zl)-first.prevrawlen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Resize and update length */</span></span><br><span class="line">        <span class="comment">// 删除多余的内存空间</span></span><br><span class="line">        offset = first.p-zl;</span><br><span class="line">        zl = ziplistResize(zl, intrev32ifbe(ZIPLIST_BYTES(zl))-totlen+nextdiff);</span><br><span class="line">        ZIPLIST_INCR_LENGTH(zl,-deleted);</span><br><span class="line">        p = zl+offset;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* When nextdiff != 0, the raw length of the next entry has changed, so</span></span><br><span class="line"><span class="comment">         * we need to cascade the update throughout the ziplist */</span></span><br><span class="line">        <span class="keyword">if</span> (nextdiff != <span class="number">0</span>) <span class="comment">// 考虑连锁更新</span></span><br><span class="line">            zl = __ziplistCascadeUpdate(zl,p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> zl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/gxcbuf.jpg"
                alt="郭欣成" />
            
              <p class="site-author-name" itemprop="name">郭欣成</p>
              <p class="site-description motion-element" itemprop="description">Persion & Developer</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/gxcbuf" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭欣成</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
