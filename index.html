<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Persion &amp; Developer">
<meta property="og:type" content="website">
<meta property="og:title" content="孰能生巧">
<meta property="og:url" content="http://gxcbuf.github.io/index.html">
<meta property="og:site_name" content="孰能生巧">
<meta property="og:description" content="Persion &amp; Developer">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孰能生巧">
<meta name="twitter:description" content="Persion &amp; Developer">






  <link rel="canonical" href="http://gxcbuf.github.io/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>孰能生巧</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?4aa8d6634642cbec4e6c0dd1c9f3ef00";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">孰能生巧</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">Practice makes Perfect.</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">
    <a href="/tags/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">
    <a href="/categories/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-about">
    <a href="/about/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-user"></i> <br />关于</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/10/25/redis/23_集群/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/25/redis/23_集群/" itemprop="url">
                  Redis源码阅读(二十三) 集群
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-25 16:11:13 / 修改时间：16:11:14" itemprop="dateCreated datePublished" datetime="2018-10-25T16:11:13+08:00">2018-10-25</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis集群是Redis的分布式实现，具有高性能和线性可扩展性，最多可拥有1000个节点；具有可接受的写入安全程度，系统尽力保留与大多主节点连接的客户端的所有写入；同时保持可用性，集群能够在大多数主节点可用区中存活。集群通过分片的方式进行数据共享，并提供复制和故障转移功能。</p>
<h3 id="1-集群节点"><a href="#1-集群节点" class="headerlink" title="1. 集群节点"></a>1. 集群节点</h3><p>Redis集群通常包含多个节点，但最开始时，每个节点都是独立的集群，要将它们连接在一起需要执行<code>CLUSTER MEET &lt;ip&gt; &lt;port&gt;</code>命令，让指定的节点与之握手，一旦握手成功，就会将该节点加入当前节点所在集群中。</p>
<h4 id="1-1-集群数据结构"><a href="#1-1-集群数据结构" class="headerlink" title="1.1 集群数据结构"></a>1.1 集群数据结构</h4><p>clusterNode结构保存节点当前状态，每个节点都会使用该结构为自己创建一个状态，并且也会为集群中其他节点创建相应的状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 节点创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; <span class="comment">/* Node object creation time. */</span></span><br><span class="line">    <span class="comment">// 节点名称</span></span><br><span class="line">    <span class="keyword">char</span> name[CLUSTER_NAMELEN]; <span class="comment">/* Node name, hex string, sha1-size */</span></span><br><span class="line">    <span class="comment">// 状态标识</span></span><br><span class="line">    <span class="keyword">int</span> flags;      <span class="comment">/* CLUSTER_NODE_... */</span></span><br><span class="line">    <span class="comment">// 最新的配置纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch; <span class="comment">/* Last configEpoch observed for this node */</span></span><br><span class="line">    <span class="comment">// 节点的槽位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* slots handled by this node */</span></span><br><span class="line">    <span class="comment">// 当前节点复制槽的数量</span></span><br><span class="line">    <span class="keyword">int</span> numslots;   <span class="comment">/* Number of slots handled by this node */</span></span><br><span class="line">    <span class="comment">// 从节点数量</span></span><br><span class="line">    <span class="keyword">int</span> numslaves;  <span class="comment">/* Number of slave nodes, if this is a master */</span></span><br><span class="line">    <span class="comment">// 从节点指针数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> **<span class="title">slaves</span>;</span> <span class="comment">/* pointers to slave nodes */</span></span><br><span class="line">    <span class="comment">// 指向主节点，可能为NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">slaveof</span>;</span> <span class="comment">/* pointer to the master node. Note that it</span></span><br><span class="line"><span class="comment">                                    may be NULL even if the node is a slave</span></span><br><span class="line"><span class="comment">                                    if we don't have the master node in our</span></span><br><span class="line"><span class="comment">                                    tables. */</span></span><br><span class="line">    <span class="comment">// 最新发送ping的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ping_sent;      <span class="comment">/* Unix time we sent latest ping */</span></span><br><span class="line">    <span class="comment">// 最新接收pong的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> pong_received;  <span class="comment">/* Unix time we received the pong */</span></span><br><span class="line">    <span class="comment">// 设置为FAIL的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> fail_time;      <span class="comment">/* Unix time when FAIL flag was set */</span></span><br><span class="line">    <span class="comment">// 最新投票的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> voted_time;     <span class="comment">/* Last time we voted for a slave of this master */</span></span><br><span class="line">    <span class="comment">// 复制偏移量的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> repl_offset_time;  <span class="comment">/* Unix time we received offset for this node */</span></span><br><span class="line">    <span class="comment">// 孤立的主节点迁移的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> orphaned_time;     <span class="comment">/* Starting time of orphaned master condition */</span></span><br><span class="line">    <span class="comment">// 该节点已知的复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> repl_offset;      <span class="comment">/* Last known repl offset for this node. */</span></span><br><span class="line">    <span class="comment">// 该节点已知的最新IP地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN];  <span class="comment">/* Latest known IP address of this node */</span></span><br><span class="line">    <span class="comment">// 最新的客户端端口</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">/* Latest known clients port of this node */</span></span><br><span class="line">    <span class="comment">// 最新的集群端口</span></span><br><span class="line">    <span class="keyword">int</span> cport;                  <span class="comment">/* Latest known cluster port of this node. */</span></span><br><span class="line">    <span class="comment">// 与该节点关联的TCP/IP连接</span></span><br><span class="line">    clusterLink *link;          <span class="comment">/* TCP/IP link with this node */</span></span><br><span class="line">    <span class="comment">// 保存下线报告的链表</span></span><br><span class="line">    <span class="built_in">list</span> *fail_reports;         <span class="comment">/* List of nodes signaling this as failing */</span></span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure>
<p>clusterLink结构是存储连接该节点所需的有关信息状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line">    <span class="comment">// 连接创建的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;             <span class="comment">/* Link creation time */</span></span><br><span class="line">    <span class="comment">// TCP socket连接的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;                     <span class="comment">/* TCP socket file descriptor */</span></span><br><span class="line">    <span class="comment">// 输出缓冲区</span></span><br><span class="line">    sds sndbuf;                 <span class="comment">/* Packet send buffer */</span></span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    sds rcvbuf;                 <span class="comment">/* Packet reception buffer */</span></span><br><span class="line">    <span class="comment">// 关联该连接的节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>   <span class="comment">/* Node related to this link if any, or NULL */</span></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>redisClient和clusterLink都有自己的socket、文件描述符和输入输出缓冲区，不同的是redisClient用于保存客户端的连接，而clusterLink用于保存节点间的连接</p>
</blockquote>
<p>每个节点都有一个clusterState结构，该结构记录了当前纪元集群的状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 节点自身</span></span><br><span class="line">    clusterNode *myself;  <span class="comment">/* This node */</span></span><br><span class="line">    <span class="comment">// 节点当前纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line">    <span class="comment">// 集群状态</span></span><br><span class="line">    <span class="keyword">int</span> state;            <span class="comment">/* CLUSTER_OK, CLUSTER_FAIL, ... */</span></span><br><span class="line">    <span class="comment">// 集群中至少负责一个槽的主节点数</span></span><br><span class="line">    <span class="keyword">int</span> size;             <span class="comment">/* Num of master nodes with at least one slot */</span></span><br><span class="line">    <span class="comment">// 集群节点字典，键是节点名称，值是节点结构</span></span><br><span class="line">    dict *nodes;          <span class="comment">/* Hash table of name -&gt; clusterNode structures */</span></span><br><span class="line">    <span class="comment">// 防止重复添加节点的黑名单</span></span><br><span class="line">    dict *nodes_black_list; <span class="comment">/* Nodes we don't re-add for a few seconds. */</span></span><br><span class="line">    clusterNode *migrating_slots_to[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *importing_slots_from[CLUSTER_SLOTS];</span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    <span class="keyword">uint64_t</span> slots_keys_count[CLUSTER_SLOTS];</span><br><span class="line">    rax *slots_to_keys;</span><br><span class="line">    <span class="comment">/* The following fields are used to take the slave state on elections. */</span></span><br><span class="line">    <span class="comment">// 之前或下次选举时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_auth_time; <span class="comment">/* Time of previous or next election. */</span></span><br><span class="line">    <span class="comment">// 节点获得投票数</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_count;    <span class="comment">/* Number of votes received so far. */</span></span><br><span class="line">    <span class="comment">// 节点已经发送投票请求</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_sent;     <span class="comment">/* True if we already asked for votes. */</span></span><br><span class="line">    <span class="comment">// 节点当前排名</span></span><br><span class="line">    <span class="keyword">int</span> failover_auth_rank;     <span class="comment">/* This slave rank for current auth request. */</span></span><br><span class="line">    <span class="comment">// 选举的当前纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> failover_auth_epoch; <span class="comment">/* Epoch of the current election. */</span></span><br><span class="line">    <span class="comment">// 从节点不能执行故障转移的原因</span></span><br><span class="line">    <span class="keyword">int</span> cant_failover_reason;   <span class="comment">/* Why a slave is currently not able to</span></span><br><span class="line"><span class="comment">                                   failover. See the CANT_FAILOVER_* macros. */</span></span><br><span class="line">    <span class="comment">/* Manual failover state in common. */</span></span><br><span class="line">    <span class="comment">// 手动故障转移的时间限制，为0表示没有正在执行的手动故障转移</span></span><br><span class="line">    <span class="keyword">mstime_t</span> mf_end;            <span class="comment">/* Manual failover time limit (ms unixtime).</span></span><br><span class="line"><span class="comment">                                   It is zero if there is no MF in progress. */</span></span><br><span class="line">    <span class="comment">/* Manual failover state of master. */</span></span><br><span class="line">    <span class="comment">// 手动故障转移的状态</span></span><br><span class="line">    <span class="comment">// 执行手动故障转移的从节点</span></span><br><span class="line">    clusterNode *mf_slave;      <span class="comment">/* Slave performing the manual failover. */</span></span><br><span class="line">    <span class="comment">/* Manual failover state of slave. */</span></span><br><span class="line">    <span class="comment">// 从节点记录手动故障转移的主节点偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mf_master_offset; <span class="comment">/* Master offset the slave needs to start MF</span></span><br><span class="line"><span class="comment">                                   or zero if stil not received. */</span></span><br><span class="line">    <span class="comment">// 非零表示可以开始手动故障转移</span></span><br><span class="line">    <span class="keyword">int</span> mf_can_start;           <span class="comment">/* If non-zero signal that the manual failover</span></span><br><span class="line"><span class="comment">                                   can start requesting masters vote. */</span></span><br><span class="line">    <span class="comment">/* The followign fields are used by masters to take state on elections. */</span></span><br><span class="line">    <span class="comment">// 集群最后一次投票的纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> lastVoteEpoch;     <span class="comment">/* Epoch of the last vote granted. */</span></span><br><span class="line">    <span class="keyword">int</span> todo_before_sleep; <span class="comment">/* Things to do in clusterBeforeSleep(). */</span></span><br><span class="line">    <span class="comment">/* Messages received and sent by type. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stats_bus_messages_sent[CLUSTERMSG_TYPE_COUNT];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stats_bus_messages_received[CLUSTERMSG_TYPE_COUNT];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stats_pfail_nodes;    <span class="comment">/* Number of nodes in PFAIL status,</span></span><br><span class="line"><span class="comment">                                       excluding nodes without address. */</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<h4 id="1-2-CLUSTER-MEET命令"><a href="#1-2-CLUSTER-MEET命令" class="headerlink" title="1.2 CLUSTER MEET命令"></a>1.2 <code>CLUSTER MEET</code>命令</h4><p>收到命令的节点A将于指定地址端口的节点B进行握手：</p>
<ol>
<li>节点A为节点B创建clusterNode结构，保存B的状态信息，并添加到自己的<code>clusterState.nodes</code>中</li>
<li>节点A向节点B发送MEET消息</li>
<li>节点B接收到A的MEET消息，会为A创建clusterNode结构，同样保存到自己的<code>clusterState.nodes</code>中</li>
<li>节点B返回PONG消息给节点A</li>
<li>节点A接收到PONG消息，表示与B节点MEET成功</li>
<li>节点A发送PING给节点B</li>
<li>节点B收到节点A的PING消息，表示节点A已经收到了自己的PONG</li>
</ol>
<h3 id="2-散列槽指派"><a href="#2-散列槽指派" class="headerlink" title="2. 散列槽指派"></a>2. 散列槽指派</h3><p>Redis集群通过分片的方式保存键值对，集群中整个数据库被分为16384个slot，通过<code>HASH_SLOT = CRC16(key) mod 16384</code>的方式确定某个键存储在哪个散列槽中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 节点的槽位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[CLUSTER_SLOTS/<span class="number">8</span>]; <span class="comment">/* slots handled by this node */</span></span><br><span class="line">    <span class="comment">// 当前节点复制槽的数量</span></span><br><span class="line">    <span class="keyword">int</span> numslots;   <span class="comment">/* Number of slots handled by this node */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure>
<p>slots是一个二进制位数组，长度为16384/8=2048个字节，包含16384个二进制位，刚好对应每个散列槽。如果节点的slots数组的第i位为1，表示该节点负责这个散列槽数据的处理。numslots表示当前节点处理散列槽的数量。</p>
<p>每个节点除了负责字节要处理的散列槽之外，还需要将自己slots数组告知集群的其他节点，当节点接收到来自其他节点的信息后，会更新自己保存的状态数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    clusterNode *slots[CLUSTER_SLOTS];</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure>
<p>clusterState结构中slots记录了集群所有散列槽的指派信息，slots数组包含16384个项，每个都是指向集群节点的指针。如果slots[i]为NULL，表示该散列槽尚未指派给任何节点，否则指向处理给散列槽的节点。</p>
<h3 id="3-重定向和重新分片"><a href="#3-重定向和重新分片" class="headerlink" title="3. 重定向和重新分片"></a>3. 重定向和重新分片</h3><h4 id="3-1-MOVED错误"><a href="#3-1-MOVED错误" class="headerlink" title="3.1 MOVED错误"></a>3.1 MOVED错误</h4><p>在对数据的16384个散列槽都进行了指派后，集群就会进入上线状态，这时Redis客户端可以自由的向集群中每个节点发送查询，当命令与数据库键有关时，节点会计算该键属于哪个散列槽，并检查该散列槽是否指派给自己，如果该散列槽并未指派给自己，那么节点会返回一个MOVED错误，告知客户端重定向到正确的节点。</p>
<p>MOVED错误的格式为<code>MOVED &lt;slot&gt; &lt;ip&gt;:&lt;port&gt;</code>，当客户端接收到节点返回的MOVED错误信息，会根据其提供的IP和端口号访问该节点，重新执行之前的命令。</p>
<h4 id="3-2-重新分片"><a href="#3-2-重新分片" class="headerlink" title="3.2 重新分片"></a>3.2 重新分片</h4><p>Redis集群的重新分片可以修改散列槽的指派，并且对应槽的键也会修改到相应节点。该操作可以在线进行，重新分片过程中，集群不需要下线，而且还可以继续处理请求。</p>
<p>Redis集群重新分片由<code>redis-trib</code>负责执行，它对集群某单个散列槽重新分片步骤如下：</p>
<ol>
<li><code>redis-trib</code>向目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让目标节点准备好从源节点导入指定散列槽的键值对。</li>
<li><code>redis-trib</code>向源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>命令，让源节点准备好将指定散列槽的键值对迁移至目标节点</li>
<li><code>redis-trib</code>向源节点发送<code>CLUSTER GETKEYSINLSOT &lt;slot&gt; &lt;count&gt;</code>命令，获得最多count个属于slot的键值对的键</li>
<li>对于3获得的每个key，<code>redis-trib</code>向源节点发送<code>MIGRATE &lt;target_ip&gt; &lt;target_port&gt; &lt;key_name&gt; 0 &lt;timeout&gt;</code>，将键原子的从源节点迁移到目标节点</li>
<li>重复执行步骤3、4，直到指定散列槽所有键值对迁移完成</li>
<li><code>redis-trib</code>向集群中任一节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>，将散列槽slot指派给目标节点，这一指派信息会发送给整个集群</li>
</ol>
<h4 id="3-3-ASK错误"><a href="#3-3-ASK错误" class="headerlink" title="3.3 ASK错误"></a>3.3 ASK错误</h4><p>节点接收到有关key的命令，若为在自己数据库内查到该key，则检查自己的<code>clusterState.migrating_slots_to[i]</code>，如果该key正在进行迁移，那么节点回复客户端一个ASK错误，指引客户端在正确位置寻找key。</p>
<h4 id="3-4-ASKING"><a href="#3-4-ASKING" class="headerlink" title="3.4 ASKING"></a>3.4 ASKING</h4><p>客户端请求集群中节点关于键key的命令，若该节点并未指派key所在的散列槽，但节点的<code>clusterState.importing_slots_from[i]</code>表示正在导入散列槽i，并且发送命令客户端带有<code>REDIS_ASKING</code>标识，那么节点将执行关于该散列槽的操作一次。</p>
<p>当客户端接收到ASK错误并转向正在导入散列槽的节点时，先向节点发送ASKING命令，然后重新发送要执行的命令，因为不发生ASKING命令而直接发送执行命令，会被节点拒绝，并返回MOVED错误。</p>
<h4 id="3-5-MOVED错误和ASK错误的区别"><a href="#3-5-MOVED错误和ASK错误的区别" class="headerlink" title="3.5 MOVED错误和ASK错误的区别"></a>3.5 MOVED错误和ASK错误的区别</h4><ul>
<li>MOVED错误表示散列槽的负责权已经从一个节点转移到另一个节点，当客户端遇到MOVED错误，只需将目标节点换成MOVED重定向的节点</li>
<li>ASK错误是两个节点散列槽迁移过程中的临时措施，客户端收到ASK错误后，会在接下来的命令请求换成ASK错误中指定的节点，但之后并不会改变，客户端仍然请求源节点</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/10/24/redis/22_哨兵Sentinel/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/24/redis/22_哨兵Sentinel/" itemprop="url">
                  Redis源码阅读(二十二) Sentinel哨兵
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-24 11:13:37 / 修改时间：11:13:39" itemprop="dateCreated datePublished" datetime="2018-10-24T11:13:37+08:00">2018-10-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>Sentinel是运行在一个特殊模式下的Redis服务器，由一个或多个服务器构成，它解决了Redis的高可用性，用于监视多个主从服务器，当主服务器下线时会选择该主服务器的从服务器作为新的主节点。</p>
<p>Redis Sentinel提供其他附属任务，如监控，通知，并充当客户端的配置提供程序。</p>
<ul>
<li>监控：Sentinel会不断检查主从节点是否按预期进行工作。</li>
<li>通知：Sentinel可以通过API通知系统管理员，另一台受监控的Redis实例出现故障。</li>
<li>自动故障转移：如果主节点出现故障，Sentinel可以启动故障转移程序，选择一个从节点升级为主节点，其它从节点重新配置为使用新的主节点，并且使用Redis服务器的应用程序通知有关新服务器的地址和链接。</li>
<li>配置提供商：Sentinel充当客户端服务发现的权限来源：客户端链接到Sentinel以询问负责给定服务的当前Redis主节点的地址，如发生故障转移，则报告新地址。</li>
</ul>
<p>Redis Sentinel是一个分布式系统，可以在多个Sentinel进程中协同工作，当多个Sentinels同意给定主节点不可用时才会执行故障转移，降低误报可能性；即使Sentinel系统中有几个服务器故障，它也能正常工作。</p>
<h3 id="2-Sentinel基础"><a href="#2-Sentinel基础" class="headerlink" title="2. Sentinel基础"></a>2. Sentinel基础</h3><p>启动Sentinel可以使用<code>redis-sentinel /path/to/sentinel.conf</code>或<code>redis-server /path/to/sentinel.conf --sentinel</code>命令，这两个命令等效，在运行Sentinel时必须使用配置文件，默认情况下会监听TCP端口26379。</p>
<p>在启动Sentinel必须注意：</p>
<ol>
<li>至少需要3台Sentinel实例</li>
<li>3台实例必须位于不同的可用区，如物理机或虚拟机，不能在同一台主机</li>
<li>Sentinel+Redis分布式系统因为使用异步复制，所以不保证在故障期间保留已确认的写入</li>
<li>需要在客户端支持Sentinel，大多数目前都支持，但仍有些尚未支持</li>
<li><strong>Docker或其他形式的网络地址或端口映射应该谨慎使用</strong>: Docker执行端口重新映射，会打破其他Sentinel进程的Sentinel自动发现以及主服务器的从属列表。</li>
</ol>
<h4 id="2-1-初始化Sentinel"><a href="#2-1-初始化Sentinel" class="headerlink" title="2.1 初始化Sentinel"></a>2.1 初始化Sentinel</h4><p>Sentinel本质是运行在特殊模式下的Redis服务器，所以我们先启动一个Redis服务器，然后让其执行Sentinel部分的代码。</p>
<ol>
<li><p>Sentinel模式下有特殊的命令表，之前普通服务器的命令表会被清空，换成新的命令表。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sentinel模式下可执行命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> <span class="title">sentinelcmds</span>[] = &#123;</span></span><br><span class="line">    &#123;<span class="string">"ping"</span>,pingCommand,<span class="number">1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"sentinel"</span>,sentinelCommand,<span class="number">-2</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"subscribe"</span>,subscribeCommand,<span class="number">-2</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"unsubscribe"</span>,unsubscribeCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"psubscribe"</span>,psubscribeCommand,<span class="number">-2</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"punsubscribe"</span>,punsubscribeCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"publish"</span>,sentinelPublishCommand,<span class="number">3</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"info"</span>,sentinelInfoCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"role"</span>,sentinelRoleCommand,<span class="number">1</span>,<span class="string">"l"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"client"</span>,clientCommand,<span class="number">-2</span>,<span class="string">"rs"</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"shutdown"</span>,shutdownCommand,<span class="number">-1</span>,<span class="string">""</span>,<span class="number">0</span>,<span class="literal">NULL</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在执行Sentinel代码后，服务器会初始化Sentinel的状态，来专属表示Sentinel功能相关的属性，原有服务器状态仍然会保留。</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sentinelState</span> &#123;</span></span><br><span class="line">    <span class="comment">// 哨兵ID, 41位</span></span><br><span class="line">    <span class="keyword">char</span> myid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* This sentinel ID. */</span></span><br><span class="line">    <span class="comment">// 当前纪元记录</span></span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch;         <span class="comment">/* Current epoch. */</span></span><br><span class="line">    <span class="comment">// 监控的主节点字典，键是主节点实例的名称，值是指向sentinelRedisInstance的指针</span></span><br><span class="line">    dict *masters;      <span class="comment">/* Dictionary of master sentinelRedisInstances.</span></span><br><span class="line"><span class="comment">                           Key is the instance name, value is the</span></span><br><span class="line"><span class="comment">                           sentinelRedisInstance structure pointer. */</span></span><br><span class="line">    <span class="comment">// 是否在TILT模式，该模式仅收集数据，不进行故障转移</span></span><br><span class="line">    <span class="keyword">int</span> tilt;           <span class="comment">/* Are we in TILT mode? */</span></span><br><span class="line">    <span class="comment">// 当前正在执行的脚本数量</span></span><br><span class="line">    <span class="keyword">int</span> running_scripts;    <span class="comment">/* Number of scripts in execution right now. */</span></span><br><span class="line">    <span class="comment">// TILT模式开始的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> tilt_start_time;       <span class="comment">/* When TITL started. */</span></span><br><span class="line">    <span class="comment">// 最后一次执行时间出来程序的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> previous_time;         <span class="comment">/* Last time we ran the time handler. */</span></span><br><span class="line">    <span class="comment">// 要执行用户脚本的队列</span></span><br><span class="line">    <span class="built_in">list</span> *scripts_queue;            <span class="comment">/* Queue of user scripts to execute. */</span></span><br><span class="line">    <span class="comment">// 多个Sentinel之间使用流言来接收关于主服务器是否下线的消息，</span></span><br><span class="line">    <span class="comment">// 并使用投票来决定是否执行自动故障迁移，以及选择哪个从服务器作为新的主服务器</span></span><br><span class="line">    <span class="comment">// 被流言到其他哨兵主机的IP</span></span><br><span class="line">    <span class="keyword">char</span> *announce_ip;  <span class="comment">/* IP addr that is gossiped to other sentinels if</span></span><br><span class="line"><span class="comment">                           not NULL. */</span></span><br><span class="line">    <span class="comment">// 端口</span></span><br><span class="line">    <span class="keyword">int</span> announce_port;  <span class="comment">/* Port that is gossiped to other sentinels if</span></span><br><span class="line"><span class="comment">                           non zero. */</span></span><br><span class="line">    <span class="comment">// 故障模拟</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> simfailure_flags; <span class="comment">/* Failures simulation. */</span></span><br><span class="line">&#125; sentinel;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Sentinel状态中masters字段存储了当前哨兵监控的master节点的状态信息，它是一个字典，键是被监视的服务器名称，值对应的是下面的结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标记当前Redis实例的类型和状态</span></span><br><span class="line">    <span class="keyword">int</span> flags;      <span class="comment">/* See SRI_... defines */</span></span><br><span class="line">    <span class="comment">// 从哨兵看来实例的名称</span></span><br><span class="line">    <span class="keyword">char</span> *name;     <span class="comment">/* Master name from the point of view of this sentinel. */</span></span><br><span class="line">    <span class="comment">// 实例的运行ID，如果是哨兵则为其唯一ID</span></span><br><span class="line">    <span class="keyword">char</span> *runid;    <span class="comment">/* Run ID of this instance, or unique ID if is a Sentinel.*/</span></span><br><span class="line">    <span class="comment">// 用于实现故障转移，标记新纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> config_epoch;  <span class="comment">/* Configuration epoch. */</span></span><br><span class="line">    <span class="comment">// 实例地址ip和port</span></span><br><span class="line">    sentinelAddr *addr; <span class="comment">/* Master host. */</span></span><br><span class="line">    <span class="comment">// 实例的连接，可能被Sentienls共享</span></span><br><span class="line">    instanceLink *link; <span class="comment">/* Link to the instance, may be shared for Sentinels. */</span></span><br><span class="line">    <span class="comment">// 最后一次通过Pub/Sub发送hello的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> last_pub_time;   <span class="comment">/* Last time we sent hello via Pub/Sub. */</span></span><br><span class="line">    <span class="comment">// 最后一次从Sentienls收到hello的时间 </span></span><br><span class="line">    <span class="keyword">mstime_t</span> last_hello_time; <span class="comment">/* Only used if SRI_SENTINEL is set. Last time</span></span><br><span class="line"><span class="comment">                                 we received a hello from this Sentinel</span></span><br><span class="line"><span class="comment">                                 via Pub/Sub. */</span></span><br><span class="line">    <span class="comment">// 最后一次回复is-master-down命令的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> last_master_down_reply_time; <span class="comment">/* Time of last reply to</span></span><br><span class="line"><span class="comment">                                             SENTINEL is-master-down command. */</span></span><br><span class="line">    <span class="comment">// 主观下线的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> s_down_since_time; <span class="comment">/* Subjectively down since time. */</span></span><br><span class="line">    <span class="comment">// 客观下线的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> o_down_since_time; <span class="comment">/* Objectively down since time. */</span></span><br><span class="line">    <span class="comment">// 无响应多久后被判断为下线</span></span><br><span class="line">    <span class="keyword">mstime_t</span> down_after_period; <span class="comment">/* Consider it down after that period. */</span></span><br><span class="line">    <span class="comment">// 收到INFO回复的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> info_refresh;  <span class="comment">/* Time at which we received INFO output from it. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Role and the first time we observed it.</span></span><br><span class="line"><span class="comment">     * This is useful in order to delay replacing what the instance reports</span></span><br><span class="line"><span class="comment">     * with our own configuration. We need to always wait some time in order</span></span><br><span class="line"><span class="comment">     * to give a chance to the leader to report the new configuration before</span></span><br><span class="line"><span class="comment">     * we do silly things. */</span></span><br><span class="line">    <span class="comment">// 实例扮演的角色</span></span><br><span class="line">    <span class="keyword">int</span> role_reported;</span><br><span class="line">    <span class="comment">// 角色更新的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> role_reported_time;</span><br><span class="line">    <span class="comment">// 最后一次从节点的主节点地址变更的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> slave_conf_change_time; <span class="comment">/* Last time slave master addr changed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Master specific. 主节点特有属性 */</span></span><br><span class="line">    <span class="comment">// 其他监控相同主节点的Sentienls</span></span><br><span class="line">    dict *sentinels;    <span class="comment">/* Other sentinels monitoring the same master. */</span></span><br><span class="line">    <span class="comment">// 该master节点的从属节点</span></span><br><span class="line">    dict *slaves;       <span class="comment">/* Slaves for this master instance. */</span></span><br><span class="line">    <span class="comment">// 判断该主节点客观下线的投票数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quorum;<span class="comment">/* Number of sentinels that need to agree on failure. */</span></span><br><span class="line">    <span class="comment">// 故障转移时，可以同时对新的主节点进行同步的从节点数量</span></span><br><span class="line">    <span class="keyword">int</span> parallel_syncs; <span class="comment">/* How many slaves to reconfigure at same time. */</span></span><br><span class="line">    <span class="comment">// 连接主节点和从节点的认证密码</span></span><br><span class="line">    <span class="keyword">char</span> *auth_pass;    <span class="comment">/* Password to use for AUTH against master &amp; slaves. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Slave specific. 从节点特有属性 */</span></span><br><span class="line">    <span class="comment">// 从节点复制操作断开的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> master_link_down_time; <span class="comment">/* Slave replication link down time. */</span></span><br><span class="line">    <span class="comment">// 按照INFO命令输出的从节点优先级</span></span><br><span class="line">    <span class="keyword">int</span> slave_priority; <span class="comment">/* Slave priority according to its INFO output. */</span></span><br><span class="line">    <span class="comment">// 故障转移时，从节点发送SLAVEOF &lt;new&gt; 命令的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> slave_reconf_sent_time; <span class="comment">/* Time at which we sent SLAVE OF &lt;new&gt; */</span></span><br><span class="line">    <span class="comment">// 从节点保存的主节点实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> *<span class="title">master</span>;</span> <span class="comment">/* Master instance if it's slave. */</span></span><br><span class="line">    <span class="comment">// INFO命令的回复中记录的主节点host</span></span><br><span class="line">    <span class="keyword">char</span> *slave_master_host;    <span class="comment">/* Master host as reported by INFO */</span></span><br><span class="line">    <span class="comment">// INFO命令的回复中记录的主节点port</span></span><br><span class="line">    <span class="keyword">int</span> slave_master_port;      <span class="comment">/* Master port as reported by INFO */</span></span><br><span class="line">    <span class="comment">// INFO命令的回复中记录的主从服务器连接状态</span></span><br><span class="line">    <span class="keyword">int</span> slave_master_link_status; <span class="comment">/* Master link status as reported by INFO */</span></span><br><span class="line">    <span class="comment">// 从节点复制偏移量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> slave_repl_offset; <span class="comment">/* Slave replication offset. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Failover 故障转移属性 */</span></span><br><span class="line">    <span class="comment">// 如果是主节点实例，则leader保存的是只想故障转移的Sentinel的runid</span></span><br><span class="line">    <span class="comment">// 如果是哨兵实例，则leader保存的是当前哨兵选举出来的领头runid</span></span><br><span class="line">    <span class="keyword">char</span> *leader;       <span class="comment">/* If this is a master instance, this is the runid of</span></span><br><span class="line"><span class="comment">                           the Sentinel that should perform the failover. If</span></span><br><span class="line"><span class="comment">                           this is a Sentinel, this is the runid of the Sentinel</span></span><br><span class="line"><span class="comment">                           that this Sentinel voted as leader. */</span></span><br><span class="line">    <span class="comment">// leader的纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> leader_epoch; <span class="comment">/* Epoch of the 'leader' field. */</span></span><br><span class="line">    <span class="comment">// 当前执行故障转移的纪元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> failover_epoch; <span class="comment">/* Epoch of the currently started failover. */</span></span><br><span class="line">    <span class="comment">// 故障转移操作的状态</span></span><br><span class="line">    <span class="keyword">int</span> failover_state; <span class="comment">/* See SENTINEL_FAILOVER_STATE_* defines. */</span></span><br><span class="line">    <span class="comment">// 状态改变世界</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_state_change_time;</span><br><span class="line">    <span class="comment">// 最后一次尝试故障转移开始时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_start_time;   <span class="comment">/* Last failover attempt start time. */</span></span><br><span class="line">    <span class="comment">// 更新故障转移状态的最大超时时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_timeout;      <span class="comment">/* Max time to refresh failover state. */</span></span><br><span class="line">    <span class="comment">// 记录故障转移延迟的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> failover_delay_logged; <span class="comment">/* For what failover_start_time value we</span></span><br><span class="line"><span class="comment">                                       logged the failover delay. */</span></span><br><span class="line">    <span class="comment">// 晋身为新主节点的从节点实例</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sentinelRedisInstance</span> *<span class="title">promoted_slave</span>;</span> <span class="comment">/* Promoted slave instance. */</span></span><br><span class="line">    <span class="comment">/* Scripts executed to notify admin or reconfigure clients: when they</span></span><br><span class="line"><span class="comment">     * are set to NULL no script is executed. */</span></span><br><span class="line">    <span class="comment">// 通知admin的可执行脚本的地址，如果为空，则表示没有执行的脚本</span></span><br><span class="line">    <span class="keyword">char</span> *notification_script;</span><br><span class="line">    <span class="comment">// 通知配置的client的可执行脚本的地址，如果为空，则表示没有执行的脚本</span></span><br><span class="line">    <span class="keyword">char</span> *client_reconfig_script;</span><br><span class="line">    <span class="comment">// 缓存INFO命令的输出</span></span><br><span class="line">    sds info; <span class="comment">/* cached INFO output */</span></span><br><span class="line">&#125; sentinelRedisInstance;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化Sentinel最后一步会创建面向被监视主服务器的网络连接，Sentinel将成为主服务器的客户端，可以向主服务器发送命令并获取相关信息。对于每个被Sentinel监视的服务器，Sentinel会创建两个异步网络连接：</p>
<ul>
<li>命令连接：用于向主服务器发送命令，并接受回复消息</li>
<li>订阅连接：用于订阅主服务器<code>__sentinel__:hello</code>频道</li>
</ul>
</li>
</ol>
<h4 id="2-2-与服务器间的通信"><a href="#2-2-与服务器间的通信" class="headerlink" title="2.2 与服务器间的通信"></a>2.2 与服务器间的通信</h4><ol>
<li><p>获取主从服务器实例状态</p>
<p>Sentinel默认每10秒发送INFO命令给被监控的主服务器，通过INFO命令的回复获得主节点的状态数据，通过分析可获取下面信息：</p>
<ul>
<li>关于主服务器本身的信息，包括服务器运行ID，和服务器角色。</li>
<li>主服务器属下所有从服务器的信息，每个记录如<code>slave:ip=1.2.3.4,port=123,state=online</code></li>
</ul>
<p>根据这些信息，Sentinel将会对主节点的信息进行更新。</p>
<blockquote>
<p>获取从节点ip和端口后，Sentinel也会每10秒发送INFO命令来获取从节点信息。</p>
</blockquote>
<p> 当Sentinel发现主节点有新从节点加入时，Sentinel会创建该新实例的相应结构并创建命令连接和订阅连接。创建命令连接后，默认每10秒与该实例通过INFO获取一次状态信息。</p>
</li>
<li><p>向主从服务器发送信息</p>
<p>默认情况下，Sentinel每两秒通过命令连接向所有被监视的主从节点发送<code>PUBLISH __sentinel__:hello &quot;&lt;sentinel_ip&gt;,&lt;sentinel_port&gt;,&lt;sentinel_runid&gt;,&lt;current_epoch&gt;,&lt;master_name&gt;,&lt;master_ip&gt;,&lt;master_ip&gt;,&lt;master_port&gt;,&lt;master_config_epoch&gt;&quot;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sentinelSendHello</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ip[NET_IP_STR_LEN];</span><br><span class="line">    <span class="keyword">char</span> payload[NET_IP_STR_LEN+<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> retval;</span><br><span class="line">    <span class="keyword">char</span> *announce_ip;</span><br><span class="line">    <span class="keyword">int</span> announce_port;</span><br><span class="line">    <span class="comment">// 主服务器实例</span></span><br><span class="line">    sentinelRedisInstance *master = (ri-&gt;flags &amp; SRI_MASTER) ? ri : ri-&gt;master;</span><br><span class="line">    <span class="comment">// 主服务器地址</span></span><br><span class="line">    sentinelAddr *master_addr = sentinelGetCurrentMasterAddress(master);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接关闭则返回C_ERR</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use the specified announce address if specified, otherwise try to</span></span><br><span class="line"><span class="comment">     * obtain our own IP address. */</span></span><br><span class="line">    <span class="comment">// 如果Sentinel指定了announce则使用它</span></span><br><span class="line">    <span class="keyword">if</span> (sentinel.announce_ip) &#123;</span><br><span class="line">        announce_ip = sentinel.announce_ip;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (anetSockName(ri-&gt;link-&gt;cc-&gt;c.fd,ip,<span class="keyword">sizeof</span>(ip),<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        announce_ip = ip;</span><br><span class="line">    &#125;</span><br><span class="line">    announce_port = sentinel.announce_port ?</span><br><span class="line">                    sentinel.announce_port : server.port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Format and send the Hello message. */</span></span><br><span class="line">    <span class="comment">// 格式化Hello消息</span></span><br><span class="line">    <span class="built_in">snprintf</span>(payload,<span class="keyword">sizeof</span>(payload),</span><br><span class="line">        <span class="string">"%s,%d,%s,%llu,"</span> <span class="comment">/* Info about this sentinel. */</span></span><br><span class="line">        <span class="string">"%s,%s,%d,%llu"</span>, <span class="comment">/* Info about current master. */</span></span><br><span class="line">        announce_ip, announce_port, sentinel.myid,</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) sentinel.current_epoch,</span><br><span class="line">        <span class="comment">/* --- */</span></span><br><span class="line">        master-&gt;name,master_addr-&gt;ip,master_addr-&gt;port,</span><br><span class="line">        (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) master-&gt;config_epoch);</span><br><span class="line">    <span class="comment">// 异步执行命令</span></span><br><span class="line">    retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">        sentinelPublishReplyCallback, ri, <span class="string">"PUBLISH %s %s"</span>,</span><br><span class="line">            SENTINEL_HELLO_CHANNEL,payload);</span><br><span class="line">    <span class="keyword">if</span> (retval != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line">    ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收主从服务器消息</p>
<p>当Sentinel与主从服务器建立订阅连接后，就会订阅<code>__sentinel__:hello</code>频道，通过该频道获取来自服务器的消息，也就表明每个Sentinel即通过命令连接向服务器的<code>__sentinel__:hello</code>发送消息，又订阅服务器的<code>__sentinel__:hello</code>接收其消息。</p>
<p>对监视同一个服务器的多个Sentinel来说，他们会接收到来自不同Sentinel的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelProcessHelloMessage</span><span class="params">(<span class="keyword">char</span> *hello, <span class="keyword">int</span> hello_len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Format is composed of 8 tokens:</span></span><br><span class="line"><span class="comment">     * 0=ip,1=port,2=runid,3=current_epoch,4=master_name,</span></span><br><span class="line"><span class="comment">     * 5=master_ip,6=master_port,7=master_config_epoch. */</span></span><br><span class="line">    <span class="keyword">int</span> numtokens, port, removed, master_port;</span><br><span class="line">    <span class="keyword">uint64_t</span> current_epoch, master_config_epoch;</span><br><span class="line">    <span class="keyword">char</span> **token = sdssplitlen(hello, hello_len, <span class="string">","</span>, <span class="number">1</span>, &amp;numtokens);</span><br><span class="line">    sentinelRedisInstance *si, *master;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numtokens == <span class="number">8</span>) &#123;</span><br><span class="line">        <span class="comment">/* Obtain a reference to the master this hello message is about */</span></span><br><span class="line">        <span class="comment">// 获取主服务器名称，丢到未知的master数据</span></span><br><span class="line">        master = sentinelGetMasterByName(token[<span class="number">4</span>]);</span><br><span class="line">        <span class="keyword">if</span> (!master) <span class="keyword">goto</span> cleanup; <span class="comment">/* Unknown master, skip the message. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* First, try to see if we already have this sentinel. */</span></span><br><span class="line">        <span class="comment">// 获取消息内容，并转化为相应类型</span></span><br><span class="line">        port = atoi(token[<span class="number">1</span>]);</span><br><span class="line">        master_port = atoi(token[<span class="number">6</span>]);</span><br><span class="line">        si = getSentinelRedisInstanceByAddrAndRunID(</span><br><span class="line">                        master-&gt;sentinels,token[<span class="number">0</span>],port,token[<span class="number">2</span>]);</span><br><span class="line">        current_epoch = strtoull(token[<span class="number">3</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">        master_config_epoch = strtoull(token[<span class="number">7</span>],<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没在主节点的Sentinel字典中找到该Sentinel</span></span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;</span><br><span class="line">            <span class="comment">/* If not, remove all the sentinels that have the same runid</span></span><br><span class="line"><span class="comment">             * because there was an address change, and add the same Sentinel</span></span><br><span class="line"><span class="comment">             * with the new address back. */</span></span><br><span class="line">            <span class="comment">// 删除master中所有具有相同runid的Sentinel节点, 并添加具有</span></span><br><span class="line">            <span class="comment">// 新地址的同一Sentinel实例</span></span><br><span class="line">            removed = removeMatchingSentinelFromMaster(master,token[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                sentinelEvent(LL_NOTICE,<span class="string">"+sentinel-address-switch"</span>,master,</span><br><span class="line">                    <span class="string">"%@ ip %s port %d for %s"</span>, token[<span class="number">0</span>],port,token[<span class="number">2</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Check if there is another Sentinel with the same address this</span></span><br><span class="line"><span class="comment">                 * new one is reporting. What we do if this happens is to set its</span></span><br><span class="line"><span class="comment">                 * port to 0, to signal the address is invalid. We'll update it</span></span><br><span class="line"><span class="comment">                 * later if we get an HELLO message. */</span></span><br><span class="line">                <span class="comment">// 检查是否存在和Hello信息中报告地址一致的Sentinel，如果发生该情况</span></span><br><span class="line">                <span class="comment">// 我们将端口设置为0，以表示地址无效，如果过会收到HELLO消息, 我们则更新它</span></span><br><span class="line">                sentinelRedisInstance *other =</span><br><span class="line">                    getSentinelRedisInstanceByAddrAndRunID(</span><br><span class="line">                        master-&gt;sentinels, token[<span class="number">0</span>],port,<span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (other) &#123;</span><br><span class="line">                    sentinelEvent(LL_NOTICE,<span class="string">"+sentinel-invalid-addr"</span>,other,<span class="string">"%@"</span>);</span><br><span class="line">                    other-&gt;addr-&gt;port = <span class="number">0</span>; <span class="comment">/* It means: invalid address. */</span></span><br><span class="line">                    sentinelUpdateSentinelAddressInAllMasters(other);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Add the new sentinel. */</span></span><br><span class="line">            <span class="comment">// 添加一个新的Sentinel结构, 添加到master的Sentinel中</span></span><br><span class="line">            si = createSentinelRedisInstance(token[<span class="number">2</span>],SRI_SENTINEL,</span><br><span class="line">                            token[<span class="number">0</span>],port,master-&gt;quorum,master);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 添加成功</span></span><br><span class="line">            <span class="keyword">if</span> (si) &#123;</span><br><span class="line">                <span class="comment">// 若未删除之前的Sentinel，发生事件通知</span></span><br><span class="line">                <span class="keyword">if</span> (!removed) sentinelEvent(LL_NOTICE,<span class="string">"+sentinel"</span>,si,<span class="string">"%@"</span>);</span><br><span class="line">                <span class="comment">/* The runid is NULL after a new instance creation and</span></span><br><span class="line"><span class="comment">                 * for Sentinels we don't have a later chance to fill it,</span></span><br><span class="line"><span class="comment">                 * so do it now. */</span></span><br><span class="line">                <span class="comment">// 更新runid</span></span><br><span class="line">                si-&gt;runid = sdsnew(token[<span class="number">2</span>]);</span><br><span class="line">                <span class="comment">// 尝试与其他Sentinel共享连接</span></span><br><span class="line">                sentinelTryConnectionSharing(si);</span><br><span class="line">                <span class="comment">// 若已删除了Sentinel节点，更新其他的Sentinel信息</span></span><br><span class="line">                <span class="keyword">if</span> (removed) sentinelUpdateSentinelAddressInAllMasters(si);</span><br><span class="line">                <span class="comment">// 刷新配置</span></span><br><span class="line">                sentinelFlushConfig();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update local current_epoch if received current_epoch is greater.*/</span></span><br><span class="line">        <span class="comment">// 更新更改的纪元信息</span></span><br><span class="line">        <span class="keyword">if</span> (current_epoch &gt; sentinel.current_epoch) &#123;</span><br><span class="line">            sentinel.current_epoch = current_epoch;</span><br><span class="line">            sentinelFlushConfig();</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"+new-epoch"</span>,master,<span class="string">"%llu"</span>,</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) sentinel.current_epoch);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update master info if received configuration is newer. */</span></span><br><span class="line">        <span class="comment">// 更新接收到的新配置信息</span></span><br><span class="line">        <span class="keyword">if</span> (si &amp;&amp; master-&gt;config_epoch &lt; master_config_epoch) &#123;</span><br><span class="line">            master-&gt;config_epoch = master_config_epoch;</span><br><span class="line">            <span class="keyword">if</span> (master_port != master-&gt;addr-&gt;port ||</span><br><span class="line">                <span class="built_in">strcmp</span>(master-&gt;addr-&gt;ip, token[<span class="number">5</span>]))</span><br><span class="line">            &#123; sentinelAddr *old_addr;</span><br><span class="line"></span><br><span class="line">                sentinelEvent(LL_WARNING,<span class="string">"+config-update-from"</span>,si,<span class="string">"%@"</span>);</span><br><span class="line">                sentinelEvent(LL_WARNING,<span class="string">"+switch-master"</span>,</span><br><span class="line">                    master,<span class="string">"%s %s %d %s %d"</span>,</span><br><span class="line">                    master-&gt;name,</span><br><span class="line">                    master-&gt;addr-&gt;ip, master-&gt;addr-&gt;port,</span><br><span class="line">                    token[<span class="number">5</span>], master_port);</span><br><span class="line"></span><br><span class="line">                old_addr = dupSentinelAddr(master-&gt;addr);</span><br><span class="line">                sentinelResetMasterAndChangeAddress(master, token[<span class="number">5</span>], master_port);</span><br><span class="line">                sentinelCallClientReconfScript(master,</span><br><span class="line">                    SENTINEL_OBSERVER,<span class="string">"start"</span>,</span><br><span class="line">                    old_addr,master-&gt;addr);</span><br><span class="line">                releaseSentinelAddr(old_addr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update the state of the Sentinel. */</span></span><br><span class="line">        <span class="comment">// 更新最后一次接收到Sentinel的hello消息时间</span></span><br><span class="line">        <span class="keyword">if</span> (si) si-&gt;last_hello_time = mstime();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    sdsfreesplitres(token,numtokens);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-监测服务器下线状态"><a href="#3-监测服务器下线状态" class="headerlink" title="3. 监测服务器下线状态"></a>3. 监测服务器下线状态</h3><h4 id="3-1-主观下线状态"><a href="#3-1-主观下线状态" class="headerlink" title="3.1 主观下线状态"></a>3.1 主观下线状态</h4><p>默认情况下，Sentinel会每秒向所有与它建立命令连接的实例发送PING命令，并根据返回信息判断实例是否处于在线状态。接收到PING命令的回复若为<code>+PONG -LOADING -MASTERDOWN</code>则会认为是正常回复，会更新最后接收到PING命令的时间，但如果是<code>BUSY</code>则表示非正常回复。</p>
<blockquote>
<p>当Lua脚本运行的时间超过配置的Lua脚本时间限制时，Redis实例会返回-BUSY错误。在触发故障转移之前发生这种情况时，Redis Sentinel将尝试发送<a href="https://redis.io/commands/script-kill" target="_blank" rel="noopener">SCRIPT KILL</a> 命令，该命令仅在脚本为只读时才会成功。</p>
<p>如果在尝试之后实例仍然处于错误状态，则最终将进行故障转移。</p>
</blockquote>
<p>在低活跃状态下，我们需要断开命令连接和订阅连接。</p>
<p>如果主节点长时间没有回复或无效回复，或者Sentinel认为服务器时主节点，但它自己上报为从节点，那么会将该实例设置为主观下线状态。</p>
<blockquote>
<p>判断时间可以通过Sentinel的配置文件中的down-after-milliseconds参数进行修改</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelCheckSubjectivelyDown</span><span class="params">(sentinelRedisInstance *ri)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">mstime_t</span> elapsed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取距离服务器最后一次响应已经过去多长时间</span></span><br><span class="line">    <span class="comment">// 正常获取距离最后一次PING的时间，丢失连接则获取最后一次可用时间</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;act_ping_time)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;act_ping_time;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected)</span><br><span class="line">        elapsed = mstime() - ri-&gt;link-&gt;last_avail_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we are in need for a reconnection of one of the</span></span><br><span class="line"><span class="comment">     * links, because we are detecting low activity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 检查我们是否需要重新连接其中的一个链接，因为我们处于低活动状态</span></span><br><span class="line"><span class="comment">     * 1) 检查命令连接是否已连接，若连接已超过1.5s，且发送过PING命令</span></span><br><span class="line"><span class="comment">     *    但连接活跃度很低，那么久断开实例的cc命令连接</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) Check if the command link seems connected, was connected not less</span></span><br><span class="line"><span class="comment">     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have a</span></span><br><span class="line"><span class="comment">     *    pending ping for more than half the timeout. */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;cc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;cc_conn_time) &gt;</span><br><span class="line">        SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;</span><br><span class="line">        ri-&gt;link-&gt;act_ping_time != <span class="number">0</span> &amp;&amp; <span class="comment">/* Ther is a pending ping... */</span></span><br><span class="line">        <span class="comment">/* The pending ping is delayed, and we did not received</span></span><br><span class="line"><span class="comment">         * error replies as well. */</span></span><br><span class="line">        (mstime() - ri-&gt;link-&gt;act_ping_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>) &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;last_pong_time) &gt; (ri-&gt;down_after_period/<span class="number">2</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;cc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2) Check if the pubsub link seems connected, was connected not less</span></span><br><span class="line"><span class="comment">     *    than SENTINEL_MIN_LINK_RECONNECT_PERIOD, but still we have no</span></span><br><span class="line"><span class="comment">     *    activity in the Pub/Sub channel for more than</span></span><br><span class="line"><span class="comment">     *    SENTINEL_PUBLISH_PERIOD * 3.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2) 检测pc订阅连接是否也处于低活跃状态，则断开订阅连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (ri-&gt;link-&gt;pc &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_conn_time) &gt;</span><br><span class="line">         SENTINEL_MIN_LINK_RECONNECT_PERIOD &amp;&amp;</span><br><span class="line">        (mstime() - ri-&gt;link-&gt;pc_last_activity) &gt; (SENTINEL_PUBLISH_PERIOD*<span class="number">3</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        instanceLinkCloseConnection(ri-&gt;link,ri-&gt;link-&gt;pc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the SDOWN flag. We believe the instance is SDOWN if:</span></span><br><span class="line"><span class="comment">     * 更新主观下线标志，条件：</span></span><br><span class="line"><span class="comment">     * 1) 没有回复命令</span></span><br><span class="line"><span class="comment">     * 2) Sentinel认为服务器是主节点，但它自己报告的是从节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1) It is not replying.</span></span><br><span class="line"><span class="comment">     * 2) We believe it is a master, it reports to be a slave for enough time</span></span><br><span class="line"><span class="comment">     *    to meet the down_after_period, plus enough time to get two times</span></span><br><span class="line"><span class="comment">     *    INFO report from the instance. */</span></span><br><span class="line">    <span class="keyword">if</span> (elapsed &gt; ri-&gt;down_after_period ||</span><br><span class="line">        (ri-&gt;flags &amp; SRI_MASTER &amp;&amp;</span><br><span class="line">         ri-&gt;role_reported == SRI_SLAVE &amp;&amp;</span><br><span class="line">         mstime() - ri-&gt;role_reported_time &gt;</span><br><span class="line">          (ri-&gt;down_after_period+SENTINEL_INFO_PERIOD*<span class="number">2</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Is subjectively down */</span></span><br><span class="line">        <span class="comment">// 设置主观下线标识</span></span><br><span class="line">        <span class="keyword">if</span> ((ri-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 发送"+sdown"事件通知</span></span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"+sdown"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">            <span class="comment">// 记录主观下线时间和标识</span></span><br><span class="line">            ri-&gt;s_down_since_time = mstime();</span><br><span class="line">            ri-&gt;flags |= SRI_S_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Is subjectively up */</span></span><br><span class="line">        <span class="comment">// 如果设置了主观下线标识，则取消标识</span></span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"-sdown"</span>,ri,<span class="string">"%@"</span>);</span><br><span class="line">            ri-&gt;flags &amp;= ~(SRI_S_DOWN|SRI_SCRIPT_KILL_SENT);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-客观下线状态"><a href="#3-2-客观下线状态" class="headerlink" title="3.2 客观下线状态"></a>3.2 客观下线状态</h4><p>当Sentinel将一个主服务器判断为主观下线状态后，为确认是否真的下线，会与监视该主服务器的Sentinel们进行询问，以确定主服务器状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客观下线状态检测, 根据配置的投票数判断</span></span><br><span class="line"><span class="comment"> * 注意：ODOWN是一个较弱的投票，它仅表示在给定时间范围内报告的实例无法</span></span><br><span class="line"><span class="comment"> *       访问足够的Sentinel，然而，消息可以被延迟，所以并不能保证N各实例</span></span><br><span class="line"><span class="comment"> *       同时同意关闭状态。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelCheckObjectivelyDown</span><span class="params">(sentinelRedisInstance *master)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> quorum = <span class="number">0</span>, odown = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该master已经被判定为客观下线</span></span><br><span class="line">    <span class="keyword">if</span> (master-&gt;flags &amp; SRI_S_DOWN) &#123;</span><br><span class="line">        <span class="comment">/* Is down for enough sentinels? */</span></span><br><span class="line">        <span class="comment">// 投票</span></span><br><span class="line">        quorum = <span class="number">1</span>; <span class="comment">/* the current sentinel. */</span></span><br><span class="line">        <span class="comment">/* Count all the other sentinels. */</span></span><br><span class="line">        <span class="comment">// 遍历监控该节点的所有Sentinel</span></span><br><span class="line">        di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果Sentinel认为其下线，则投票数+1</span></span><br><span class="line">            <span class="keyword">if</span> (ri-&gt;flags &amp; SRI_MASTER_DOWN) quorum++;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">        <span class="comment">// 如果投票数超过设置的客观下线投票数，则客观下线</span></span><br><span class="line">        <span class="keyword">if</span> (quorum &gt;= master-&gt;quorum) odown = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the flag accordingly to the outcome. */</span></span><br><span class="line">    <span class="comment">// 设置客观下线标识</span></span><br><span class="line">    <span class="keyword">if</span> (odown) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_O_DOWN) == <span class="number">0</span>) &#123;</span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"+odown"</span>,master,<span class="string">"%@ #quorum %d/%d"</span>,</span><br><span class="line">                quorum, master-&gt;quorum);</span><br><span class="line">            master-&gt;flags |= SRI_O_DOWN;</span><br><span class="line">            master-&gt;o_down_since_time = mstime();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不用设置客观下线标识</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果已经是客观下线，的取消客观下线表示</span></span><br><span class="line">        <span class="keyword">if</span> (master-&gt;flags &amp; SRI_O_DOWN) &#123;</span><br><span class="line">            <span class="comment">// 发送"-odown"事件通知</span></span><br><span class="line">            sentinelEvent(LL_WARNING,<span class="string">"-odown"</span>,master,<span class="string">"%@"</span>);</span><br><span class="line">            master-&gt;flags &amp;= ~SRI_O_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Receive the SENTINEL is-master-down-by-addr reply, see the</span></span><br><span class="line"><span class="comment"> * sentinelAskMasterStateToOtherSentinels() function for more information. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接收Sentinel关于is-master-down-by-addr的回复</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelReceiveIsMasterDownReply</span><span class="params">(redisAsyncContext *c, <span class="keyword">void</span> *reply, <span class="keyword">void</span> *privdata)</span> </span>&#123;</span><br><span class="line">    sentinelRedisInstance *ri = privdata;</span><br><span class="line">    instanceLink *link = c-&gt;data;</span><br><span class="line">    redisReply *r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!reply || !link) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 已发送未回复命令数-1</span></span><br><span class="line">    link-&gt;pending_commands--;</span><br><span class="line">    r = reply;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ignore every error or unexpected reply.</span></span><br><span class="line"><span class="comment">     * Note that if the command returns an error for any reason we'll</span></span><br><span class="line"><span class="comment">     * end clearing the SRI_MASTER_DOWN flag for timeout anyway. */</span></span><br><span class="line">    <span class="comment">// 忽略错误回复, 注意：如果回复错误，那么需要清除SRI_MASTER_DOWN标志</span></span><br><span class="line">    <span class="keyword">if</span> (r-&gt;type == REDIS_REPLY_ARRAY &amp;&amp; r-&gt;elements == <span class="number">3</span> &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">0</span>]-&gt;type == REDIS_REPLY_INTEGER &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">1</span>]-&gt;type == REDIS_REPLY_STRING &amp;&amp;</span><br><span class="line">        r-&gt;element[<span class="number">2</span>]-&gt;type == REDIS_REPLY_INTEGER)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 最后一次回复下线时间</span></span><br><span class="line">        ri-&gt;last_master_down_reply_time = mstime();</span><br><span class="line">        <span class="comment">// 如果回复的第一个元素是1，表示同意客观下线</span></span><br><span class="line">        <span class="keyword">if</span> (r-&gt;element[<span class="number">0</span>]-&gt;integer == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 设置客观下线</span></span><br><span class="line">            ri-&gt;flags |= SRI_MASTER_DOWN;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 取消客观下线</span></span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果回复的第一个元素是"*"</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(r-&gt;element[<span class="number">1</span>]-&gt;str,<span class="string">"*"</span>)) &#123;</span><br><span class="line">            <span class="comment">/* If the runid in the reply is not "*" the Sentinel actually</span></span><br><span class="line"><span class="comment">             * replied with a vote. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放leader</span></span><br><span class="line">            sdsfree(ri-&gt;leader);</span><br><span class="line">            <span class="comment">// 打印日志</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">long</span> <span class="keyword">long</span>)ri-&gt;leader_epoch != r-&gt;element[<span class="number">2</span>]-&gt;integer)</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"%s voted for %s %llu"</span>, ri-&gt;name,</span><br><span class="line">                    r-&gt;element[<span class="number">1</span>]-&gt;str,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) r-&gt;element[<span class="number">2</span>]-&gt;integer);</span><br><span class="line">            <span class="comment">// 设置leader和其纪元</span></span><br><span class="line">            ri-&gt;leader = sdsnew(r-&gt;element[<span class="number">1</span>]-&gt;str);</span><br><span class="line">            ri-&gt;leader_epoch = r-&gt;element[<span class="number">2</span>]-&gt;integer;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* If we think the master is down, we start sending</span></span><br><span class="line"><span class="comment"> * SENTINEL IS-MASTER-DOWN-BY-ADDR requests to other sentinels</span></span><br><span class="line"><span class="comment"> * in order to get the replies that allow to reach the quorum</span></span><br><span class="line"><span class="comment"> * needed to mark the master in ODOWN state and trigger a failover. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SENTINEL_ASK_FORCED (1&lt;&lt;0)</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果Sentinel认为主节点下线，会发送一个SENTINEL IS-MASTER-DOWN-BY-ADDR给所有的Sentinel以</span></span><br><span class="line"><span class="comment"> * 获取回复，尝试获取足够多的票数，标记主节点为客观下线状态用于触发故障转移</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sentinelAskMasterStateToOtherSentinels</span><span class="params">(sentinelRedisInstance *master, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    dictIterator *di;</span><br><span class="line">    dictEntry *de;</span><br><span class="line"></span><br><span class="line">    di = dictGetIterator(master-&gt;sentinels);</span><br><span class="line">    <span class="comment">// 遍历监控master的所有Sentinel节点</span></span><br><span class="line">    <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        sentinelRedisInstance *ri = dictGetVal(de);</span><br><span class="line">        <span class="comment">// 获取距离当前Sentinel实例最后一次回复该命令所过去的时间</span></span><br><span class="line">        <span class="keyword">mstime_t</span> elapsed = mstime() - ri-&gt;last_master_down_reply_time;</span><br><span class="line">        <span class="keyword">char</span> port[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the master state from other sentinel is too old, we clear it. */</span></span><br><span class="line">        <span class="comment">// 如果master的状态太久没有更新，那么则清除</span></span><br><span class="line">        <span class="keyword">if</span> (elapsed &gt; SENTINEL_ASK_PERIOD*<span class="number">5</span>) &#123;</span><br><span class="line">            ri-&gt;flags &amp;= ~SRI_MASTER_DOWN;</span><br><span class="line">            sdsfree(ri-&gt;leader);</span><br><span class="line">            ri-&gt;leader = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Only ask if master is down to other sentinels if:</span></span><br><span class="line"><span class="comment">         * 满足以下条件则向其他Sentinel询问主节点是否下线</span></span><br><span class="line"><span class="comment">         * 1) 当前Sentinel节点认为它已经下线，并且处于故障转移状态</span></span><br><span class="line"><span class="comment">         * 2) 其他Sentinel与当前Sentinel保持连接状态</span></span><br><span class="line"><span class="comment">         * 3) 在SENTINEL_ASK_PERIOD毫秒内没有收到INFO回复</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 1) We believe it is down, or there is a failover in progress.</span></span><br><span class="line"><span class="comment">         * 2) Sentinel is connected.</span></span><br><span class="line"><span class="comment">         * 3) We did not received the info within SENTINEL_ASK_PERIOD ms. */</span></span><br><span class="line">        <span class="comment">// 主节点没有处于客观下线状态，则跳过当前Sentinel节点</span></span><br><span class="line">        <span class="keyword">if</span> ((master-&gt;flags &amp; SRI_S_DOWN) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ri-&gt;link-&gt;disconnected) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!(flags &amp; SENTINEL_ASK_FORCED) &amp;&amp;</span><br><span class="line">            mstime() - ri-&gt;last_master_down_reply_time &lt; SENTINEL_ASK_PERIOD)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Ask */</span></span><br><span class="line">        ll2string(port,<span class="keyword">sizeof</span>(port),master-&gt;addr-&gt;port);</span><br><span class="line">        <span class="comment">// 异步发送命令</span></span><br><span class="line">        retval = redisAsyncCommand(ri-&gt;link-&gt;cc,</span><br><span class="line">                    sentinelReceiveIsMasterDownReply, ri,</span><br><span class="line">                    <span class="string">"SENTINEL is-master-down-by-addr %s %s %llu %s"</span>,</span><br><span class="line">                    master-&gt;addr-&gt;ip, port,</span><br><span class="line">                    sentinel.current_epoch,</span><br><span class="line">                    (master-&gt;failover_state &gt; SENTINEL_FAILOVER_STATE_NONE) ?</span><br><span class="line">                    sentinel.myid : <span class="string">"*"</span>);</span><br><span class="line">        <span class="keyword">if</span> (retval == C_OK) ri-&gt;link-&gt;pending_commands++;</span><br><span class="line">    &#125;</span><br><span class="line">    dictReleaseIterator(di);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-Sentinel选举"><a href="#4-Sentinel选举" class="headerlink" title="4. Sentinel选举"></a>4. Sentinel选举</h3><p>当一个主服务器被判定为主观下线，监视这个服务器的所有Sentinel会协商一个leader，并由leader对主服务器进行故障转移操作，以下是leader选取的规则：</p>
<ul>
<li>所有在线Sentinel都被设置为候选人，即每个Sentinel都有资格成为leader</li>
<li>每次选举之后，所有Sentinel的纪元加1</li>
<li>在一个纪元里，每个Sentinel都有一次将某个Sentinel设置为leader的机会，并且该纪元内不能改变</li>
<li>每个发现主节点客观下线的Sentinel都会要求其他Sentinel将自己设为leader</li>
<li>当一个Sentinel向另一个Sentinel发送<code>SENTINEL is-master-down-by-addr</code>命令，且命令中runid参数不是*而是Sentinel的runid那么表示要求目标Sentinel将leader设置为它</li>
<li>Sentinel设置leader的规则就是先到先得，后来的投票请求会被拒绝</li>
<li>如果某个Sentinel获得了半数以上(50% + 1)的选票，那么它就会成为该纪元的leader</li>
<li>如果给定时间内未选出leader，那么会隔一段时间重新选举，直到leader出现</li>
</ul>
<blockquote>
<p>该算法类似Raft的一致性算法</p>
</blockquote>
<h3 id="5-故障转移"><a href="#5-故障转移" class="headerlink" title="5. 故障转移"></a>5. 故障转移</h3><p>在选择出领头Sentinel之后，由其负责对已下线的主节点进行故障转移操作：</p>
<ol>
<li><p>在已下线的主节点的从节点中选择一个并将其转换为主节点</p>
<p>选出服务器后向其发送<code>SLAVEOF no one</code>命令，将其转换为主服务器，在发送该命令后，领头Sentinel每秒向服务器发送INFO命令并观察回复信息，当其中role角色从slave转换为master时就表示成功。</p>
<blockquote>
<p>新主节点挑选原则：</p>
<p>1) 删除所有下线的服务器，保证列表中都是正常在线的</p>
<p>2) 删除列表中5秒内未回复INFO命令的服务器</p>
<p>3) 删除所有与已下线主节点断开连接超过<code>down-after-milliseconds * 10</code>的服务器</p>
<p>之后根据服务器优先级选择，若优先级相同，则选择偏移量最大的，若偏移量也相同，则选择runid最小的服务器</p>
</blockquote>
</li>
<li><p>让已下线主节点的所有从节点改为复制新的主节点</p>
</li>
<li><p>将已下线的主节点设为新主节点的从节点，当该节点重新上线时，会成为新主节点的从节点</p>
</li>
</ol>
<h3 id="6-TILT模式"><a href="#6-TILT模式" class="headerlink" title="6. TILT模式"></a>6. TILT模式</h3><p>TILT模式是一种特殊的”保护模式”，当检测到奇怪的状态，Sentinel可以进入该模式。</p>
<p>Sentinel定时器中断每秒调用10次，所以预期两次调用直接会经过100毫秒，但由于系统某些原因可能会导致大于100毫秒，如果时差为负或者大于2秒，那么则进入TILT模式。</p>
<p>在TILT模式下，Sentinel会继续监控服务器，但是：</p>
<ul>
<li>不会执行任何操作，例如故障转移</li>
<li>对<code>SENTINEL is-master-down-by-addr</code>回复负数，因为不信任故障检测功能</li>
</ul>
<p>如果TILT正常运行30秒，那么则退出该模式。</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/10/09/redis/21_复制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/09/redis/21_复制/" itemprop="url">
                  Redis源码阅读(二十一) 复制
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-10-09 16:53:45 / 修改时间：16:53:46" itemprop="dateCreated datePublished" datetime="2018-10-09T16:53:45+08:00">2018-10-09</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis为了解决单点故障的问题，会将数据复制到多个从节点服务器中，通过复制，实现Redis的高可用。</p>
<h3 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1. 介绍"></a>1. 介绍</h3><p>复制使得slave服务器能够精确复制master服务器的数据，每当slave和master连接断开时，slave会自动重连到master，并且无论这期间master做了什么操作，slave都将尝试让自身成为master的精确副本。</p>
<ul>
<li>当一个master和slave连接正常时，master会将所有的修改命令发送给slave。</li>
<li>当master和slave之间因为某些原因断开连接后，slave会重新连接到master并尝试进行部分重同步。</li>
<li>当无法进行部分同步时，slave会请求全量同步。</li>
</ul>
<p>Redis默认使用异步复制，即低延迟高性能，是绝大多Redis的自然复制模式。</p>
<p>配置Redis复制功能非常简单，只需加入下面内容到slave的配置文件即可，或在客户端中执行该命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 命令 主机ip地址 主机端口号</span><br><span class="line">slaveof 192.168.1.2 6379</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：通常完全重同步需要在磁盘上创建RDB文件，然后slave获取此RDB文件进行复制。但如果磁盘性能很低会对master造成很大压力，所以可以通过socket直接发送给slave而不存储到磁盘中。</p>
</blockquote>
<h3 id="2-工作原理"><a href="#2-工作原理" class="headerlink" title="2. 工作原理"></a>2. 工作原理</h3><p>master使用复制ID和偏移量来标识当前复制的进度，复制ID用于标记数据集，偏移量用于标识此次复制中，master将多少字节已经发送给slave。而master自己则用于一块复制缓冲区域，用于缓存master产生的复制流。</p>
<p>当slave连接到master时，使用PSYNC命令发送旧的复制ID和已经处理的偏移量。如果复制ID与master匹配，且偏移量在复制积压缓冲区以内，则进行部分重同步；但否则的话，需要进行完全重同步。</p>
<p>复制ID标记数据集的历史记录，每次实例作为master重新启动或slave提升为master都会为其生成新的复制ID。</p>
<p>Redis实例拥有两个复制ID是因为到故障发生时，slave提升为master，slave需要记住过期的复制ID，该复制ID是之前的master，这样当其他slave与新master连接时，它们可以使用旧的复制ID尝试部分重同步。</p>
<h4 id="2-1-部分重同步"><a href="#2-1-部分重同步" class="headerlink" title="2.1 部分重同步"></a>2.1 部分重同步</h4><p>主节点在复制过程中，会将命令传递给从节点的同时保存在一个叫做复制积压缓冲区backlog的区域内，当从节点重新连接到主节点，会发送自己的复制ID和偏移量，如果偏移量在主节点的缓冲区范围内，则可以进行部分重同步，只是少量的数据，而不需要全部的RDB文件。</p>
<blockquote>
<p>复制积压缓冲区backlog是一个1M大小的循环队列，用于存储主节点传递的修改数据库的命令，也是部分重同步的重要部分，从节点通过偏移量和复制积压缓冲区就可以计算出与主节点的差异，如果在缓冲区中能找到则只需进行部分重同步，而无需完整的拷贝所有RDB文件</p>
</blockquote>
<h4 id="2-2-完全重同步"><a href="#2-2-完全重同步" class="headerlink" title="2.2 完全重同步"></a>2.2 完全重同步</h4><p>由于网络或其他原因，主从节点断线，当从节点重新连接到主节点时，主节点的复制积压缓冲区已经超过了从节点的偏移，此时无法进行部分重同步。</p>
<h4 id="2-3-心跳检测"><a href="#2-3-心跳检测" class="headerlink" title="2.3 心跳检测"></a>2.3 心跳检测</h4><p>为了保持master与slave之间的连接，它们之间会不时的进行通信以保持对方的在线状态：</p>
<ul>
<li>master节点每隔10s(默认)向slave节点发送PING命令，判断从节点连接状态</li>
<li>slave节点每秒发送<code>REPLCONF ACK &lt;offset&gt;</code>命令，给主节点报告自己当前复制偏移量</li>
</ul>
<h4 id="2-4-复制积压缓冲区backlog"><a href="#2-4-复制积压缓冲区backlog" class="headerlink" title="2.4 复制积压缓冲区backlog"></a>2.4 复制积压缓冲区backlog</h4><p>复制积压缓冲区backlog是一个1M大小的循环队列，用于存储主节点传递的修改数据库的命令，也是部分重同步的重要部分，从节点通过偏移量和复制积压缓冲区就可以计算出与主节点的差异，如果在缓冲区中能找到则只需进行部分重同步，而无需完整的拷贝所有RDB文件</p>
<h3 id="3-实现"><a href="#3-实现" class="headerlink" title="3. 实现"></a>3. 实现</h3><ul>
<li><p>步骤1：设置主服务器的地址和端口</p>
<p>执行<code>SLAVEOF &lt;master_ip&gt; &lt;master_port&gt;</code></p>
</li>
<li><p>步骤2：建立socket连接</p>
</li>
<li><p>步骤3：发送PING命令</p>
</li>
<li><p>步骤4：身份验证</p>
</li>
<li><p>步骤5：发送端口信息</p>
</li>
<li><p>步骤6：同步</p>
</li>
<li><p>步骤7：命令传递</p>
</li>
</ul>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>复制周期性任务</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Replication cron function, called 1 time per second. */</span></span><br><span class="line"><span class="comment">// 复制周期函数，每秒调用一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">replicationCron</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> <span class="keyword">long</span> replication_cron_loops = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Non blocking connection timeout? */</span></span><br><span class="line">    <span class="comment">// 非阻塞连接已经超时，记录日志，并取消握手状态</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp;</span><br><span class="line">        (server.repl_state == REPL_STATE_CONNECTING ||</span><br><span class="line">         slaveIsInHandshakeState()) &amp;&amp;</span><br><span class="line">         (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Timeout connecting to the MASTER..."</span>);</span><br><span class="line">        cancelReplicationHandshake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Bulk transfer I/O timeout? */</span></span><br><span class="line">    <span class="comment">// 接收RDB文件超时，记录日志，并取消握手状态</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_TRANSFER &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.repl_transfer_lastio) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value."</span>);</span><br><span class="line">        cancelReplicationHandshake();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Timed out master when we are an already connected slave? */</span></span><br><span class="line">    <span class="comment">// 主节点每10s向从节点发送PING，从节点每1秒向主节点发送PING</span></span><br><span class="line">    <span class="comment">// 主从节点已连接，但很久未接收到PING，则超时</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state == REPL_STATE_CONNECTED &amp;&amp;</span><br><span class="line">        (time(<span class="literal">NULL</span>)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"MASTER timeout: no data nor PING received..."</span>);</span><br><span class="line">        <span class="comment">// 释放主节点</span></span><br><span class="line">        freeClient(server.master);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we should connect to a MASTER */</span></span><br><span class="line">    <span class="comment">// 尝试连接master状态</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_state == REPL_STATE_CONNECT) &#123;</span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Connecting to MASTER %s:%d"</span>,</span><br><span class="line">            server.masterhost, server.masterport);</span><br><span class="line">        <span class="comment">// 连接master</span></span><br><span class="line">        <span class="keyword">if</span> (connectWithMaster() == C_OK) &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"MASTER &lt;-&gt; SLAVE sync started"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send ACK to master from time to time.</span></span><br><span class="line"><span class="comment">     * Note that we do not send periodic acks to masters that don't</span></span><br><span class="line"><span class="comment">     * support PSYNC and replication offsets. */</span></span><br><span class="line">    <span class="comment">// 发送ACK给主节点</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.master &amp;&amp;</span><br><span class="line">        !(server.master-&gt;flags &amp; CLIENT_PRE_PSYNC))</span><br><span class="line">        replicationSendAck();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we have attached slaves, PING them from time to time.</span></span><br><span class="line"><span class="comment">     * So slaves can implement an explicit timeout to masters, and will</span></span><br><span class="line"><span class="comment">     * be able to detect a link disconnection even if the TCP connection</span></span><br><span class="line"><span class="comment">     * will not actually go down. */</span></span><br><span class="line">    <span class="comment">// 如果服务器有从节点，定期发送PING</span></span><br><span class="line">    listIter li;</span><br><span class="line">    listNode *ln;</span><br><span class="line">    robj *ping_argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First, send PING according to ping_slave_period. */</span></span><br><span class="line">    <span class="comment">// 首先, 根据配置的server.repl_ping_slave_period判断是否发送ACK，默认10秒主节点PING从节点</span></span><br><span class="line">    <span class="keyword">if</span> ((replication_cron_loops % server.repl_ping_slave_period) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        listLength(server.slaves))</span><br><span class="line">    &#123;</span><br><span class="line">        ping_argv[<span class="number">0</span>] = createStringObject(<span class="string">"PING"</span>,<span class="number">4</span>);</span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb,</span><br><span class="line">            ping_argv, <span class="number">1</span>);</span><br><span class="line">        decrRefCount(ping_argv[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Second, send a newline to all the slaves in pre-synchronization</span></span><br><span class="line"><span class="comment">     * stage, that is, slaves waiting for the master to create the RDB file.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Also send the a newline to all the chained slaves we have, if we lost</span></span><br><span class="line"><span class="comment">     * connection from our master, to keep the slaves aware that their</span></span><br><span class="line"><span class="comment">     * master is online. This is needed since sub-slaves only receive proxied</span></span><br><span class="line"><span class="comment">     * data from top-level masters, so there is no explicit pinging in order</span></span><br><span class="line"><span class="comment">     * to avoid altering the replication offsets. This special out of band</span></span><br><span class="line"><span class="comment">     * pings (newlines) can be sent, they will have no effect in the offset.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * The newline will be ignored by the slave but will refresh the</span></span><br><span class="line"><span class="comment">     * last interaction timer preventing a timeout. In this case we ignore the</span></span><br><span class="line"><span class="comment">     * ping period and refresh the connection once per second since certain</span></span><br><span class="line"><span class="comment">     * timeouts are set at a few seconds (example: PSYNC response). */</span></span><br><span class="line">    <span class="comment">// 其次，发送一个换行符'\n'给所有准备同步：等待master创建RDB文件的从节点</span></span><br><span class="line">    <span class="comment">// 发送该换行符是为了确保slave知道他们的master在线，这样对偏移量也没有影响</span></span><br><span class="line">    <span class="comment">// 从节点会忽略该换行符，但会刷新最后一次交互时间，这种情况下，我们忽略ping周期并每秒刷新</span></span><br><span class="line">    <span class="comment">// 一次连接, 因为某些超时设置为几秒</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有从节点</span></span><br><span class="line">    listRewind(server.slaves,&amp;li);</span><br><span class="line">    <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">        client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从节点的复制状态处于等待主节点创建RDB文件状态, 则发送一个'\n'用于ping</span></span><br><span class="line">        <span class="keyword">int</span> is_presync =</span><br><span class="line">            (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START ||</span><br><span class="line">            (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END &amp;&amp;</span><br><span class="line">             server.rdb_child_type != RDB_CHILD_TYPE_SOCKET));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (is_presync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (write(slave-&gt;fd, <span class="string">"\n"</span>, <span class="number">1</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">/* Don't worry about socket errors, it's just a ping. */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Disconnect timedout slaves. */</span></span><br><span class="line">    <span class="comment">// 断开超时的从节点</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves)) &#123;</span><br><span class="line">        listIter li;</span><br><span class="line">        listNode *ln;</span><br><span class="line"></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳过未完成RDB文件传输的节点</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate != SLAVE_STATE_ONLINE) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;flags &amp; CLIENT_PRE_PSYNC) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_WARNING, <span class="string">"Disconnecting timedout slave: %s"</span>,</span><br><span class="line">                    replicationGetSlaveName(slave));</span><br><span class="line">                freeClient(slave);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this is a master without attached slaves and there is a replication</span></span><br><span class="line"><span class="comment">     * backlog active, in order to reclaim memory we can free it after some</span></span><br><span class="line"><span class="comment">     * (configured) time. Note that this cannot be done for slaves: slaves</span></span><br><span class="line"><span class="comment">     * without sub-slaves attached should still accumulate data into the</span></span><br><span class="line"><span class="comment">     * backlog, in order to reply to PSYNC queries if they are turned into</span></span><br><span class="line"><span class="comment">     * masters after a failover. */</span></span><br><span class="line">    <span class="comment">// 如果该主节点已经没有从节点，并且复制积压缓冲区存在，为了回收内存，</span></span><br><span class="line">    <span class="comment">// 我们可以在一段时间(可配置)之后释放它。</span></span><br><span class="line">    <span class="comment">// 注意：从节点无法执行该操作：没有附加从节点的从节点仍将数据累积下来，以便</span></span><br><span class="line">    <span class="comment">// 故障转移后将其转换为master时回复PSYNC</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp; server.repl_backlog_time_limit &amp;&amp;</span><br><span class="line">        server.repl_backlog &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算没有从节点开始有多久了</span></span><br><span class="line">        <span class="keyword">time_t</span> idle = server.unixtime - server.repl_no_slaves_since;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 超过设定的限制，则释放积压缓冲区backlong</span></span><br><span class="line">        <span class="keyword">if</span> (idle &gt; server.repl_backlog_time_limit) &#123;</span><br><span class="line">            <span class="comment">/* When we free the backlog, we always use a new</span></span><br><span class="line"><span class="comment">             * replication ID and clear the ID2. This is needed</span></span><br><span class="line"><span class="comment">             * because when there is no backlog, the master_repl_offset</span></span><br><span class="line"><span class="comment">             * is not updated, but we would still retain our replication</span></span><br><span class="line"><span class="comment">             * ID, leading to the following problem:</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 1. We are a master instance.</span></span><br><span class="line"><span class="comment">             * 2. Our slave is promoted to master. It's repl-id-2 will</span></span><br><span class="line"><span class="comment">             *    be the same as our repl-id.</span></span><br><span class="line"><span class="comment">             * 3. We, yet as master, receive some updates, that will not</span></span><br><span class="line"><span class="comment">             *    increment the master_repl_offset.</span></span><br><span class="line"><span class="comment">             * 4. Later we are turned into a slave, connecto to the new</span></span><br><span class="line"><span class="comment">             *    master that will accept our PSYNC request by second</span></span><br><span class="line"><span class="comment">             *    replication ID, but there will be data inconsistency</span></span><br><span class="line"><span class="comment">             *    because we received writes. */</span></span><br><span class="line">            changeReplicationId();</span><br><span class="line">            clearReplicationId2();</span><br><span class="line">            freeReplicationBacklog();</span><br><span class="line">            serverLog(LL_NOTICE,</span><br><span class="line">                <span class="string">"Replication backlog freed after %d seconds "</span></span><br><span class="line">                <span class="string">"without connected slaves."</span>,</span><br><span class="line">                (<span class="keyword">int</span>) server.repl_backlog_time_limit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If AOF is disabled and we no longer have attached slaves, we can</span></span><br><span class="line"><span class="comment">     * free our Replication Script Cache as there is no need to propagate</span></span><br><span class="line"><span class="comment">     * EVALSHA at all. */</span></span><br><span class="line">    <span class="comment">// 如果AOF关闭，且没有从节点，我们就释放复制脚本缓存，因为没有传递EVALSHA的必要</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.aof_state == AOF_OFF &amp;&amp;</span><br><span class="line">        listLength(server.repl_scriptcache_fifo) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start a BGSAVE good for replication if we have slaves in</span></span><br><span class="line"><span class="comment">     * WAIT_BGSAVE_START state.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * In case of diskless replication, we make sure to wait the specified</span></span><br><span class="line"><span class="comment">     * number of seconds (according to configuration) so that other slaves</span></span><br><span class="line"><span class="comment">     * have the time to arrive before we start streaming. */</span></span><br><span class="line">    <span class="comment">// 如果从节点处于WAIT_BGSAVE_START状态，则为了复制操作开始执行一个BGSAVE</span></span><br><span class="line">    <span class="comment">// 无盘复制情况下，等待指定秒数(可配置)，以确保其他从节点有时间在我们开始流式传输之前到达</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">time_t</span> idle, max_idle = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> slaves_waiting = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mincapa = <span class="number">-1</span>;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历所有从节点</span></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            client *slave = ln-&gt;value;</span><br><span class="line">            <span class="comment">// 如果从节点复制状态为等待BGSAVE开始</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_START) &#123;</span><br><span class="line">                <span class="comment">// 计算距离上一次交互时间差</span></span><br><span class="line">                idle = server.unixtime - slave-&gt;lastinteraction;</span><br><span class="line">                <span class="comment">// 记录最大空余时间</span></span><br><span class="line">                <span class="keyword">if</span> (idle &gt; max_idle) max_idle = idle;</span><br><span class="line">                <span class="comment">// 记录等待BGSAVE的节点数量</span></span><br><span class="line">                slaves_waiting++;</span><br><span class="line">                mincapa = (mincapa == <span class="number">-1</span>) ? slave-&gt;slave_capa :</span><br><span class="line">                                            (mincapa &amp; slave-&gt;slave_capa);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断是否需要执行BGSAVE，BGSAVE会根据mincapa将RDB文件写到磁盘或socket</span></span><br><span class="line">        <span class="keyword">if</span> (slaves_waiting &amp;&amp;</span><br><span class="line">            (!server.repl_diskless_sync ||</span><br><span class="line">             max_idle &gt; server.repl_diskless_sync_delay))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Start the BGSAVE. The called function may start a</span></span><br><span class="line"><span class="comment">             * BGSAVE with socket target or disk target depending on the</span></span><br><span class="line"><span class="comment">             * configuration and slaves capabilities. */</span></span><br><span class="line">            startBgsaveForReplication(mincapa);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refresh the number of slaves with lag &lt;= min-slaves-max-lag. */</span></span><br><span class="line">    <span class="comment">// 更新延迟lag小于 min-slaves-max-lag的从节点数量</span></span><br><span class="line">    refreshGoodSlavesCount();</span><br><span class="line">    <span class="comment">// 更新cron函数执行次数</span></span><br><span class="line">    replication_cron_loops++; <span class="comment">/* Incremented with frequency 1 HZ. */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>SYNC和PSYNC命令</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SYNC和PSYNC命令实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syncCommand</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ignore SYNC if already slave or in monitor mode */</span></span><br><span class="line">    <span class="comment">// 从节点忽略同步命令</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Refuse SYNC requests if we are a slave but the link with our master</span></span><br><span class="line"><span class="comment">     * is not ok... */</span></span><br><span class="line">    <span class="comment">// 从节点未与主节点连接，则发送错误回复</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost &amp;&amp; server.repl_state != REPL_STATE_CONNECTED) &#123;</span><br><span class="line">        addReplySds(c,sdsnew(<span class="string">"-NOMASTERLINK Can't SYNC while not connected with my master\r\n"</span>));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* SYNC can't be issued when the server has pending data to send to</span></span><br><span class="line"><span class="comment">     * the client about already issued commands. We need a fresh reply</span></span><br><span class="line"><span class="comment">     * buffer registering the differences between the BGSAVE and the current</span></span><br><span class="line"><span class="comment">     * dataset, so that we can copy to other slaves if needed. */</span></span><br><span class="line">    <span class="comment">// 如果指定的客户端回复缓冲区中海油数据，则不能执行同步</span></span><br><span class="line">    <span class="keyword">if</span> (clientHasPendingReplies(c)) &#123;</span><br><span class="line">        addReplyError(c,<span class="string">"SYNC and PSYNC are invalid with pending output"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    serverLog(LL_NOTICE,<span class="string">"Slave %s asks for synchronization"</span>,</span><br><span class="line">        replicationGetSlaveName(c));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try a partial resynchronization if this is a PSYNC command.</span></span><br><span class="line"><span class="comment">     * If it fails, we continue with usual full resynchronization, however</span></span><br><span class="line"><span class="comment">     * when this happens masterTryPartialResynchronization() already</span></span><br><span class="line"><span class="comment">     * replied with:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * +FULLRESYNC &lt;replid&gt; &lt;offset&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * So the slave knows the new replid and offset to try a PSYNC later</span></span><br><span class="line"><span class="comment">     * if the connection with the master is lost. */</span></span><br><span class="line">    <span class="comment">// 尝试执行部分同步命令，回复"+FULLRESYNC &lt;replid&gt; &lt;offset&gt;", 失败则执行全量同步，</span></span><br><span class="line">    <span class="keyword">if</span> (!strcasecmp(c-&gt;argv[<span class="number">0</span>]-&gt;ptr,<span class="string">"psync"</span>)) &#123;</span><br><span class="line">        <span class="comment">// 主节点尝试执行部分重同步</span></span><br><span class="line">        <span class="keyword">if</span> (masterTryPartialResynchronization(c) == C_OK) &#123;</span><br><span class="line">            <span class="comment">// 可执行PSYNC命令，计数+1</span></span><br><span class="line">            server.stat_sync_partial_ok++;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* No full resync needed, return. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不能执行PSYNC，则全量同步</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> *master_replid = c-&gt;argv[<span class="number">1</span>]-&gt;ptr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Increment stats for failed PSYNCs, but only if the</span></span><br><span class="line"><span class="comment">             * replid is not "?", as this is used by slaves to force a full</span></span><br><span class="line"><span class="comment">             * resync on purpose when they are not albe to partially</span></span><br><span class="line"><span class="comment">             * resync. */</span></span><br><span class="line">            <span class="comment">// 记录psync失败次数</span></span><br><span class="line">            <span class="keyword">if</span> (master_replid[<span class="number">0</span>] != <span class="string">'?'</span>) server.stat_sync_partial_err++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If a slave uses SYNC, we are dealing with an old implementation</span></span><br><span class="line"><span class="comment">         * of the replication protocol (like redis-cli --slave). Flag the client</span></span><br><span class="line"><span class="comment">         * so that we don't expect to receive replicationSendAck ACK feedbacks. */</span></span><br><span class="line">        c-&gt;flags |= CLIENT_PRE_PSYNC;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Full resynchronization. */</span></span><br><span class="line">    <span class="comment">// 全量同步计数</span></span><br><span class="line">    server.stat_sync_full++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Setup the slave as one waiting for BGSAVE to start. The following code</span></span><br><span class="line"><span class="comment">     * paths will change the state if we handle the slave differently. */</span></span><br><span class="line">    <span class="comment">// 客户端状态为从节点服务器等待BGSAVE开始</span></span><br><span class="line">    c-&gt;replstate = SLAVE_STATE_WAIT_BGSAVE_START;</span><br><span class="line">    <span class="comment">// 执行SYNC命令后，是否关闭TCP_NODELAY</span></span><br><span class="line">    <span class="keyword">if</span> (server.repl_disable_tcp_nodelay)</span><br><span class="line">        anetDisableTcpNoDelay(<span class="literal">NULL</span>, c-&gt;fd); <span class="comment">/* Non critical if it fails. */</span></span><br><span class="line">    c-&gt;repldbfd = <span class="number">-1</span>;</span><br><span class="line">    c-&gt;flags |= CLIENT_SLAVE;</span><br><span class="line">    listAddNodeTail(server.slaves,c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Create the replication backlog if needed. */</span></span><br><span class="line">    <span class="comment">// 根据需要创建一个backlog缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.slaves) == <span class="number">1</span> &amp;&amp; server.repl_backlog == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* When we create the backlog from scratch, we always use a new</span></span><br><span class="line"><span class="comment">         * replication ID and clear the ID2, since there is no valid</span></span><br><span class="line"><span class="comment">         * past history. */</span></span><br><span class="line">        changeReplicationId();</span><br><span class="line">        clearReplicationId2();</span><br><span class="line">        createReplicationBacklog();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 1: BGSAVE is in progress, with disk target. */</span></span><br><span class="line">    <span class="comment">// 情况1：BGSAVE正在执行，同步到磁盘</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        server.rdb_child_type == RDB_CHILD_TYPE_DISK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Ok a background save is in progress. Let's check if it is a good</span></span><br><span class="line"><span class="comment">         * one for replication, i.e. if there is another slave that is</span></span><br><span class="line"><span class="comment">         * registering differences since the server forked to save. */</span></span><br><span class="line">        client *slave;</span><br><span class="line">        listNode *ln;</span><br><span class="line">        listIter li;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历从节点链表</span></span><br><span class="line">        listRewind(server.slaves,&amp;li);</span><br><span class="line">        <span class="keyword">while</span>((ln = listNext(&amp;li))) &#123;</span><br><span class="line">            slave = ln-&gt;value;</span><br><span class="line">            <span class="comment">// 从节点等待BGSAVE结束</span></span><br><span class="line">            <span class="keyword">if</span> (slave-&gt;replstate == SLAVE_STATE_WAIT_BGSAVE_END) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* To attach this slave, we check that it has at least all the</span></span><br><span class="line"><span class="comment">         * capabilities of the slave that triggered the current BGSAVE. */</span></span><br><span class="line">        <span class="comment">// 对与该节点，检测它是否具有触发当前BGSAVE操作的能力</span></span><br><span class="line">        <span class="keyword">if</span> (ln &amp;&amp; ((c-&gt;slave_capa &amp; slave-&gt;slave_capa) == slave-&gt;slave_capa)) &#123;</span><br><span class="line">            <span class="comment">/* Perfect, the server is already registering differences for</span></span><br><span class="line"><span class="comment">             * another slave. Set the right state, and copy the buffer. */</span></span><br><span class="line">            <span class="comment">// 将从节点输出缓冲区内容拷贝到客户端输出缓冲区</span></span><br><span class="line">            copyClientOutputBuffer(c,slave);</span><br><span class="line">            <span class="comment">// 设置全量同步状态，和部分重同步偏移量</span></span><br><span class="line">            replicationSetupSlaveForFullResync(c,slave-&gt;psync_initial_offset);</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Waiting for end of BGSAVE for SYNC"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* No way, we need to wait for the next BGSAVE in order to</span></span><br><span class="line"><span class="comment">             * register differences. */</span></span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Can't attach the slave to the current BGSAVE. Waiting for next BGSAVE for SYNC"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 2: BGSAVE is in progress, with socket target. */</span></span><br><span class="line">    <span class="comment">// 情况2： BGSAVE正在执行，同步到socket</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> &amp;&amp;</span><br><span class="line">               server.rdb_child_type == RDB_CHILD_TYPE_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* There is an RDB child process but it is writing directly to</span></span><br><span class="line"><span class="comment">         * children sockets. We need to wait for the next BGSAVE</span></span><br><span class="line"><span class="comment">         * in order to synchronize. */</span></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Current BGSAVE has socket target. Waiting for next BGSAVE for SYNC"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CASE 3: There is no BGSAVE is progress. */</span></span><br><span class="line">    <span class="comment">// 情况3：BGSAVE没有执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.repl_diskless_sync &amp;&amp; (c-&gt;slave_capa &amp; SLAVE_CAPA_EOF)) &#123;</span><br><span class="line">            <span class="comment">/* Diskless replication RDB child is created inside</span></span><br><span class="line"><span class="comment">             * replicationCron() since we want to delay its start a</span></span><br><span class="line"><span class="comment">             * few seconds to wait for more slaves to arrive. */</span></span><br><span class="line">            <span class="comment">// 无盘同步的子进程在replicationCron()中创建</span></span><br><span class="line">            <span class="keyword">if</span> (server.repl_diskless_sync_delay)</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"Delay next BGSAVE for diskless SYNC"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Target is disk (or the slave is not capable of supporting</span></span><br><span class="line"><span class="comment">             * diskless replication) and we don't have a BGSAVE in progress,</span></span><br><span class="line"><span class="comment">             * let's start one. */</span></span><br><span class="line">            <span class="comment">// 没有进行BGSAVE并且没有AOF，则开始为复制执行BGSAVE</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_child_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                startBgsaveForReplication(c-&gt;slave_capa);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">"No BGSAVE in progress, but an AOF rewrite is active. "</span></span><br><span class="line">                    <span class="string">"BGSAVE for replication delayed"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/26/course/6.828/Lab1.Booting a PC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/26/course/6.828/Lab1.Booting a PC/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-26 13:10:59" itemprop="dateCreated datePublished" datetime="2018-09-26T13:10:59+08:00">2018-09-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-31 17:12:00" itemprop="dateModified" datetime="2018-10-31T17:12:00+08:00">2018-10-31</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Lab-1-Boot-a-PC"><a href="#Lab-1-Boot-a-PC" class="headerlink" title="Lab 1: Boot a PC"></a>Lab 1: Boot a PC</h1><p>实验分为三部分，第一部分重点介绍如何熟悉x86汇编语言，QEMUx86模拟器和PC引导程序；第二部分检查6.828内核的引导加载程序；第三部分研究6.828内核本身的初始内容。</p>
<p>JOS是mit为了教学操作系统而开发的精简版类UNIX系统，使用<code>git clone https://pdos.csail.mit.edu/6.828/2018/jos.git lab</code>来获取源码。</p>
<h2 id="I-·-PC-Bootstrap"><a href="#I-·-PC-Bootstrap" class="headerlink" title="I · PC Bootstrap"></a>I · PC Bootstrap</h2><p>该部分练习是用来介绍x86汇编语言和PC引导程序，开始使用QEMU/GDB调试。</p>
<h3 id="1-PC的物理地址分配"><a href="#1-PC的物理地址分配" class="headerlink" title="1. PC的物理地址分配"></a>1. PC的物理地址分配</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">+------------------+  &lt;- 0xFFFFFFFF (4GB)</span><br><span class="line">|      32-bit      |</span><br><span class="line">|  memory mapped   |</span><br><span class="line">|     devices      |</span><br><span class="line">|                  |</span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line"></span><br><span class="line">/\/\/\/\/\/\/\/\/\/\</span><br><span class="line">|                  |</span><br><span class="line">|      Unused      |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- depends on amount of RAM</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">| Extended Memory  |</span><br><span class="line">|                  |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00100000 (1MB)</span><br><span class="line">|     BIOS ROM     |</span><br><span class="line">+------------------+  &lt;- 0x000F0000 (960KB)</span><br><span class="line">|  16-bit devices, |</span><br><span class="line">|  expansion ROMs  |</span><br><span class="line">+------------------+  &lt;- 0x000C0000 (768KB)</span><br><span class="line">|   VGA Display    |</span><br><span class="line">+------------------+  &lt;- 0x000A0000 (640KB)</span><br><span class="line">|                  |</span><br><span class="line">|    Low Memory    |</span><br><span class="line">|                  |</span><br><span class="line">+------------------+  &lt;- 0x00000000</span><br></pre></td></tr></table></figure>
<p>早期16位8088处理器PC只能处理1MB的物理内存，所以地址空间为0x00000000~0x000FFFFF。而Low Memory区域的640KB是早期PC可以使用的唯一随机存储器RAM。实际上，最早的PC只能配置16KB, 32KB或64KB的RAM.</p>
<p>从0x000A0000到0x000FFFFF的384KB的区域由硬件保留用于特殊用途，如视频显示缓冲区和非易失性存储器中保存的固件。该保留区内最重要的就是基本输入/输出系统（BIOS），它占用0x000F0000到0x000FFFFF的64KB区域。早期PC中，BIOS保存在真正的ROM中，但当前的PC将BIOS存储在可更新的闪存中。BIOS负责基本系统初始化，如激活显卡和检查内存。执行完初始化后，BIOS从某些位置(软盘、硬盘、CD-ROM或网络)加载操作系统，并将机器的控制权限交给操作系统。</p>
<blockquote>
<p>当Intel设计突破1MB限制的处理器时，PC架构师仍然保留了原有低1MB物理地址空间布局，以向后兼容。</p>
<p>PC的32位物理地址顶部一些空间，通常由BIOS保留，供32位PCI设备使用。</p>
</blockquote>
<h3 id="2-ROM-BIOS"><a href="#2-ROM-BIOS" class="headerlink" title="2. ROM BIOS"></a>2. ROM BIOS</h3><p>该部分实验将使用QEMU的调试工具来研究IA-32兼容计算机的启动方式。</p>
<p>打开两个终端，第一个输入make qemu-gdb，启动QEMU但会停止在第一条命令之前，并等待来自GDB的调试链接。第二个终端中输入make gdb，则有一下显示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gdb -n -x .gdbinit</span><br><span class="line">GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">The target architecture is assumed to be i8086</span><br><span class="line">[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b</span><br><span class="line">0x0000fff0 in ?? ()</span><br><span class="line">+ symbol-file obj/kern/kernel</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>源码中提供了.gdbinit文件，该文件设置GDB以调试早期启动间使用的16位代码，并将其指向到监听QEMU</p>
</blockquote>
<p><code>[f000：fff0] 0xffff0:    ljmp   $0xf000,$0xe05b</code></p>
<p>该条命令是GDB要执行的第一条命令的反汇编，我们可以得出以下结论：</p>
<ul>
<li>IBM PC在物理地址<code>0x000ffff0</code>处开始执行，该地址位于ROM BIOS保留的64KB的最顶端。</li>
<li>PC开始执行 <code>CS: 0xf000 IP: 0xfff0</code>  </li>
<li>执行的第一条指令为<code>ljmp</code>，跳转到<code>CS: 0xf000, IP:0xe05b</code>处</li>
</ul>
<blockquote>
<p>由于PC中的BIOS与物理地址范围0x000f0000-0x000fffff存在”硬连线”，因此可确保BIOS在启动后最先被加载</p>
</blockquote>
<p>当BIOS运行时，会设置一个中断描述符表并初始化各种设备，如VGA显示器，当初始化PCI总线和一些重要设备之后，BIOS会搜索可引导设备，如floppy、hard drive、CD-ROM，最终找到可引导盘，BIOS会从磁盘读取boot loader并把控制权交给它。</p>
<h3 id="3-引导加载程序-boot-loader"><a href="#3-引导加载程序-boot-loader" class="headerlink" title="3. 引导加载程序 boot loader"></a>3. 引导加载程序 boot loader</h3><p>PC的软盘和硬盘被分为512字节的区域，称之为扇区，扇区是磁盘的最小传输粒度：每个读写操作都必须是一个或多个扇区，并在扇区边界上对齐。如果磁盘是可引导的，那么第一个扇区称之为<strong>引导扇区</strong>，该位置存放了引导加载程序的代码。</p>
<p>当BIOS找到可引导磁盘后，将512字节的引导扇区加载到物理地址<code>0x7c00~0x7dff</code>的内存中，然后使用<code>jmp</code>指令将<code>cs:ip</code>设置为<code>0000:7c00</code>，将控制权交给引导程序。</p>
<blockquote>
<p>PC发展过程中，从CD-ROM启动要晚很多，所以PC架构师重新规划了启动过程，现代BIOS从CD-ROM启动的引导扇区是2048字节。</p>
</blockquote>
<p>JOS中引导加载程序有boot/boot.S和boot/main.c组成，它们必须完成以下任务：</p>
<ul>
<li>将处理器从实模式切换到32位保护模式，因为只有在保护模式下，才能访问物理地址空间1MB以上的区域。</li>
<li>通过x86的特殊I/O指令直接访问IDE磁盘设备寄存器，从硬盘读取内核。</li>
</ul>
<h4 id="3-1-汇编部分boot-S"><a href="#3-1-汇编部分boot-S" class="headerlink" title="3.1 汇编部分boot.S"></a>3.1 汇编部分boot.S</h4><p>引导加载程序的第一条指令是<code>cli</code>屏蔽处理器中断，BIOS是一个小型操作系统，它拥有自己的中断处理程序，但现在已经将控制权交给了引导程序，所以需要进行中断屏蔽，以防BIOS触发中断防止引导加载程序的运行，当准备好后，会重新开启中断。</p>
<p>早期PC中，地址总线20位，寄存器16位，为了进行20位寻址，则通过<code>段选择子:偏移(segment:offset)</code>的方式进行，即<code>segment * 16 + offset</code>得到20位地址，该地址被称之为<strong>逻辑地址</strong>，在一般情况下分段硬件会处理该情况的到一个线性地址，如果开启的分页功能，那么会将线性地址翻译为物理地址，否则处理器直接将线性地址当作物理地址使用。</p>
<blockquote>
<p>虚拟地址<code>segment:offset</code>的方式可能产生21位地址，但8088只能传递20位地址，所以它截断了地址的最高位。早期软件忽略21位来解决该问题，但当CPU寻址超过20位时候就出现了问题，所以IBM给出了一个方案：如果键盘控制器输出端口第2位是低位，则物理地址第21位被清零，否则可正常使用。</p>
<p>0x60是键盘控制器命令端口，0x64是键盘控制器数据端口。</p>
</blockquote>
<p>随着技术的发展，内存大小很快就超过65535字节，这时候实模式的20位寻址就过于窘迫，x86处理器在80286之后就有了<strong>保护模式</strong>，保护模式下寻址到达32位，可以寻址4G的内存范围。</p>
<p>在保护模式下，段寄存器保存着段描述符表的索引，段描述符表中每一个表项都指定一个基物理地址，最大虚拟地址（限制），和该段的权限位，在保护模式下权限位起到保护作用，内核可以根据它们来保证一个程序只使用属于自己的地址空间。</p>
<p>引导加载程序将段描述符表gdt中的每个段基址置零，让所有段具有相同的内存限制4G。我们gdt有3个表项，一个空指针表项、一个可执行代码表项、一个数据表项，代码表项中的标志位表明代码只能在32位模式下运行。</p>
<p>引导加载程序执行<code>lgdt gdtdesc</code>将全局描述符表加载到寄存器，加载完成后将<code>CR0_PE</code>置1从而开启保护模式。允许保护模式不会马上让CPU把逻辑地址翻译为物理地址，只有当某个段寄存器加载了一个新值，并且CPU通过这个值读取到GDT的一项从而改变了内部的段设置。</p>
<p>32位模式下，引导加载程序使用<code>PROT_MODE_DSEG</code>数据段选择子初始化数据段寄存器，逻辑地址直接映射到物理地址。运行C代码前建立一个栈空间，内存<code>0xa0000 ~ 0x100000</code>属于设备区，内核则位于<code>0x100000</code>处，引导加载程序自己位于<code>0x7c00 ~ 0x7d00</code>，选择0x7c00作为栈顶，向下生长直到0x0000。</p>
<p>最后引导加载程序调用C函数bootmain，其工作为加载并运行内核。</p>
<h4 id="3-2-C代码部分main-c"><a href="#3-2-C代码部分main-c" class="headerlink" title="3.2 C代码部分main.c"></a>3.2 C代码部分main.c</h4><p>bootmain的目的是在磁盘的第二个扇区开头找到内核程序，内核是ELF格式的二进制文件。bootmain读取ELF文件的前4096字节(ELF头部长度)拷贝到内存0x10000处，并判断是否是合法ELF文件，然后读取内核的内容并加载到p_addr物理地址处，调用entry进入内核。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ELF文件由ELF头和数据部分(程序表头+段表头+数据域)组成</span><br><span class="line">- ELF头</span><br><span class="line">  - e_entry	开始执行入口地址</span><br><span class="line">  - e_phoff   程序表头开始地址</span><br><span class="line">  - e_shoff    段表头开始地址</span><br><span class="line">  - e_phentsize  程序表头表项大小</span><br><span class="line">  - e_phnum  程序表头表项数</span><br><span class="line">  - e_shentsize  段表头表项大小</span><br><span class="line">  - e_shnum  段表头表项数</span><br><span class="line">- 数据部分</span><br><span class="line">  - program header table程序表头</span><br><span class="line">    p_offset  段中偏移量</span><br><span class="line">    p_vaddr  内存中段的虚拟地址</span><br><span class="line">    P_paddr  物理地址</span><br><span class="line">    p_filesz   image文件中段大小</span><br><span class="line">    p_memsz  内存中段大小</span><br><span class="line">  - section header table 段表头</span><br><span class="line">  - data <span class="keyword">for</span> ph <span class="keyword">and</span> sh 数据域</span><br></pre></td></tr></table></figure>
<h3 id="4-内核"><a href="#4-内核" class="headerlink" title="4. 内核"></a>4. 内核</h3>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/25/course/6.828/A.实验准备/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/course/6.828/A.实验准备/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-25 17:24:58" itemprop="dateCreated datePublished" datetime="2018-09-25T17:24:58+08:00">2018-09-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2018-10-25 17:18:36" itemprop="dateModified" datetime="2018-10-25T17:18:36+08:00">2018-10-25</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h1><p>在6.828实验中，我们需要两个重要的工具集合：QEMU用于运行内核；编译工具链用于源码的编译链接。</p>
<blockquote>
<p>系统选择ubuntu-16.04.5-desktop-i386</p>
</blockquote>
<h2 id="1-编译工具链"><a href="#1-编译工具链" class="headerlink" title="1. 编译工具链"></a>1. 编译工具链</h2><p>为了简便期间直接安装build-essential和gdb就可以了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y build-essential gdb</span><br></pre></td></tr></table></figure>
<p>执行<code>objdump -i</code>在第二行提示<code>elf32-i386</code>就说明编译环境ok。</p>
<h2 id="2-QEMU"><a href="#2-QEMU" class="headerlink" title="2. QEMU"></a>2. QEMU</h2><p>X86 CPU模拟器，用于运行内核</p>
<ol>
<li><p>获取MIT修改过的qemu源码<code>git clone https://github.com/mit-pdos/6.828-qemu.git qemu</code></p>
</li>
<li><p>执行<code>./configure --disable-kvm --prefix=/usr/local --target-list=&quot;i386-softmmu x86_64-softmmu&quot;</code> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># linux下需要安装 </span><br><span class="line">libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, libpixman-1-dev</span><br><span class="line"></span><br><span class="line"># 提示pkg-config binary &apos;pkg-config&apos; not found</span><br><span class="line">sudo apt-get install pkg-config</span><br><span class="line"></span><br><span class="line"># 提示 zlib check failed， 需要安装 zlib1g-dev</span><br><span class="line">sudo apt-get install zlib1g-dev</span><br><span class="line"></span><br><span class="line"># 提示 glib-2.12 gthread-2.0 is required to compile QEMU，需要安装libglib2.0-dev</span><br><span class="line">sudo apt-get install libglib2.0-dev</span><br><span class="line"></span><br><span class="line"># 提示 pixman &gt;= 0.21.8, 需要安装libpixman-1-dev</span><br><span class="line">sudo apt-get install libpixman-1-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行<code>make &amp;&amp; make install</code></p>
</li>
</ol>
<h1 id="工具简单指南"><a href="#工具简单指南" class="headerlink" title="工具简单指南"></a>工具简单指南</h1>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/19/redis/20_服务器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/19/redis/20_服务器/" itemprop="url">
                  Redis源码阅读(二十) 服务器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-19 11:14:12 / 修改时间：11:14:13" itemprop="dateCreated datePublished" datetime="2018-09-19T11:14:12+08:00">2018-09-19</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-服务器定义"><a href="#1-服务器定义" class="headerlink" title="1. 服务器定义"></a>1. 服务器定义</h3><p>Redis服务段结构是其最核心的功能结构，负责维护与客户端键的网络连接，维护数据库状态，执行客户端的命令请求，统计一些运行数据等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">/* General */</span></span><br><span class="line">    <span class="comment">// 程序运行主进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid;                  <span class="comment">/* Main process pid. */</span></span><br><span class="line">    <span class="comment">// 配置文件绝对路径</span></span><br><span class="line">    <span class="keyword">char</span> *configfile;           <span class="comment">/* Absolute config file path, or NULL */</span></span><br><span class="line">    <span class="comment">// 可执行文件绝对路径</span></span><br><span class="line">    <span class="keyword">char</span> *executable;           <span class="comment">/* Absolute executable file path. */</span></span><br><span class="line">    <span class="comment">// 执行executable时的命令行参数</span></span><br><span class="line">    <span class="keyword">char</span> **exec_argv;           <span class="comment">/* Executable argv vector (copy). */</span></span><br><span class="line">    <span class="comment">// serverCron()调用频率</span></span><br><span class="line">    <span class="keyword">int</span> hz;                     <span class="comment">/* serverCron() calls frequency in hertz */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// RedisDB对象，长度16，每个都存储了Redis数据库对象</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  命令表</span></span><br><span class="line">    dict *commands;             <span class="comment">/* Command table */</span></span><br><span class="line">    <span class="comment">// rename之前的命令表</span></span><br><span class="line">    dict *orig_commands;        <span class="comment">/* Command table before command renaming. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件循环</span></span><br><span class="line">    aeEventLoop *el;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器LRU时钟</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lruclock;      <span class="comment">/* Clock for LRU eviction */</span></span><br><span class="line">    <span class="comment">// 立即关闭服务器</span></span><br><span class="line">    <span class="keyword">int</span> shutdown_asap;          <span class="comment">/* SHUTDOWN needed ASAP */</span></span><br><span class="line">    <span class="comment">// 在执行serverCron()期间进行rehash</span></span><br><span class="line">    <span class="keyword">int</span> activerehashing;        <span class="comment">/* Incremental rehash in serverCron() */</span></span><br><span class="line">    <span class="comment">// 主动进行碎片整理</span></span><br><span class="line">    <span class="keyword">int</span> active_defrag_running;  <span class="comment">/* Active defragmentation running (holds current scan aggressiveness) */</span></span><br><span class="line">    <span class="comment">// 是否设置了密码</span></span><br><span class="line">    <span class="keyword">char</span> *requirepass;          <span class="comment">/* Pass for AUTH command, or NULL */</span></span><br><span class="line">    <span class="comment">// PID文件路径</span></span><br><span class="line">    <span class="keyword">char</span> *pidfile;              <span class="comment">/* PID file path */</span></span><br><span class="line">    <span class="comment">// 架构类型，32位或64位</span></span><br><span class="line">    <span class="keyword">int</span> arch_bits;              <span class="comment">/* 32 or 64 depending on sizeof(long) */</span></span><br><span class="line">    <span class="comment">// serverCron()运行次数计数</span></span><br><span class="line">    <span class="keyword">int</span> cronloops;              <span class="comment">/* Number of times the cron function run */</span></span><br><span class="line">    <span class="comment">// 服务器运行ID，每次重启都会分配新的id</span></span><br><span class="line">    <span class="keyword">char</span> runid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>];  <span class="comment">/* ID always different at every exec. */</span></span><br><span class="line">    <span class="comment">// 服务器是否运行在Sentinel模式</span></span><br><span class="line">    <span class="keyword">int</span> sentinel_mode;          <span class="comment">/* True if this instance is a Sentinel. */</span></span><br><span class="line">    <span class="comment">// 服务器初始化后使用内存的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> initial_memory_usage; <span class="comment">/* Bytes used after initialization. */</span></span><br><span class="line">    <span class="comment">// 非标准输出也会记录Redis的logo</span></span><br><span class="line">    <span class="keyword">int</span> always_show_logo;       <span class="comment">/* Show logo even for non-stdout logging. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Modules */</span></span><br><span class="line">    <span class="comment">// 模块暴露的API</span></span><br><span class="line">    dict *moduleapi;            <span class="comment">/* Exported APIs dictionary for modules. */</span></span><br><span class="line">    <span class="comment">// 服务器启动时需要加载的模块</span></span><br><span class="line">    <span class="built_in">list</span> *loadmodule_queue;     <span class="comment">/* List of modules to load at startup. */</span></span><br><span class="line">    <span class="comment">// 这个pipe用来唤醒事件循环中的需要module命令处理的阻塞客户端</span></span><br><span class="line">    <span class="keyword">int</span> module_blocked_pipe[<span class="number">2</span>]; <span class="comment">/* Pipe used to awake the event loop if a</span></span><br><span class="line"><span class="comment">                                   client blocked on a module command needs</span></span><br><span class="line"><span class="comment">                                   to be processed. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Networking */</span></span><br><span class="line">    <span class="comment">// 监听端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">/* TCP listening port */</span></span><br><span class="line">    <span class="comment">// listen()函数的backlog参数</span></span><br><span class="line">    <span class="keyword">int</span> tcp_backlog;            <span class="comment">/* TCP listen() backlog */</span></span><br><span class="line">    <span class="comment">// 绑定的地址</span></span><br><span class="line">    <span class="keyword">char</span> *bindaddr[CONFIG_BINDADDR_MAX]; <span class="comment">/* Addresses we should bind to */</span></span><br><span class="line">    <span class="comment">// 绑定地址的数量</span></span><br><span class="line">    <span class="keyword">int</span> bindaddr_count;         <span class="comment">/* Number of addresses in server.bindaddr[] */</span></span><br><span class="line">    <span class="comment">// UNIX套接字</span></span><br><span class="line">    <span class="comment">// socket路径</span></span><br><span class="line">    <span class="keyword">char</span> *unixsocket;           <span class="comment">/* UNIX socket path */</span></span><br><span class="line">    <span class="comment">// socket模式</span></span><br><span class="line">    <span class="keyword">mode_t</span> unixsocketperm;      <span class="comment">/* UNIX socket permission */</span></span><br><span class="line">    <span class="comment">// TCPsocket的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ipfd[CONFIG_BINDADDR_MAX]; <span class="comment">/* TCP socket file descriptors */</span></span><br><span class="line">    <span class="comment">// TCP文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> ipfd_count;             <span class="comment">/* Used slots in ipfd[] */</span></span><br><span class="line">    <span class="comment">// UNIX socket文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> sofd;                   <span class="comment">/* Unix socket file descriptor */</span></span><br><span class="line">    <span class="comment">// 集群文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> cfd[CONFIG_BINDADDR_MAX];<span class="comment">/* Cluster bus listening socket */</span></span><br><span class="line">    <span class="comment">// 集群文件描述符数量</span></span><br><span class="line">    <span class="keyword">int</span> cfd_count;              <span class="comment">/* Used slots in cfd[] */</span></span><br><span class="line">    <span class="comment">// 服务器客户端链表，存储所有的客户端</span></span><br><span class="line">    <span class="built_in">list</span> *clients;              <span class="comment">/* List of active clients */</span></span><br><span class="line">    <span class="comment">// 即将关闭的客户端链表</span></span><br><span class="line">    <span class="built_in">list</span> *clients_to_close;     <span class="comment">/* Clients to close asynchronously */</span></span><br><span class="line">    <span class="comment">// 准备写操作或安装写处理程序的客户端链表</span></span><br><span class="line">    <span class="built_in">list</span> *clients_pending_write; <span class="comment">/* There is to write or install handler. */</span></span><br><span class="line">    <span class="comment">// 从节点链表，监控客户端链表</span></span><br><span class="line">    <span class="built_in">list</span> *slaves, *monitors;    <span class="comment">/* List of slaves and MONITORs */</span></span><br><span class="line">    <span class="comment">// 当前客户端，仅用于崩溃报告</span></span><br><span class="line">    client *current_client; <span class="comment">/* Current client, only used on crash report */</span></span><br><span class="line">    <span class="comment">// 客户端是否处于暂停</span></span><br><span class="line">    <span class="keyword">int</span> clients_paused;         <span class="comment">/* True if clients are currently paused */</span></span><br><span class="line">    <span class="comment">// 取消暂停状态时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> clients_pause_end_time; <span class="comment">/* Time when we undo clients_paused */</span></span><br><span class="line">    <span class="comment">// 网络错误缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> neterr[ANET_ERR_LEN];   <span class="comment">/* Error buffer for anet.c */</span></span><br><span class="line">    <span class="comment">// 迁移缓存套接字的字典，键：host:ip，值：TCP套接字结构</span></span><br><span class="line">    dict *migrate_cached_sockets;<span class="comment">/* MIGRATE cached sockets */</span></span><br><span class="line">    <span class="comment">// 下一个客户端ID</span></span><br><span class="line">    <span class="keyword">uint64_t</span> next_client_id;    <span class="comment">/* Next client unique ID. Incremental. */</span></span><br><span class="line">    <span class="comment">// 保护模式，不接受外部链接, 仅本地连接</span></span><br><span class="line">    <span class="keyword">int</span> protected_mode;         <span class="comment">/* Don't accept external connections. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RDB / AOF loading information */</span></span><br><span class="line">    <span class="comment">// 服务器处于加载状态，从RDB/AOF文件恢复中</span></span><br><span class="line">    <span class="keyword">int</span> loading;                <span class="comment">/* We are loading data from disk if true */</span></span><br><span class="line">    <span class="comment">// 要加载的总字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> loading_total_bytes;</span><br><span class="line">    <span class="comment">// 已经加载的字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> loading_loaded_bytes;</span><br><span class="line">    <span class="comment">// 加载开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> loading_start_time;</span><br><span class="line">    <span class="comment">// 加载过程中，读写的最大块字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> loading_process_events_interval_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fast pointers to often looked up command */</span></span><br><span class="line">    <span class="comment">// Redis命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">delCommand</span>, *<span class="title">multiCommand</span>, *<span class="title">lpushCommand</span>, *<span class="title">lpopCommand</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">rpopCommand</span>, *<span class="title">sremCommand</span>, *<span class="title">execCommand</span>, *<span class="title">expireCommand</span>,</span></span><br><span class="line"><span class="class">                        *<span class="title">pexpireCommand</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fields used only for stats */</span></span><br><span class="line">    <span class="comment">// 服务器开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> stat_starttime;          <span class="comment">/* Server start time */</span></span><br><span class="line">    <span class="comment">// 执行命令的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_numcommands;     <span class="comment">/* Number of processed commands */</span></span><br><span class="line">    <span class="comment">// 接收连接的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_numconnections;  <span class="comment">/* Number of connections received */</span></span><br><span class="line">    <span class="comment">// 过期键的数量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_expiredkeys;     <span class="comment">/* Number of expired keys */</span></span><br><span class="line">    <span class="comment">// 键可能过期的百分比</span></span><br><span class="line">    <span class="keyword">double</span> stat_expired_stale_perc; <span class="comment">/* Percentage of keys probably expired */</span></span><br><span class="line">    <span class="comment">// 删除过期键时，如果过期键太多但我们不能一直进行删除，所以设定了时间</span></span><br><span class="line">    <span class="comment">// 超过该时间，则退出循环等待下一次删除，该属性记录超过该时间的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_expired_time_cap_reached_count; <span class="comment">/* Early expire cylce stops.*/</span></span><br><span class="line">    <span class="comment">// LFU算法中，驱逐key的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_evictedkeys;     <span class="comment">/* Number of evicted keys (maxmemory) */</span></span><br><span class="line">    <span class="comment">// 成功命中key的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_keyspace_hits;   <span class="comment">/* Number of successful lookups of keys */</span></span><br><span class="line">    <span class="comment">// 没有命中key的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_keyspace_misses; <span class="comment">/* Number of failed lookups of keys */</span></span><br><span class="line">    <span class="comment">// 整理内存碎片命中次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_active_defrag_hits;      <span class="comment">/* number of allocations moved */</span></span><br><span class="line">    <span class="comment">// 整理内存碎片没有命中次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_active_defrag_misses;    <span class="comment">/* number of allocations scanned but not moved */</span></span><br><span class="line">    <span class="comment">// 整理内存碎片key被重新分配的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_active_defrag_key_hits;  <span class="comment">/* number of keys with moved allocations */</span></span><br><span class="line">    <span class="comment">// 整理内存碎片扫描到key但没有移动的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_active_defrag_key_misses;<span class="comment">/* number of keys scanned and not moved */</span></span><br><span class="line">    <span class="comment">// 使用的内存峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_peak_memory;        <span class="comment">/* Max used memory record */</span></span><br><span class="line">    <span class="comment">// 执行fork()的时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_fork_time;       <span class="comment">/* Time needed to perform latest fork() */</span></span><br><span class="line">    <span class="comment">// 执行fork()的速率</span></span><br><span class="line">    <span class="keyword">double</span> stat_fork_rate;          <span class="comment">/* Fork rate in GB/sec. */</span></span><br><span class="line">    <span class="comment">// 因为最大客户端数，拒绝客户端连接的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_rejected_conn;   <span class="comment">/* Clients rejected because of maxclients */</span></span><br><span class="line">    <span class="comment">// 执行从节点全量同步的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_sync_full;       <span class="comment">/* Number of full resyncs with slaves. */</span></span><br><span class="line">    <span class="comment">// 成功接受PSYNC的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_sync_partial_ok; <span class="comment">/* Number of accepted PSYNC requests. */</span></span><br><span class="line">    <span class="comment">// 错误接受PSYNC的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_sync_partial_err;<span class="comment">/* Number of unaccepted PSYNC requests. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 慢查询命令链表</span></span><br><span class="line">    <span class="built_in">list</span> *slowlog;                  <span class="comment">/* SLOWLOG list of commands */</span></span><br><span class="line">    <span class="comment">// 当前慢查询的日志ID</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_entry_id;     <span class="comment">/* SLOWLOG current entry ID */</span></span><br><span class="line">    <span class="comment">// 慢查询的评定时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> slowlog_log_slower_than; <span class="comment">/* SLOWLOG time limit (to get logged) */</span></span><br><span class="line">    <span class="comment">// 慢查询的最大数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> slowlog_max_len;     <span class="comment">/* SLOWLOG max number of items logged */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// serverCron() 中采用RSS, 常驻内存大小</span></span><br><span class="line">    <span class="keyword">size_t</span> resident_set_size;       <span class="comment">/* RSS sampled in serverCron(). */</span></span><br><span class="line">    <span class="comment">// 读取网络字节数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_net_input_bytes; <span class="comment">/* Bytes read from network. */</span></span><br><span class="line">    <span class="comment">// 输出网络字节数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> stat_net_output_bytes; <span class="comment">/* Bytes written to network. */</span></span><br><span class="line">    <span class="comment">// RDB保存时写时复制的字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_rdb_cow_bytes;      <span class="comment">/* Copy on write bytes during RDB saving. */</span></span><br><span class="line">    <span class="comment">// AOF执行时写时复制的字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> stat_aof_cow_bytes;      <span class="comment">/* Copy on write bytes during AOF rewrite. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following two are used to track instantaneous metrics, like</span></span><br><span class="line"><span class="comment">     * number of operations per second, network traffic. */</span></span><br><span class="line">    <span class="comment">// 用来追踪瞬时数据，例如每秒操作数，网络流量等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// 上次采样的时间戳</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> last_sample_time; <span class="comment">/* Timestamp of last sample in ms */</span></span><br><span class="line">        <span class="comment">// 上次采用的数量</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> last_sample_count;<span class="comment">/* Count in last sample */</span></span><br><span class="line">        <span class="comment">// 采用数据</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> samples[STATS_METRIC_SAMPLES];</span><br><span class="line">        <span class="comment">// 下标</span></span><br><span class="line">        <span class="keyword">int</span> idx;</span><br><span class="line">    &#125; inst_metric[STATS_METRIC_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Configuration */</span></span><br><span class="line">    <span class="comment">// 日志级别</span></span><br><span class="line">    <span class="keyword">int</span> verbosity;                  <span class="comment">/* Loglevel in redis.conf */</span></span><br><span class="line">    <span class="comment">// 客户端最大空闲时间，超过会超时</span></span><br><span class="line">    <span class="keyword">int</span> maxidletime;                <span class="comment">/* Client timeout in seconds */</span></span><br><span class="line">    <span class="comment">// 开启SO_KEEPALIVE选项</span></span><br><span class="line">    <span class="keyword">int</span> tcpkeepalive;               <span class="comment">/* Set SO_KEEPALIVE if non-zero. */</span></span><br><span class="line">    <span class="comment">// 开启过期</span></span><br><span class="line">    <span class="keyword">int</span> active_expire_enabled;      <span class="comment">/* Can be disabled for testing purposes. */</span></span><br><span class="line">    <span class="comment">// 开启内存整理</span></span><br><span class="line">    <span class="keyword">int</span> active_defrag_enabled;</span><br><span class="line">    <span class="comment">// 内存碎片整理的标准，小于这个值会忽略</span></span><br><span class="line">    <span class="keyword">size_t</span> active_defrag_ignore_bytes; <span class="comment">/* minimum amount of fragmentation waste to start active defrag */</span></span><br><span class="line">    <span class="comment">// 内存碎片的最小比例，开启内存整理</span></span><br><span class="line">    <span class="keyword">int</span> active_defrag_threshold_lower; <span class="comment">/* minimum percentage of fragmentation to start active defrag */</span></span><br><span class="line">    <span class="comment">// 碎片的最大比例</span></span><br><span class="line">    <span class="keyword">int</span> active_defrag_threshold_upper; <span class="comment">/* maximum percentage of fragmentation at which we use maximum effort */</span></span><br><span class="line">    <span class="comment">// 碎片整理的CPU占用最小比例</span></span><br><span class="line">    <span class="keyword">int</span> active_defrag_cycle_min;       <span class="comment">/* minimal effort for defrag in CPU percentage */</span></span><br><span class="line">    <span class="comment">// 碎片整理的CPU占用最大比例</span></span><br><span class="line">    <span class="keyword">int</span> active_defrag_cycle_max;       <span class="comment">/* maximal effort for defrag in CPU percentage */</span></span><br><span class="line">    <span class="comment">// 客户端查询缓冲区的最大长度</span></span><br><span class="line">    <span class="keyword">size_t</span> client_max_querybuf_len; <span class="comment">/* Limit for client query buffer length */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器数据库的数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;                      <span class="comment">/* Total number of configured DBs */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1表示有监督，0表示没有</span></span><br><span class="line">    <span class="keyword">int</span> supervised;                 <span class="comment">/* 1 if supervised, 0 otherwise. */</span></span><br><span class="line">    <span class="comment">// 监督模式</span></span><br><span class="line">    <span class="keyword">int</span> supervised_mode;            <span class="comment">/* See SUPERVISED_* */</span></span><br><span class="line">    <span class="comment">// 是否运行在守护模式</span></span><br><span class="line">    <span class="keyword">int</span> daemonize;                  <span class="comment">/* True if running as a daemon */</span></span><br><span class="line">    <span class="comment">// 不同类型的客户端输出缓冲区限制</span></span><br><span class="line">    clientBufferLimitsConfig client_obuf_limits[CLIENT_TYPE_OBUF_COUNT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AOF persistence */</span></span><br><span class="line">    <span class="comment">// 服务器AOF状态</span></span><br><span class="line">    <span class="keyword">int</span> aof_state;                  <span class="comment">/* AOF_(ON|OFF|WAIT_REWRITE) */</span></span><br><span class="line">    <span class="comment">// 服务器AOF的fsync策略</span></span><br><span class="line">    <span class="keyword">int</span> aof_fsync;                  <span class="comment">/* Kind of fsync() policy */</span></span><br><span class="line">    <span class="comment">// 服务器AOF文件名</span></span><br><span class="line">    <span class="keyword">char</span> *aof_filename;             <span class="comment">/* Name of the AOF file */</span></span><br><span class="line">    <span class="comment">// 如果有aof执行，则不进行fsync</span></span><br><span class="line">    <span class="keyword">int</span> aof_no_fsync_on_rewrite;    <span class="comment">/* Don't fsync if a rewrite is in prog. */</span></span><br><span class="line">    <span class="comment">// AOF增长比率，默认100</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_perc;           <span class="comment">/* Rewrite AOF if % growth is &gt; M and... */</span></span><br><span class="line">    <span class="comment">// AOF最小字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> aof_rewrite_min_size;     <span class="comment">/* the AOF file is at least N bytes. */</span></span><br><span class="line">    <span class="comment">// AOF初始字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> aof_rewrite_base_size;    <span class="comment">/* AOF size on latest startup or rewrite. */</span></span><br><span class="line">    <span class="comment">// AOF当前字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> aof_current_size;         <span class="comment">/* AOF current size. */</span></span><br><span class="line">    <span class="comment">// AOF重写提上日程，BGSAVE完成立即执行</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_scheduled;      <span class="comment">/* Rewrite once BGSAVE terminates. */</span></span><br><span class="line">    <span class="comment">// AOF子进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;            <span class="comment">/* PID if rewriting process */</span></span><br><span class="line">    <span class="comment">// AOF缓冲区链表</span></span><br><span class="line">    <span class="built_in">list</span> *aof_rewrite_buf_blocks;   <span class="comment">/* Hold changes during an AOF rewrite. */</span></span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;      <span class="comment">/* AOF buffer, written before entering the event loop */</span></span><br><span class="line">    <span class="comment">// AOF文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> aof_fd;       <span class="comment">/* File descriptor of currently selected AOF file */</span></span><br><span class="line">    <span class="comment">// AOF选中的db</span></span><br><span class="line">    <span class="keyword">int</span> aof_selected_db; <span class="comment">/* Currently selected DB in AOF */</span></span><br><span class="line">    <span class="comment">// 延迟执行flush操作的开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_flush_postponed_start; <span class="comment">/* UNIX time of postponed AOF flush */</span></span><br><span class="line">    <span class="comment">// 最后一次fsync的直接</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_last_fsync;            <span class="comment">/* UNIX time of last fsync() */</span></span><br><span class="line">    <span class="comment">// AOF执行最后时间</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_rewrite_time_last;   <span class="comment">/* Time used by last AOF rewrite run. */</span></span><br><span class="line">    <span class="comment">// AOF执行开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_rewrite_time_start;  <span class="comment">/* Current AOF rewrite start time. */</span></span><br><span class="line">    <span class="comment">// AOF执行的状态</span></span><br><span class="line">    <span class="keyword">int</span> aof_lastbgrewrite_status;   <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line">    <span class="comment">// 延迟fsync的次数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> aof_delayed_fsync;  <span class="comment">/* delayed AOF fsync() counter */</span></span><br><span class="line">    <span class="comment">// 重写时是否开启增量式同步，每次写入AOF_AUTOSYNC_BYTES个字节，就执行一次同步</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_incremental_fsync;<span class="comment">/* fsync incrementally while rewriting? */</span></span><br><span class="line">    <span class="comment">// 上一次AOF操作状态</span></span><br><span class="line">    <span class="keyword">int</span> aof_last_write_status;      <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line">    <span class="comment">// 删一次AOF操作错误</span></span><br><span class="line">    <span class="keyword">int</span> aof_last_write_errno;       <span class="comment">/* Valid if aof_last_write_status is ERR */</span></span><br><span class="line">    <span class="keyword">int</span> aof_load_truncated;         <span class="comment">/* Don't stop on unexpected AOF EOF. */</span></span><br><span class="line">    <span class="keyword">int</span> aof_use_rdb_preamble;       <span class="comment">/* Use RDB preamble on AOF rewrites. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AOF pipes used to communicate between parent and child during rewrite. */</span></span><br><span class="line">    <span class="comment">// 进程通信文件描述描述符，管道</span></span><br><span class="line">    <span class="keyword">int</span> aof_pipe_write_data_to_child;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_read_data_from_parent;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_write_ack_to_parent;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_read_ack_from_child;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_write_ack_to_child;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_read_ack_from_parent;</span><br><span class="line">    <span class="keyword">int</span> aof_stop_sending_diff;     <span class="comment">/* If true stop sending accumulated diffs</span></span><br><span class="line"><span class="comment">                                      to child process. */</span></span><br><span class="line">    <span class="comment">// 保存子进程AOF时累积数据的sds</span></span><br><span class="line">    sds aof_child_diff;             <span class="comment">/* AOF diff accumulator child side. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* RDB persistence */</span></span><br><span class="line">    <span class="comment">// 记录数据库被修改的次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty;                <span class="comment">/* Changes to DB from the last save */</span></span><br><span class="line">    <span class="comment">// BGSAVE执行前，需要备份dirty</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> dirty_before_bgsave;  <span class="comment">/* Used to restore dirty on failed BGSAVE */</span></span><br><span class="line">    <span class="comment">// 执行BGSAVE的子进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span> rdb_child_pid;            <span class="comment">/* PID of RDB saving child */</span></span><br><span class="line">    <span class="comment">// RDB执行的参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">saveparam</span> *<span class="title">saveparams</span>;</span>   <span class="comment">/* Save points array for RDB */</span></span><br><span class="line">    <span class="comment">// save参数的长度</span></span><br><span class="line">    <span class="keyword">int</span> saveparamslen;              <span class="comment">/* Number of saving points */</span></span><br><span class="line">    <span class="comment">// rdb文件名称</span></span><br><span class="line">    <span class="keyword">char</span> *rdb_filename;             <span class="comment">/* Name of RDB file */</span></span><br><span class="line">    <span class="comment">// 是否采用LZF压缩算法压缩RDB文件</span></span><br><span class="line">    <span class="keyword">int</span> rdb_compression;            <span class="comment">/* Use compression in RDB? */</span></span><br><span class="line">    <span class="comment">// RDB是否使用校验和</span></span><br><span class="line">    <span class="keyword">int</span> rdb_checksum;               <span class="comment">/* Use RDB checksum? */</span></span><br><span class="line">    <span class="comment">// 上一次save成功的实际</span></span><br><span class="line">    <span class="keyword">time_t</span> lastsave;                <span class="comment">/* Unix time of last successful save */</span></span><br><span class="line">    <span class="comment">// 上一次尝试bgsave的实际</span></span><br><span class="line">    <span class="keyword">time_t</span> lastbgsave_try;          <span class="comment">/* Unix time of last attempted bgsave */</span></span><br><span class="line">    <span class="comment">// 上一次save执行的实际</span></span><br><span class="line">    <span class="keyword">time_t</span> rdb_save_time_last;      <span class="comment">/* Time used by last RDB save run. */</span></span><br><span class="line">    <span class="comment">// RDB保存开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> rdb_save_time_start;     <span class="comment">/* Current RDB save start time. */</span></span><br><span class="line">    <span class="comment">// BGSAVE计划</span></span><br><span class="line">    <span class="keyword">int</span> rdb_bgsave_scheduled;       <span class="comment">/* BGSAVE when possible if true. */</span></span><br><span class="line">    <span class="comment">// rdb执行的类型，写入磁盘还是从节点socket</span></span><br><span class="line">    <span class="keyword">int</span> rdb_child_type;             <span class="comment">/* Type of save by active child. */</span></span><br><span class="line">    <span class="comment">// 上一次BGSAVE执行的状态</span></span><br><span class="line">    <span class="keyword">int</span> lastbgsave_status;          <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line">    <span class="comment">// BGSAVE出错则停止写</span></span><br><span class="line">    <span class="keyword">int</span> stop_writes_on_bgsave_err;  <span class="comment">/* Don't allow writes if can't BGSAVE */</span></span><br><span class="line">    <span class="comment">// rdb管道写端</span></span><br><span class="line">    <span class="keyword">int</span> rdb_pipe_write_result_to_parent; <span class="comment">/* RDB pipes used to return the state */</span></span><br><span class="line">    <span class="comment">// rdb管道读端, 使用无盘同步</span></span><br><span class="line">    <span class="keyword">int</span> rdb_pipe_read_result_from_child; <span class="comment">/* of each slave in diskless SYNC. */</span></span><br><span class="line">    <span class="comment">/* Pipe and data structures for child -&gt; parent info sharing. */</span></span><br><span class="line">    <span class="keyword">int</span> child_info_pipe[<span class="number">2</span>];         <span class="comment">/* Pipe used to write the child_info_data. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子进程信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="comment">// AOF 或 RDB</span></span><br><span class="line">        <span class="keyword">int</span> process_type;           <span class="comment">/* AOF or RDB child? */</span></span><br><span class="line">        <span class="comment">// 写时复制的大小</span></span><br><span class="line">        <span class="keyword">size_t</span> cow_size;            <span class="comment">/* Copy on write size. */</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> magic;   <span class="comment">/* Magic value to make sure data is valid. */</span></span><br><span class="line">    &#125; child_info_data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Propagation of commands in AOF / replication */</span></span><br><span class="line">    <span class="comment">// 传递给AOF/replication的一些命令</span></span><br><span class="line">    redisOpArray also_propagate;    <span class="comment">/* Additional command to propagate. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Logging */</span></span><br><span class="line">    <span class="comment">// 日志文件路径</span></span><br><span class="line">    <span class="keyword">char</span> *logfile;                  <span class="comment">/* Path of log file */</span></span><br><span class="line">    <span class="comment">// 是否开启系统日志</span></span><br><span class="line">    <span class="keyword">int</span> syslog_enabled;             <span class="comment">/* Is syslog enabled? */</span></span><br><span class="line">    <span class="comment">// 系统日志标识</span></span><br><span class="line">    <span class="keyword">char</span> *syslog_ident;             <span class="comment">/* Syslog ident */</span></span><br><span class="line">    <span class="keyword">int</span> syslog_facility;            <span class="comment">/* Syslog facility */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replication (slave) */</span></span><br><span class="line">    <span class="comment">// master结点的验证密码</span></span><br><span class="line">    <span class="keyword">char</span> *masterauth;               <span class="comment">/* AUTH with this password with master */</span></span><br><span class="line">    <span class="comment">// master结点的地址</span></span><br><span class="line">    <span class="keyword">char</span> *masterhost;               <span class="comment">/* Hostname of master */</span></span><br><span class="line">    <span class="comment">// master结点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> masterport;                 <span class="comment">/* Port of master */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* Synchronous replication. */</span></span><br><span class="line">    <span class="comment">// 等待WAIT命令的客户端链表</span></span><br><span class="line">    <span class="built_in">list</span> *clients_waiting_acks;         <span class="comment">/* Clients waiting in WAIT command. */</span></span><br><span class="line">    <span class="comment">// 读取从节点ack</span></span><br><span class="line">    <span class="keyword">int</span> get_ack_from_slaves;            <span class="comment">/* If true we send REPLCONF GETACK. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Limits */</span></span><br><span class="line">    <span class="comment">// 同时最多连接的客户端数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> maxclients;            <span class="comment">/* Max number of simultaneous clients */</span></span><br><span class="line">    <span class="comment">// 服务器使用内存的最大值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> maxmemory;   <span class="comment">/* Max number of memory bytes to use */</span></span><br><span class="line">    <span class="comment">// 键占用内存回收策略</span></span><br><span class="line">    <span class="keyword">int</span> maxmemory_policy;           <span class="comment">/* Policy for key eviction */</span></span><br><span class="line">    <span class="comment">// 随机采样的个数</span></span><br><span class="line">    <span class="keyword">int</span> maxmemory_samples;          <span class="comment">/* Pricision of random sampling */</span></span><br><span class="line">    <span class="comment">// LFU 对数计数因子</span></span><br><span class="line">    <span class="keyword">int</span> lfu_log_factor;             <span class="comment">/* LFU logarithmic counter factor. */</span></span><br><span class="line">    <span class="comment">// LFU 反衰减因子</span></span><br><span class="line">    <span class="keyword">int</span> lfu_decay_time;             <span class="comment">/* LFU counter decay factor. */</span></span><br><span class="line">    <span class="comment">// 批量协议最大长度</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> proto_max_bulk_len;   <span class="comment">/* Protocol bulk length maximum size. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Blocked clients */</span></span><br><span class="line">    <span class="comment">// 阻塞的客户端数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bpop_blocked_clients; <span class="comment">/* Number of clients blocked by lists */</span></span><br><span class="line">    <span class="comment">// 阻塞的客户端链表</span></span><br><span class="line">    <span class="built_in">list</span> *unblocked_clients; <span class="comment">/* list of clients to unblock before next loop */</span></span><br><span class="line">    <span class="comment">// BLPOP命令产生的阻塞键列表</span></span><br><span class="line">    <span class="built_in">list</span> *ready_keys;        <span class="comment">/* List of readyList structures for BLPOP &amp; co */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sort parameters - qsort_r() is only available under BSD so we</span></span><br><span class="line"><span class="comment">     * have to take this state global, in order to pass it to sortCompare() */</span></span><br><span class="line">    <span class="comment">// 降序排序</span></span><br><span class="line">    <span class="keyword">int</span> sort_desc;</span><br><span class="line">    <span class="comment">// 根据字母排序</span></span><br><span class="line">    <span class="keyword">int</span> sort_alpha;</span><br><span class="line">    <span class="comment">// 根据模式排序</span></span><br><span class="line">    <span class="keyword">int</span> sort_bypattern;</span><br><span class="line">    <span class="comment">// 根据分数排序</span></span><br><span class="line">    <span class="keyword">int</span> sort_store;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Zip structure config, see redis.conf for more information  */</span></span><br><span class="line">    <span class="comment">// ziplist最大结点个数</span></span><br><span class="line">    <span class="keyword">size_t</span> hash_max_ziplist_entries;</span><br><span class="line">    <span class="comment">// ziplist结点最大内存</span></span><br><span class="line">    <span class="keyword">size_t</span> hash_max_ziplist_value;</span><br><span class="line">    <span class="comment">// set整数集合最大结点数</span></span><br><span class="line">    <span class="keyword">size_t</span> set_max_intset_entries;</span><br><span class="line">    <span class="comment">// zset压缩列表最大结点数</span></span><br><span class="line">    <span class="keyword">size_t</span> zset_max_ziplist_entries;</span><br><span class="line">    <span class="comment">// zset压缩列表结点最大内存</span></span><br><span class="line">    <span class="keyword">size_t</span> zset_max_ziplist_value;</span><br><span class="line">    <span class="keyword">size_t</span> hll_sparse_max_bytes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List parameters */</span></span><br><span class="line">    <span class="comment">// list压缩列表最大长度</span></span><br><span class="line">    <span class="keyword">int</span> list_max_ziplist_size;</span><br><span class="line">    <span class="comment">// list压缩列表压缩程度</span></span><br><span class="line">    <span class="keyword">int</span> list_compress_depth;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* time cache */</span></span><br><span class="line">    <span class="comment">// 循环采用世界</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;    <span class="comment">/* Unix time sampled every cron cycle. */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;   <span class="comment">/* Like 'unixtime' but with milliseconds resolution. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Pubsub */</span></span><br><span class="line">    <span class="comment">// 客户端订阅channel的字典</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line">    <span class="comment">// pubsub定义模式</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* A list of pubsub_patterns */</span></span><br><span class="line">    <span class="comment">// 通过Pub/Sub传递事件</span></span><br><span class="line">    <span class="keyword">int</span> notify_keyspace_events; <span class="comment">/* Events to propagate via Pub/Sub. This is an</span></span><br><span class="line"><span class="comment">                                   xor of NOTIFY_... flags. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cluster */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Scripting */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-Redis命令"><a href="#2-Redis命令" class="headerlink" title="2. Redis命令"></a>2. Redis命令</h3><h4 id="2-1-命令表-commands"><a href="#2-1-命令表-commands" class="headerlink" title="2.1 命令表 commands"></a>2.1 命令表 commands</h4><p>命令表存储了Redis可执行的命令字典，并对每个命令设定了一些执行参数。orig_commands是重命名之后的命令表，通过重命名可以提升Redis的安全性，比如讲KEYS, FLUSHDB这类的命令重命名为别的，这样一般用户在就不知道其真实的命令。</p>
<ul>
<li>命令结构表示如下</li>
</ul>
<table>
<thead>
<tr>
<th>字段名</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>name</td>
<td>命名的名称，用户执行命令通过查找命令表匹配该字段来寻找相应的命令</td>
</tr>
<tr>
<td>function</td>
<td>执行命令实现的方法</td>
</tr>
<tr>
<td>arity</td>
<td>命令参数的个数，-N表示大于等于N。命令本身也是一个参数</td>
</tr>
<tr>
<td>sflags</td>
<td>字符串形式标识符，用于设置命令的属性</td>
</tr>
<tr>
<td>flags</td>
<td>sflags标识符的二进制标识，由sflags计算</td>
</tr>
<tr>
<td>get_keys_proc</td>
<td>一个可选函数，用于获取命令参数，只有在first_key_index，last_key_index，key_step无法指定哪些是参数时才使用此选项</td>
</tr>
<tr>
<td>first_key_index</td>
<td>第一个参数是key</td>
</tr>
<tr>
<td>last_key_index</td>
<td>最后一个参数是key</td>
</tr>
<tr>
<td>key_step</td>
<td>key之间的步长，如MSET步长为2， MSET key value key2 value2 …</td>
</tr>
<tr>
<td>microseconds</td>
<td>服务器执行该命令耗费的时间</td>
</tr>
<tr>
<td>calls</td>
<td>服务器总共执行了多少次该命令</td>
</tr>
</tbody>
</table>
<ul>
<li>命令的属性sflag标识</li>
</ul>
<table>
<thead>
<tr>
<th>标识</th>
<th>意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>w</td>
<td>写命令</td>
</tr>
<tr>
<td>r</td>
<td>读命令</td>
</tr>
<tr>
<td>m</td>
<td>该命令会占用大量内存，执行之前需要检查内存情况</td>
</tr>
<tr>
<td>a</td>
<td>管理命令，如SAVE，SHUTDOWN等</td>
</tr>
<tr>
<td>p</td>
<td>发布订阅模式的命令</td>
</tr>
<tr>
<td>f</td>
<td>强制复制命令，无视服务器脏计数</td>
</tr>
<tr>
<td>s</td>
<td>Lua脚本中不允许的命令</td>
</tr>
<tr>
<td>R</td>
<td>随机命令，相同情况下，结果可能不同</td>
</tr>
<tr>
<td>S</td>
<td>Lua脚本中使用标识则需要对结果进行排序</td>
</tr>
<tr>
<td>l</td>
<td>服务器载入情况下可以使用的命令</td>
</tr>
<tr>
<td>t</td>
<td>从节点服务器数据过期时允许执行的命令</td>
</tr>
<tr>
<td>M</td>
<td>在MONITOR模式下不会自动传播</td>
</tr>
<tr>
<td>k</td>
<td>执行一个显示的ASKING，使得在集群模式下，被标志为imporing的槽可以接受该命令</td>
</tr>
<tr>
<td>F</td>
<td>快速模式，O(1)或O(log(N))的复杂度</td>
</tr>
</tbody>
</table>
<h4 id="2-2-命令请求执行过程"><a href="#2-2-命令请求执行过程" class="headerlink" title="2.2 命令请求执行过程"></a>2.2 命令请求执行过程</h4><p>客户端发送命令到服务端执行返回有一下几个步骤：</p>
<ol>
<li><p>客户端与服务端建立连接，按照一定格式封装命令</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SET msg hello 命令转换后如下</span></span><br><span class="line">*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nmsg\r\n<span class="variable">$5</span>\r\nhello\r\n</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器接收到来自网络客户端的请求数据，按照协议格式解析命令</p>
<ol>
<li>读取套接字中的命令请求，存储到对应的客户端输入缓冲区中</li>
<li>读取缓冲区中数据，解析命令，提取命令请求和参数</li>
</ol>
</li>
<li><p>获得解析命令后查找服务器的命令表，找到对应的命令及其执行方法</p>
<ol>
<li>查找服务器命令表匹配redisCommand结构中的name字段</li>
<li>查询到命令后获取其执行方法，属性等，将命令执行方法保存在客户端cmd字段中</li>
</ol>
</li>
<li><p>服务器根据执行命令，并返回处理后数据</p>
</li>
<li><p>客户端接收到服务器处理回复</p>
</li>
</ol>
<blockquote>
<p>命令执行时会根据其sflag标志和服务器设置有不同的处理操作，具体情况可看源码</p>
</blockquote>
<h3 id="3-Redis周期性任务"><a href="#3-Redis周期性任务" class="headerlink" title="3. Redis周期性任务"></a>3. Redis周期性任务</h3><p>服务器为了维护自身资源，默认每100毫秒执行一次周期性任务serverCron()，主要负责删除过期键、服务器状态监控、更新统计信息、渐进式rehash、触发BGSAVE/AOF重写并处理子进程中断、从节点复制重连等等。</p>
<h4 id="3-1-更新服务器时间缓存"><a href="#3-1-更新服务器时间缓存" class="headerlink" title="3.1 更新服务器时间缓存"></a>3.1 更新服务器时间缓存</h4><p>Redis服务器很多功能需要获取系统当前时间，该系统调用需要消耗一定的CPU时间，对某些时间精度要求不高的功能我们可以在serverCron()中获取系统时间后缓存下来，可以有效的减少系统调用次数，服务器状态中unixtime和mstime属性用于存储时间缓存。</p>
<p>对于日志打印、更新服务器LRU时钟等任务可以使用服务器缓冲时间；对于过期键的检测、慢查询日志等需要高精度时间任务来说，需要重新系统调用获取时间来计算。</p>
<h4 id="3-2-处理SIGTERM信号"><a href="#3-2-处理SIGTERM信号" class="headerlink" title="3.2 处理SIGTERM信号"></a>3.2 处理SIGTERM信号</h4><p>启动服务器时，Redis会设置SIGTERM信号处理函数，当服务器接收到SIGTERM信号时，会开启shutdown_asap标识。serverCron()函数中，每次都会检测该标识，如果设置该标识，服务器会安全关闭，并记录日志。</p>
<h4 id="3-3-客户端资源管理clientsCron"><a href="#3-3-客户端资源管理clientsCron" class="headerlink" title="3.3 客户端资源管理clientsCron()"></a>3.3 客户端资源管理clientsCron()</h4><p>serverCron()函数每次执行都会调用clientsCron函数，因为函数每秒调用server.hz(默认10)，为了确保每个客户端至少执行一秒，所以迭代次数至少为numclients/server.hz，该函数执行以下检查：</p>
<ul>
<li>如果客户端与服务器连接超时，那么释放该客户端</li>
<li>如果客户端输入缓冲区超过一定限制，则重新分配缓存区的内存空间，确保没有浪费</li>
</ul>
<h4 id="3-4-管理数据库资源databaseCron"><a href="#3-4-管理数据库资源databaseCron" class="headerlink" title="3.4 管理数据库资源databaseCron()"></a>3.4 管理数据库资源databaseCron()</h4><p>serverCron()函数每次执行会调用databaseCron()函数，该函数会对数据库进行检查，删除过期键，resize，rehash等操作。</p>
<ul>
<li>主节点则开启过期键自动删除功能，从节点直接删除过期键</li>
<li>内存碎片整理</li>
<li>如果服务器为进行AOF或RDB，则进行Rehash和Resize</li>
</ul>
<h4 id="3-5-持久化记录"><a href="#3-5-持久化记录" class="headerlink" title="3.5 持久化记录"></a>3.5 持久化记录</h4><p>如果服务器没有RDB或AOF持久正在进行，那么开启后台的AOF重写任务；如果有RDB或AOF，则等待子进程信号，如果接收到信号说明持久化已完成，否则表示未完成。</p>
<blockquote>
<p>即使AOF重写错误，也需要刷新AOF缓冲区</p>
</blockquote>
<h4 id="3-6-更新信息并记录日志"><a href="#3-6-更新信息并记录日志" class="headerlink" title="3.6 更新信息并记录日志"></a>3.6 更新信息并记录日志</h4><ul>
<li>更新服务器每秒执行命令次数</li>
<li>更新LRU时钟</li>
<li>更新内存使用峰值</li>
<li>记录非空数据库日志</li>
<li>非哨兵模式服务器，记录客户端连接日志</li>
</ul>
<h4 id="3-7-其他一些任务"><a href="#3-7-其他一些任务" class="headerlink" title="3.7 其他一些任务"></a>3.7 其他一些任务</h4><ul>
<li><p>异步关闭需要关闭的客户端</p>
</li>
<li><p>如果需要解除客户端暂停状态</p>
</li>
<li><p>周期性复制任务</p>
</li>
<li><p>集群模式下，集群周期性任务</p>
</li>
<li><p>哨兵模式下任务</p>
</li>
<li><p>清理sockets连接</p>
</li>
</ul>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>周期性任务</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务器周期任务, 每秒调用server.hz次</span></span><br><span class="line"><span class="comment"> * 需要执行一些异步任务：</span></span><br><span class="line"><span class="comment"> *   - 主动删除过期键集合(也可以在读操作时懒删除)</span></span><br><span class="line"><span class="comment"> *   - 软件监控，🐶看门狗🐶</span></span><br><span class="line"><span class="comment"> *   - 更新统计信息</span></span><br><span class="line"><span class="comment"> *   - 渐进式rehash</span></span><br><span class="line"><span class="comment"> *   - 触发BGSAVE/AOF重写, 处理子进程中断</span></span><br><span class="line"><span class="comment"> *   - 不同类型客户端的超时时间</span></span><br><span class="line"><span class="comment"> *   - 复制重连</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 这里调用会每秒执行server.hz次，所以为了简便，我们使用一个宏run_with_period </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">serverCron</span><span class="params">(struct aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id, <span class="keyword">void</span> *clientData)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line">    UNUSED(id);</span><br><span class="line">    UNUSED(clientData);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Software watchdog: deliver the SIGALRM that will reach the signal</span></span><br><span class="line"><span class="comment">     * handler if we don't return here fast enough. */</span></span><br><span class="line">    <span class="comment">// 定期发送一个 SIGALRM 信号</span></span><br><span class="line">    <span class="keyword">if</span> (server.watchdog_period) watchdogScheduleSignal(server.watchdog_period);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Update the time cache. */</span></span><br><span class="line">    <span class="comment">// 更新服务器时间缓存</span></span><br><span class="line">    updateCachedTime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新统计数据</span></span><br><span class="line">    run_with_period(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="comment">// 命令执行次数</span></span><br><span class="line">        trackInstantaneousMetric(STATS_METRIC_COMMAND,server.stat_numcommands);</span><br><span class="line">        <span class="comment">// 网络读取字节数</span></span><br><span class="line">        trackInstantaneousMetric(STATS_METRIC_NET_INPUT,</span><br><span class="line">                server.stat_net_input_bytes);</span><br><span class="line">        <span class="comment">// 网络输出字节数</span></span><br><span class="line">        trackInstantaneousMetric(STATS_METRIC_NET_OUTPUT,</span><br><span class="line">                server.stat_net_output_bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We have just LRU_BITS bits per object for LRU information.</span></span><br><span class="line"><span class="comment">     * So we use an (eventually wrapping) LRU clock.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that even if the counter wraps it's not a big problem,</span></span><br><span class="line"><span class="comment">     * everything will still work but some object will appear younger</span></span><br><span class="line"><span class="comment">     * to Redis. However for this to happen a given object should never be</span></span><br><span class="line"><span class="comment">     * touched for all the time needed to the counter to wrap, which is</span></span><br><span class="line"><span class="comment">     * not likely.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that you can change the resolution altering the</span></span><br><span class="line"><span class="comment">     * LRU_CLOCK_RESOLUTION define. */</span></span><br><span class="line">    <span class="comment">// 服务器LRU时钟</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> lruclock = getLRUClock();</span><br><span class="line">    atomicSet(server.lruclock,lruclock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Record the max memory used since the server was started. */</span></span><br><span class="line">    <span class="comment">// 记录使用内存峰值</span></span><br><span class="line">    <span class="keyword">if</span> (zmalloc_used_memory() &gt; server.stat_peak_memory)</span><br><span class="line">        server.stat_peak_memory = zmalloc_used_memory();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Sample the RSS here since this is a relatively slow call. */</span></span><br><span class="line">    <span class="comment">// 记录常驻内存大小</span></span><br><span class="line">    server.resident_set_size = zmalloc_get_rss();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We received a SIGTERM, shutting down here in a safe way, as it is</span></span><br><span class="line"><span class="comment">     * not ok doing so inside the signal handler. */</span></span><br><span class="line">    <span class="comment">// 接收到SIGTERM信号，安全关闭服务器</span></span><br><span class="line">    <span class="keyword">if</span> (server.shutdown_asap) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prepareForShutdown(SHUTDOWN_NOFLAGS) == C_OK) <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"SIGTERM received but errors trying to shut down the server, check the logs for more information"</span>);</span><br><span class="line">        server.shutdown_asap = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Show some info about non-empty databases */</span></span><br><span class="line">    <span class="comment">// 记录非空数据库日志</span></span><br><span class="line">    run_with_period(<span class="number">5000</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> size, used, vkeys;</span><br><span class="line"></span><br><span class="line">            size = dictSlots(server.db[j].dict);</span><br><span class="line">            used = dictSize(server.db[j].dict);</span><br><span class="line">            vkeys = dictSize(server.db[j].expires);</span><br><span class="line">            <span class="keyword">if</span> (used || vkeys) &#123;</span><br><span class="line">                serverLog(LL_VERBOSE,<span class="string">"DB %d: %lld keys (%lld volatile) in %lld slots HT."</span>,j,used,vkeys,size);</span><br><span class="line">                <span class="comment">/* dictPrintStats(server.dict); */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Show information about connected clients */</span></span><br><span class="line">    <span class="comment">// 非哨兵模式服务器，记录客户端连接信息到日志中</span></span><br><span class="line">    <span class="keyword">if</span> (!server.sentinel_mode) &#123;</span><br><span class="line">        run_with_period(<span class="number">5000</span>) &#123;</span><br><span class="line">            serverLog(LL_VERBOSE,</span><br><span class="line">                <span class="string">"%lu clients connected (%lu slaves), %zu bytes in use"</span>,</span><br><span class="line">                listLength(server.clients)-listLength(server.slaves),</span><br><span class="line">                listLength(server.slaves),</span><br><span class="line">                zmalloc_used_memory());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We need to do a few operations on clients asynchronously. */</span></span><br><span class="line">    <span class="comment">// 客户端周期性任务</span></span><br><span class="line">    clientsCron();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle background operations on Redis databases. */</span></span><br><span class="line">    <span class="comment">// 数据库周期性任务</span></span><br><span class="line">    databasesCron();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start a scheduled AOF rewrite if this was requested by the user while</span></span><br><span class="line"><span class="comment">     * a BGSAVE was in progress. */</span></span><br><span class="line">    <span class="comment">// 如果没有RDB或AOF执行，那么开启后台AOF重写操作</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        server.aof_rewrite_scheduled)</span><br><span class="line">    &#123;</span><br><span class="line">        rewriteAppendOnlyFileBackground();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if a background saving or AOF rewrite in progress terminated. */</span></span><br><span class="line">    <span class="comment">// 如果正在进行RDB或AOF重写操作，那么等待子进程信号</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid != <span class="number">-1</span> || server.aof_child_pid != <span class="number">-1</span> ||</span><br><span class="line">        ldbPendingChildren())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> statloc;</span><br><span class="line">        <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((pid = wait3(&amp;statloc,WNOHANG,<span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> exitcode = WEXITSTATUS(statloc);</span><br><span class="line">            <span class="keyword">int</span> bysignal = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (WIFSIGNALED(statloc)) bysignal = WTERMSIG(statloc);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (pid == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"wait3() returned an error: %s. "</span></span><br><span class="line">                    <span class="string">"rdb_child_pid = %d, aof_child_pid = %d"</span>,</span><br><span class="line">                    strerror(errno),</span><br><span class="line">                    (<span class="keyword">int</span>) server.rdb_child_pid,</span><br><span class="line">                    (<span class="keyword">int</span>) server.aof_child_pid);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.rdb_child_pid) &#123;</span><br><span class="line">                backgroundSaveDoneHandler(exitcode,bysignal);</span><br><span class="line">                <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) receiveChildInfo();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == server.aof_child_pid) &#123;</span><br><span class="line">                backgroundRewriteDoneHandler(exitcode,bysignal);</span><br><span class="line">                <span class="keyword">if</span> (!bysignal &amp;&amp; exitcode == <span class="number">0</span>) receiveChildInfo();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ldbRemoveChild(pid)) &#123;</span><br><span class="line">                    serverLog(LL_WARNING,</span><br><span class="line">                        <span class="string">"Warning, detected child with unmatched pid: %ld"</span>,</span><br><span class="line">                        (<span class="keyword">long</span>)pid);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            updateDictResizePolicy();</span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没有正在进行的RDB或AOF，那么检查是否需要执行</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* If there is not a background saving/rewrite in progress check if</span></span><br><span class="line"><span class="comment">         * we have to save/rewrite now. */</span></span><br><span class="line">         <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.saveparamslen; j++) &#123;</span><br><span class="line">            struct saveparam *sp = server.saveparams+j;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Save if we reached the given amount of changes,</span></span><br><span class="line"><span class="comment">             * the given amount of seconds, and if the latest bgsave was</span></span><br><span class="line"><span class="comment">             * successful or if, in case of an error, at least</span></span><br><span class="line"><span class="comment">             * CONFIG_BGSAVE_RETRY_DELAY seconds already elapsed. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.dirty &gt;= sp-&gt;changes &amp;&amp;</span><br><span class="line">                server.unixtime-server.lastsave &gt; sp-&gt;seconds &amp;&amp;</span><br><span class="line">                (server.unixtime-server.lastbgsave_try &gt;</span><br><span class="line">                 CONFIG_BGSAVE_RETRY_DELAY ||</span><br><span class="line">                 server.lastbgsave_status == C_OK))</span><br><span class="line">            &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"%d changes in %d seconds. Saving..."</span>,</span><br><span class="line">                    sp-&gt;changes, (<span class="keyword">int</span>)sp-&gt;seconds);</span><br><span class="line">                rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">                rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">                rdbSaveBackground(server.rdb_filename,rsiptr);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* Trigger an AOF rewrite if needed. */</span></span><br><span class="line">         <span class="comment">// 根据需要触发AOF</span></span><br><span class="line">         <span class="keyword">if</span> (server.aof_state == AOF_ON &amp;&amp;</span><br><span class="line">             server.rdb_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">             server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">             server.aof_rewrite_perc &amp;&amp;</span><br><span class="line">             server.aof_current_size &gt; server.aof_rewrite_min_size)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> base = server.aof_rewrite_base_size ?</span><br><span class="line">                            server.aof_rewrite_base_size : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> growth = (server.aof_current_size*<span class="number">100</span>/base) - <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">if</span> (growth &gt;= server.aof_rewrite_perc) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"Starting automatic rewriting of AOF on %lld%% growth"</span>,growth);</span><br><span class="line">                rewriteAppendOnlyFileBackground();</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AOF postponed flush: Try at every cron cycle if the slow fsync</span></span><br><span class="line"><span class="comment">     * completed. */</span></span><br><span class="line">    <span class="comment">// AOF缓冲区冲洗到磁盘中</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_flush_postponed_start) flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AOF write errors: in this case we have a buffer to flush as well and</span></span><br><span class="line"><span class="comment">     * clear the AOF error in case of success to make the DB writable again,</span></span><br><span class="line"><span class="comment">     * however to try every second is enough in case of 'hz' is set to</span></span><br><span class="line"><span class="comment">     * an higher frequency. */</span></span><br><span class="line">    <span class="comment">// 即使AOF重写错误，也刷新AOF缓冲区</span></span><br><span class="line">    run_with_period(<span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR)</span><br><span class="line">            flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Close clients that need to be closed asynchronous */</span></span><br><span class="line">    <span class="comment">// 异步关闭客户端</span></span><br><span class="line">    freeClientsInAsyncFreeQueue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clear the paused clients flag if needed. */</span></span><br><span class="line">    <span class="comment">// 如果需要解除客户端暂停状态</span></span><br><span class="line">    clientsArePaused(); <span class="comment">/* Don't check return value, just use the side effect.*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Replication cron function -- used to reconnect to master,</span></span><br><span class="line"><span class="comment">     * detect transfer failures, start background RDB transfers and so forth. */</span></span><br><span class="line">    <span class="comment">// 周期性复制任务</span></span><br><span class="line">    run_with_period(<span class="number">1000</span>) replicationCron();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run the Redis Cluster cron. */</span></span><br><span class="line">    <span class="comment">// 集群周期性任务</span></span><br><span class="line">    run_with_period(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.cluster_enabled) clusterCron();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run the Sentinel timer if we are in sentinel mode. */</span></span><br><span class="line">    <span class="comment">// 哨兵timer</span></span><br><span class="line">    run_with_period(<span class="number">100</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.sentinel_mode) sentinelTimer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Cleanup expired MIGRATE cached sockets. */</span></span><br><span class="line">    <span class="comment">// 清理socket链接</span></span><br><span class="line">    run_with_period(<span class="number">1000</span>) &#123;</span><br><span class="line">        migrateCloseTimedoutSockets();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start a scheduled BGSAVE if the corresponding flag is set. This is</span></span><br><span class="line"><span class="comment">     * useful when we are forced to postpone a BGSAVE because an AOF</span></span><br><span class="line"><span class="comment">     * rewrite is in progress.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note: this code must be after the replicationCron() call above so</span></span><br><span class="line"><span class="comment">     * make sure when refactoring this file to keep this order. This is useful</span></span><br><span class="line"><span class="comment">     * because we want to give priority to RDB savings for replication. */</span></span><br><span class="line">    <span class="comment">// 如果设置了相应标志，则启动预定的BGSAVE。</span></span><br><span class="line">    <span class="comment">// 这是非常有用的，当我们强制延迟BGSAVE，因为AOF重写正在执行</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_child_pid == <span class="number">-1</span> &amp;&amp; server.aof_child_pid == <span class="number">-1</span> &amp;&amp;</span><br><span class="line">        server.rdb_bgsave_scheduled &amp;&amp;</span><br><span class="line">        (server.unixtime-server.lastbgsave_try &gt; CONFIG_BGSAVE_RETRY_DELAY ||</span><br><span class="line">         server.lastbgsave_status == C_OK))</span><br><span class="line">    &#123;</span><br><span class="line">        rdbSaveInfo rsi, *rsiptr;</span><br><span class="line">        rsiptr = rdbPopulateSaveInfo(&amp;rsi);</span><br><span class="line">        <span class="keyword">if</span> (rdbSaveBackground(server.rdb_filename,rsiptr) == C_OK)</span><br><span class="line">            server.rdb_bgsave_scheduled = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 周期循环+1</span></span><br><span class="line">    server.cronloops++;</span><br><span class="line">    <span class="comment">// 默认100ms</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1000</span>/server.hz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>进入事件循环前调用</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis进入事件循环前被调用，准备文件描述符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">beforeSleep</span><span class="params">(struct aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    UNUSED(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Call the Redis Cluster before sleep function. Note that this function</span></span><br><span class="line"><span class="comment">     * may change the state of Redis Cluster (from ok to fail or vice versa),</span></span><br><span class="line"><span class="comment">     * so it's a good idea to call it before serving the unblocked clients</span></span><br><span class="line"><span class="comment">     * later in this function. */</span></span><br><span class="line">    <span class="comment">// 集群模式开启beforeSleep, 可能会改变redis集群的状态，</span></span><br><span class="line">    <span class="keyword">if</span> (server.cluster_enabled) clusterBeforeSleep();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Run a fast expire cycle (the called function will return</span></span><br><span class="line"><span class="comment">     * ASAP if a fast cycle is not needed). */</span></span><br><span class="line">    <span class="comment">// 主节点开启过期键删除，则以快速模式运行</span></span><br><span class="line">    <span class="keyword">if</span> (server.active_expire_enabled &amp;&amp; server.masterhost == <span class="literal">NULL</span>)</span><br><span class="line">        activeExpireCycle(ACTIVE_EXPIRE_CYCLE_FAST);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Send all the slaves an ACK request if at least one client blocked</span></span><br><span class="line"><span class="comment">     * during the previous event loop iteration. */</span></span><br><span class="line">    <span class="comment">// 如果在前一个事件循环迭代期间有客户端被阻塞，则向所有从节点发送ACK请求</span></span><br><span class="line">    <span class="keyword">if</span> (server.get_ack_from_slaves) &#123;</span><br><span class="line">        robj *argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构建参数</span></span><br><span class="line">        argv[<span class="number">0</span>] = createStringObject(<span class="string">"REPLCONF"</span>,<span class="number">8</span>);</span><br><span class="line">        argv[<span class="number">1</span>] = createStringObject(<span class="string">"GETACK"</span>,<span class="number">6</span>);</span><br><span class="line">        argv[<span class="number">2</span>] = createStringObject(<span class="string">"*"</span>,<span class="number">1</span>); <span class="comment">/* Not used argument. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 给从节点服务器发送请求</span></span><br><span class="line">        replicationFeedSlaves(server.slaves, server.slaveseldb, argv, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放构建的参数</span></span><br><span class="line">        decrRefCount(argv[<span class="number">0</span>]);</span><br><span class="line">        decrRefCount(argv[<span class="number">1</span>]);</span><br><span class="line">        decrRefCount(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清空标志</span></span><br><span class="line">        server.get_ack_from_slaves = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unblock all the clients blocked for synchronous replication</span></span><br><span class="line"><span class="comment">     * in WAIT. */</span></span><br><span class="line">    <span class="comment">// 解除所有等待WAIT命令而被阻塞的客户端</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.clients_waiting_acks))</span><br><span class="line">        processClientsWaitingReplicas();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if there are clients unblocked by modules that implement</span></span><br><span class="line"><span class="comment">     * blocking commands. */</span></span><br><span class="line">    <span class="comment">// 检查是否有模块阻塞命令解除阻塞客户端</span></span><br><span class="line">    moduleHandleBlockedClients();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Try to process pending commands for clients that were just unblocked. */</span></span><br><span class="line">    <span class="comment">// 处理非阻塞客户端的输入缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.unblocked_clients))</span><br><span class="line">        processUnblockedClients();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Write the AOF buffer on disk */</span></span><br><span class="line">    <span class="comment">// 将AOF缓冲区冲洗到磁盘中</span></span><br><span class="line">    flushAppendOnlyFile(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle writes with pending output buffers. */</span></span><br><span class="line">    <span class="comment">// 处理待写的输出缓冲区</span></span><br><span class="line">    handleClientsWithPendingWrites();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Before we are going to sleep, let the threads access the dataset by</span></span><br><span class="line"><span class="comment">     * releasing the GIL. Redis main thread will not touch anything at this</span></span><br><span class="line"><span class="comment">     * time. */</span></span><br><span class="line">    <span class="comment">// 在进入sleep之前，让线程释放GIL来访问数据集。</span></span><br><span class="line">    <span class="comment">// Redis主线程此时不会触及任何内容</span></span><br><span class="line">    <span class="keyword">if</span> (moduleCount()) moduleReleaseGIL();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/13/redis/19_客户端/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/13/redis/19_客户端/" itemprop="url">
                  Redis源码阅读(十九) 客户端
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-13 16:34:46 / 修改时间：16:34:48" itemprop="dateCreated datePublished" datetime="2018-09-13T16:34:46+08:00">2018-09-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis是经典C/S架构，一个服务器可以与多个客户端进行通信。Redis服务器工作在单进程单线程模式，但它通过I/O多路复用技术处理客户端请求实现了高并发。</p>
<h3 id="1-客户端定义"><a href="#1-客户端定义" class="headerlink" title="1. 客户端定义"></a>1. 客户端定义</h3><p>Redis客户端作为与服务器通信的媒介，保存了其必要的一些属性，要操作Redis服务器存储的内容，必须通过客户端与服务端进行通信才能修改。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis客户端结构</span></span><br><span class="line"><span class="comment"> * 保存着客户端的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">client</span> &#123;</span></span><br><span class="line">    <span class="comment">// 客户端识别id</span></span><br><span class="line">    <span class="keyword">uint64_t</span> id;            <span class="comment">/* Client incremental unique ID. */</span></span><br><span class="line">    <span class="comment">// 客户端socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;                 <span class="comment">/* Client socket. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向当前客户端选中的Redis数据库</span></span><br><span class="line">    redisDb *db;            <span class="comment">/* Pointer to currently SELECTed DB. */</span></span><br><span class="line">    <span class="comment">// 客户端名称</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME. */</span></span><br><span class="line">    <span class="comment">// 查询输入缓冲区</span></span><br><span class="line">    sds querybuf;           <span class="comment">/* Buffer we use to accumulate client queries. */</span></span><br><span class="line">    <span class="comment">// 如果是主节点，该缓冲区表示我们要复制给从节点的内容</span></span><br><span class="line">    sds pending_querybuf;   <span class="comment">/* If this is a master, this buffer represents the</span></span><br><span class="line"><span class="comment">                               yet not applied replication stream that we</span></span><br><span class="line"><span class="comment">                               are receiving from the master. */</span></span><br><span class="line">    <span class="comment">// 输入缓冲区峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size. */</span></span><br><span class="line">    <span class="comment">// 客户端当前命令参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;               <span class="comment">/* Num of arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 客户端当前命令参数</span></span><br><span class="line">    robj **argv;            <span class="comment">/* Arguments of current command. */</span></span><br><span class="line">    <span class="comment">// 保存客户端执行命令的记录</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span>  <span class="comment">/* Last command executed. */</span></span><br><span class="line">    <span class="comment">// 请求协议类型：PROTO_REQ_*, 内联或多条命令</span></span><br><span class="line">    <span class="keyword">int</span> reqtype;            <span class="comment">/* Request protocol type: PROTO_REQ_* */</span></span><br><span class="line">    <span class="comment">// 参数列表中未读取参数的数量</span></span><br><span class="line">    <span class="keyword">int</span> multibulklen;       <span class="comment">/* Number of multi bulk arguments left to read. */</span></span><br><span class="line">    <span class="comment">// 命令内容的长度</span></span><br><span class="line">    <span class="keyword">long</span> bulklen;           <span class="comment">/* Length of bulk argument in multi bulk request. */</span></span><br><span class="line">    <span class="comment">// 回复缓存列表，用于发送大于固定回复缓冲区的回复</span></span><br><span class="line">    <span class="built_in">list</span> *reply;            <span class="comment">/* List of reply objects to send to the client. */</span></span><br><span class="line">    <span class="comment">// 回复缓存列表对象的总字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list. */</span></span><br><span class="line">    <span class="comment">// 已发送的字节数</span></span><br><span class="line">    <span class="keyword">size_t</span> sentlen;         <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line">    <span class="comment">// 客户端创建时间</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;           <span class="comment">/* Client creation time. */</span></span><br><span class="line">    <span class="comment">// 客户端与服务器最后一次交互时间 </span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction; <span class="comment">/* Time of the last interaction, used for timeout */</span></span><br><span class="line">    <span class="comment">// 客户端输出缓冲区超过软性限制的时间，记录输出缓冲区第一次到达软性限制的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line">    <span class="comment">// 客户端状态标识</span></span><br><span class="line">    <span class="keyword">int</span> flags;              <span class="comment">/* Client flags: CLIENT_* macros. */</span></span><br><span class="line">    <span class="comment">// 认证标识，0表示已认证，1表示未认证</span></span><br><span class="line">    <span class="keyword">int</span> authenticated;      <span class="comment">/* When requirepass is non-NULL. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// =========&gt; 主从复制</span></span><br><span class="line">    <span class="comment">// 从节点复制状态</span></span><br><span class="line">    <span class="keyword">int</span> replstate;          <span class="comment">/* Replication state if this is a slave. */</span></span><br><span class="line">    <span class="comment">// ACK上设置从节点写处理</span></span><br><span class="line">    <span class="keyword">int</span> repl_put_online_on_ack; <span class="comment">/* Install slave write handler on ACK. */</span></span><br><span class="line">    <span class="comment">// 主节点传过来的RDB文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> repldbfd;           <span class="comment">/* Replication DB file descriptor. */</span></span><br><span class="line">    <span class="comment">// 主节点RDB文件偏移量</span></span><br><span class="line">    <span class="keyword">off_t</span> repldboff;        <span class="comment">/* Replication DB file offset. */</span></span><br><span class="line">    <span class="comment">// 主节点RDB文件大小</span></span><br><span class="line">    <span class="keyword">off_t</span> repldbsize;       <span class="comment">/* Replication DB file size. */</span></span><br><span class="line">    <span class="comment">// 主节点RDB文件头</span></span><br><span class="line">    sds replpreamble;       <span class="comment">/* Replication DB preamble. */</span></span><br><span class="line">    <span class="comment">// 主节点中读取的复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> read_reploff; <span class="comment">/* Read replication offset if this is a master. */</span></span><br><span class="line">    <span class="comment">// 主节点中应用的复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> reploff;      <span class="comment">/* Applied replication offset if this is a master. */</span></span><br><span class="line">    <span class="comment">// 通过ack接收到的复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> repl_ack_off; <span class="comment">/* Replication ack offset, if this is a slave. */</span></span><br><span class="line">    <span class="comment">// 接收到复制偏移量使用的时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> repl_ack_time;<span class="comment">/* Replication ack time, if this is a slave. */</span></span><br><span class="line">    <span class="comment">// FULLRESYNC回复从节点偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> psync_initial_offset; <span class="comment">/* FULLRESYNC reply offset other slaves</span></span><br><span class="line"><span class="comment">                                       copying this slave output buffer</span></span><br><span class="line"><span class="comment">                                       should use. */</span></span><br><span class="line">    <span class="comment">// master运行复制id</span></span><br><span class="line">    <span class="keyword">char</span> replid[CONFIG_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* Master replication ID (if master). */</span></span><br><span class="line">    <span class="comment">// 从节点端口号</span></span><br><span class="line">    <span class="keyword">int</span> slave_listening_port; <span class="comment">/* As configured with: SLAVECONF listening-port */</span></span><br><span class="line">    <span class="comment">// 从节点IP地址</span></span><br><span class="line">    <span class="keyword">char</span> slave_ip[NET_IP_STR_LEN]; <span class="comment">/* Optionally given by REPLCONF ip-address */</span></span><br><span class="line">    <span class="comment">// 从节点功能，按位OR</span></span><br><span class="line">    <span class="keyword">int</span> slave_capa;         <span class="comment">/* Slave capabilities: SLAVE_CAPA_* bitwise OR. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line">    <span class="comment">// 客户端阻塞类型</span></span><br><span class="line">    <span class="keyword">int</span> btype;              <span class="comment">/* Type of blocking op if CLIENT_BLOCKED. */</span></span><br><span class="line">    <span class="comment">// 客户端当前阻塞状态</span></span><br><span class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span></span><br><span class="line">    <span class="comment">// 上次写入全局复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line">    <span class="comment">// 客户端监控命令列表， MULTI/EXEC</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line">    <span class="comment">// 客户端订阅的渠道</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="comment">// 客户端订阅的模式</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    <span class="comment">// 被缓存的ID</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="comment">// 回复固定缓冲区的偏移量</span></span><br><span class="line">    <span class="keyword">int</span> bufpos;</span><br><span class="line">    <span class="comment">// 回复固定缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buf[PROTO_REPLY_CHUNK_BYTES];</span><br><span class="line">&#125; client;</span><br></pre></td></tr></table></figure>
<h4 id="1-1-套接字文件描述符-fd"><a href="#1-1-套接字文件描述符-fd" class="headerlink" title="1.1 套接字文件描述符 - fd"></a>1.1 套接字文件描述符 - fd</h4><p>根据客户端类型的不同，fd的值可以是-1或真实文件描述符。</p>
<ul>
<li>伪客户端：fd值为-1，这种客户端用于本地执行命令，如AOF文件加载或Lua脚本执行。</li>
<li>普通客户端：fd值为真实描述符值，这种客户端通过网络套接字与服务端通信，用于执行一般的命令。</li>
</ul>
<h3 id="1-2-客户端名称-name"><a href="#1-2-客户端名称-name" class="headerlink" title="1.2 客户端名称 - name"></a>1.2 客户端名称 - name</h3><p>默认情况下，连接到服务端的客户端没有名称，我们通过CLIENT SETNAME命令可以设置当前客户端的名称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过CLIENT list命令获取当前服务器连接的客户端</span></span><br><span class="line">127.0.0.1:6379&gt; CLIENT list</span><br><span class="line">id=3 addr=127.0.0.1:62087 fd=8 name= age=3 ... cmd=client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过CLIENT SETNAME 命令设置当前客户端名称</span></span><br><span class="line">127.0.0.1:6379&gt; CLIENT SETNAME xxx</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; CLIENT list</span><br><span class="line">id=3 addr=127.0.0.1:62087 fd=8 name=xxx age=33 ... cmd=client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过CLIENT GETNAME 获取当前客户端名称</span></span><br><span class="line">127.0.0.1:6379&gt; CLIENT GETNAME</span><br><span class="line"><span class="string">"xxx"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
<h4 id="1-3-标志-flags"><a href="#1-3-标志-flags" class="headerlink" title="1.3 标志 - flags"></a>1.3 标志 - flags</h4><p>客户端标志属性flags记录了客户端的角色，每一位都记录客户端的一种属性或状态。</p>
<table>
<thead>
<tr>
<th>第N位</th>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>CLIENT_SLAVE</td>
<td>客户端是从节点</td>
</tr>
<tr>
<td>1</td>
<td>CLIENT_MASTER</td>
<td>客户端是主节点</td>
</tr>
<tr>
<td>2</td>
<td>CLIENT_MONITOR</td>
<td>客户端是监控从节点</td>
</tr>
<tr>
<td>3</td>
<td>CLIENT_MULTI</td>
<td>客户端正在执行事务</td>
</tr>
<tr>
<td>4</td>
<td>CLIENT_BLOCKED</td>
<td>客户端正在被BRPOP等命令阻塞</td>
</tr>
<tr>
<td>5</td>
<td>CLIENT_DIRTY_CAS</td>
<td>WATCH命令监控的键已经改变，EXEC将会失败</td>
</tr>
<tr>
<td>6</td>
<td>CLIENT_CLOSE_AFTER_REPLY</td>
<td>回复完成后关闭客户端</td>
</tr>
<tr>
<td>7</td>
<td>CLIENT_UNBLOCKED</td>
<td>客户端非阻塞，存储在server.unblocked_clients链表中</td>
</tr>
<tr>
<td>8</td>
<td>CLIENT_LUA</td>
<td>指向Lua脚本的客户端</td>
</tr>
<tr>
<td>9</td>
<td>CLIENT_ASKING</td>
<td>客户端发出了ASKING命令</td>
</tr>
<tr>
<td>10</td>
<td>CLIENT_CLOSE_ASAP</td>
<td>客户端需要尽快关闭</td>
</tr>
<tr>
<td>11</td>
<td>CLIENT_UNIX_SOCKET</td>
<td>通过unix domain连接的客户端</td>
</tr>
<tr>
<td>12</td>
<td>CLIENT_DIRTY_EXEC</td>
<td>事务命令入队时出错，EXEC将会失败</td>
</tr>
<tr>
<td>13</td>
<td>CLIENT_MASTER_FORCE_REPLY</td>
<td>主从服务器命令通信时，从节点要发送REPLICATION ACK给主节点，但主节点必须打开该标识强制回复</td>
</tr>
<tr>
<td>14</td>
<td>CLIENT_FORCE_AOF</td>
<td>默认情况下，AOF不会记录PUB/SUB等命令，该标志表示AOF也会记录PUBSUB命令和SCRIPT LOAD</td>
</tr>
<tr>
<td>15</td>
<td>CLIENT_FORCE_REPL</td>
<td>强制主节点将当前执行的命令复制给所有从节点。执行PUBSUB命令会打开客户端CLIENT_FORCE_AOF标志，执行SCRIPT LOAD命令会打开CLIENT_FORCE_AOF，CLIENT_FORCE_REPL两个标志</td>
</tr>
<tr>
<td>16</td>
<td>CLIENT_PRE_PSYNC</td>
<td>客户端代表的是低于Redis2.8版本的从节点，主节点不能使用PSYNC命令与该从节点同步</td>
</tr>
<tr>
<td>17</td>
<td>CLIENT_READONLY</td>
<td>集群客户端处于只读状态</td>
</tr>
<tr>
<td>18</td>
<td>CLIENT_PUBSUB</td>
<td>客户端处于PUB/SUB模式</td>
</tr>
<tr>
<td>19</td>
<td>CLIENT_PREVENT_AOF_PROP</td>
<td>客户端执行的命令不存储到AOF</td>
</tr>
<tr>
<td>20</td>
<td>CLIENT_PREVENT_REPL_PROP</td>
<td>客户端执行的命令不复制给从节点</td>
</tr>
<tr>
<td>19+20</td>
<td>CLIENT_PREVENT_PROP</td>
<td>客户端执行的敏力不存储到AOF且不复制给从节点</td>
</tr>
<tr>
<td>21</td>
<td>CLIENT_PENDING_WRITE</td>
<td>客户端有要发送的内容，但并未设置写处理程序</td>
</tr>
<tr>
<td>22</td>
<td>CLIENT_REPLY_OFF</td>
<td>不要发送回复给客户端</td>
</tr>
<tr>
<td>23</td>
<td>CLIENT_REPLY_SKIP_NEXT</td>
<td>跳过下一跳命令的回复</td>
</tr>
<tr>
<td>24</td>
<td>CLIENT_REPLY_SKIP</td>
<td>不要发送这条命令的回复</td>
</tr>
<tr>
<td>25</td>
<td>CLIENT_LUA_DEBUG</td>
<td>debug模式执行Lua脚本</td>
</tr>
<tr>
<td>26</td>
<td>CLIENT_LUA_DEBUG_SYNC</td>
<td>debug模式执行Lua脚本，但并不fork()子进程</td>
</tr>
<tr>
<td>27</td>
<td>CLIENT_MODULE</td>
<td>无连接的模块客户端</td>
</tr>
</tbody>
</table>
<h4 id="1-4-输入缓冲区-querybuf"><a href="#1-4-输入缓冲区-querybuf" class="headerlink" title="1.4 输入缓冲区 - querybuf"></a>1.4 输入缓冲区 - querybuf</h4><p>客户端的输入缓冲区用于保存客户端发送的命令请求，输入缓冲区的大小根据输入内容动态地扩大或缩小，最大不能超过client_max_querybuf_len(默认1G)，可以通过配置文件进行配置。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输入命令</span></span><br><span class="line">SET msg hello</span><br><span class="line"><span class="comment"># 输入缓冲区querybuf中则保存为</span></span><br><span class="line">*3\r\n<span class="variable">$3</span>\r\nSET\r\n<span class="variable">$3</span>\r\nmsg\r\n<span class="variable">$5</span>\r\nhello\r\n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>pending_querybuf缓冲区是存储主节点将接收到的命令复制给从节点的数据</p>
</blockquote>
<h4 id="1-5-输出缓冲区-list-amp-buf"><a href="#1-5-输出缓冲区-list-amp-buf" class="headerlink" title="1.5 输出缓冲区 - list &amp; buf"></a>1.5 输出缓冲区 - list &amp; buf</h4><p>服务端给客户端的回复会保存在客户端的输出缓冲区中，每个客户端有两个输出缓冲区，一个是固定的缓冲区，一个是可变的缓冲区：</p>
<ul>
<li>固定缓冲区-buf字节数组：保存长度较小的回复信息</li>
<li>可变缓冲区-list链表：保存长度较大的回复</li>
</ul>
<p>固定缓冲区buf的默认大小为16KB，当该空间用完或回复内容太多无法放进buf中，则会使用list可变缓冲区。</p>
<h3 id="2-源码剖析"><a href="#2-源码剖析" class="headerlink" title="2. 源码剖析"></a>2. 源码剖析</h3><ul>
<li>TCP连接处理程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TCP链接处理程序，创建一个客户端的连接状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">acceptCommonHandler</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> flags, <span class="keyword">char</span> *ip)</span> </span>&#123;</span><br><span class="line">    client *c;</span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">    <span class="keyword">if</span> ((c = createClient(fd)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,</span><br><span class="line">            <span class="string">"Error registering fd event for the new client: %s (fd=%d)"</span>,</span><br><span class="line">            strerror(errno),fd);</span><br><span class="line">        close(fd); <span class="comment">/* May be already closed, just ignore errors */</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If maxclient directive is set and this is one client more... close the</span></span><br><span class="line"><span class="comment">     * connection. Note that we create the client instead to check before</span></span><br><span class="line"><span class="comment">     * for this condition, since now the socket is already set in non-blocking</span></span><br><span class="line"><span class="comment">     * mode and we can send an error for free using the Kernel I/O */</span></span><br><span class="line">    <span class="comment">// 如果超过服务端规定的最大客户端数，那么写入错误，关闭客户端</span></span><br><span class="line">    <span class="keyword">if</span> (listLength(server.clients) &gt; server.maxclients) &#123;</span><br><span class="line">        <span class="keyword">char</span> *err = <span class="string">"-ERR max number of clients reached\r\n"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* That's a best effort error message, don't check write errors */</span></span><br><span class="line">        <span class="comment">// 写入错误信息</span></span><br><span class="line">        <span class="keyword">if</span> (write(c-&gt;fd,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录服务器拒绝的客户端数量</span></span><br><span class="line">        server.stat_rejected_conn++;</span><br><span class="line">        <span class="comment">// 释放客户端</span></span><br><span class="line">        freeClient(c);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the server is running in protected mode (the default) and there</span></span><br><span class="line"><span class="comment">     * is no password set, nor a specific interface is bound, we don't accept</span></span><br><span class="line"><span class="comment">     * requests from non loopback interfaces. Instead we try to explain the</span></span><br><span class="line"><span class="comment">     * user what to do to fix it if needed. */</span></span><br><span class="line">    <span class="comment">// 如果服务器以保护模式(默认)运行，并且没有设置密码，没有绑定特殊的接口，那么我们</span></span><br><span class="line">    <span class="comment">// 就不接收非回环接口的请求(也就是只接收本地请求)</span></span><br><span class="line">    <span class="keyword">if</span> (server.protected_mode &amp;&amp;</span><br><span class="line">        server.bindaddr_count == <span class="number">0</span> &amp;&amp;</span><br><span class="line">        server.requirepass == <span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">        !(flags &amp; CLIENT_UNIX_SOCKET) &amp;&amp;</span><br><span class="line">        ip != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(ip,<span class="string">"127.0.0.1"</span>) &amp;&amp; <span class="built_in">strcmp</span>(ip,<span class="string">"::1"</span>)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *err =</span><br><span class="line">                <span class="string">"-DENIED Redis is running in protected mode because protected "</span></span><br><span class="line">                <span class="string">"mode is enabled, no bind address was specified, no "</span></span><br><span class="line">                <span class="string">"authentication password is requested to clients. In this mode "</span></span><br><span class="line">                <span class="string">"connections are only accepted from the loopback interface. "</span></span><br><span class="line">                <span class="string">"If you want to connect from external computers to Redis you "</span></span><br><span class="line">                <span class="string">"may adopt one of the following solutions: "</span></span><br><span class="line">                <span class="string">"1) Just disable protected mode sending the command "</span></span><br><span class="line">                <span class="string">"'CONFIG SET protected-mode no' from the loopback interface "</span></span><br><span class="line">                <span class="string">"by connecting to Redis from the same host the server is "</span></span><br><span class="line">                <span class="string">"running, however MAKE SURE Redis is not publicly accessible "</span></span><br><span class="line">                <span class="string">"from internet if you do so. Use CONFIG REWRITE to make this "</span></span><br><span class="line">                <span class="string">"change permanent. "</span></span><br><span class="line">                <span class="string">"2) Alternatively you can just disable the protected mode by "</span></span><br><span class="line">                <span class="string">"editing the Redis configuration file, and setting the protected "</span></span><br><span class="line">                <span class="string">"mode option to 'no', and then restarting the server. "</span></span><br><span class="line">                <span class="string">"3) If you started the server manually just for testing, restart "</span></span><br><span class="line">                <span class="string">"it with the '--protected-mode no' option. "</span></span><br><span class="line">                <span class="string">"4) Setup a bind address or an authentication password. "</span></span><br><span class="line">                <span class="string">"NOTE: You only need to do one of the above things in order for "</span></span><br><span class="line">                <span class="string">"the server to start accepting connections from the outside.\r\n"</span>;</span><br><span class="line">            <span class="keyword">if</span> (write(c-&gt;fd,err,<span class="built_in">strlen</span>(err)) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="comment">/* Nothing to do, Just to avoid the warning... */</span></span><br><span class="line">            &#125;</span><br><span class="line">            server.stat_rejected_conn++;</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新服务器连接客户端数量</span></span><br><span class="line">    server.stat_numconnections++;</span><br><span class="line">    <span class="comment">// 客户端状态标志</span></span><br><span class="line">    c-&gt;flags |= flags;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">client *<span class="title">createClient</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    client *c = zmalloc(<span class="keyword">sizeof</span>(client));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* passing -1 as fd it is possible to create a non connected client.</span></span><br><span class="line"><span class="comment">     * This is useful since all the commands needs to be executed</span></span><br><span class="line"><span class="comment">     * in the context of a client. When commands are executed in other</span></span><br><span class="line"><span class="comment">     * contexts (for instance a Lua script) we need a non connected client. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fd == -1 表示创建的是一个无网络的伪客户端，执行Lua脚本时使用</span></span><br><span class="line">    <span class="comment">// fd != -1 表示创建有网络连接客户端</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 设置fd为非阻塞模式</span></span><br><span class="line">        anetNonBlock(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 禁止使用Nagle算法，客户端数据包应立即发送给服务端，TCP_NODELAY</span></span><br><span class="line">        anetEnableTcpNoDelay(<span class="literal">NULL</span>,fd);</span><br><span class="line">        <span class="comment">// 若开启tcpkeepalive, 设置SO_KEEPALIVE</span></span><br><span class="line">        <span class="keyword">if</span> (server.tcpkeepalive)</span><br><span class="line">            anetKeepAlive(<span class="literal">NULL</span>,fd,server.tcpkeepalive);</span><br><span class="line">        <span class="comment">// 创建一个文件事件，监听可读，并接收命令的输入</span></span><br><span class="line">        <span class="keyword">if</span> (aeCreateFileEvent(server.el,fd,AE_READABLE,</span><br><span class="line">            readQueryFromClient, c) == AE_ERR)</span><br><span class="line">        &#123;</span><br><span class="line">            close(fd);</span><br><span class="line">            zfree(c);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认0号数据库</span></span><br><span class="line">    selectDb(c,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">uint64_t</span> client_id;</span><br><span class="line">    <span class="comment">// 初始化客户端识别ID</span></span><br><span class="line">    atomicGetIncr(server.next_client_id,client_id,<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 初始化客户端属性值</span></span><br><span class="line">    <span class="comment">// 客户端识别id</span></span><br><span class="line">    c-&gt;id = client_id;</span><br><span class="line">    <span class="comment">// socket文件描述符</span></span><br><span class="line">    c-&gt;fd = fd;</span><br><span class="line">    <span class="comment">// 名称</span></span><br><span class="line">    c-&gt;name = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 回复缓冲区偏移量</span></span><br><span class="line">    c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 输入缓冲区</span></span><br><span class="line">    c-&gt;querybuf = sdsempty();</span><br><span class="line">    <span class="comment">// 主节点复制输入缓冲区</span></span><br><span class="line">    c-&gt;pending_querybuf = sdsempty();</span><br><span class="line">    <span class="comment">// 输入缓冲区峰值</span></span><br><span class="line">    c-&gt;querybuf_peak = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 请求协议类型</span></span><br><span class="line">    c-&gt;reqtype = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 参数个数</span></span><br><span class="line">    c-&gt;argc = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 参数</span></span><br><span class="line">    c-&gt;argv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 当前命令和上一次命令</span></span><br><span class="line">    c-&gt;cmd = c-&gt;lastcmd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 多条命令还未读取数量</span></span><br><span class="line">    c-&gt;multibulklen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 读取命令长度</span></span><br><span class="line">    c-&gt;bulklen = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 发送字节数</span></span><br><span class="line">    c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 客户端状态</span></span><br><span class="line">    c-&gt;flags = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建时间和上一次交互时间</span></span><br><span class="line">    c-&gt;ctime = c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    <span class="comment">// 认证状态</span></span><br><span class="line">    c-&gt;authenticated = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 复制状态</span></span><br><span class="line">    c-&gt;replstate = REPL_STATE_NONE;</span><br><span class="line">    c-&gt;repl_put_online_on_ack = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 复制偏移量</span></span><br><span class="line">    c-&gt;reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;read_reploff = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_off = <span class="number">0</span>;</span><br><span class="line">    c-&gt;repl_ack_time = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_listening_port = <span class="number">0</span>;</span><br><span class="line">    c-&gt;slave_ip[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    c-&gt;slave_capa = SLAVE_CAPA_NONE;</span><br><span class="line">    <span class="comment">// 创建回复链表</span></span><br><span class="line">    c-&gt;reply = listCreate();</span><br><span class="line">    <span class="comment">// 回复链表字节数</span></span><br><span class="line">    c-&gt;reply_bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 回复缓冲区软限制内存大小</span></span><br><span class="line">    c-&gt;obuf_soft_limit_reached_time = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置回复链表释放函数</span></span><br><span class="line">    listSetFreeMethod(c-&gt;reply,freeClientReplyValue);</span><br><span class="line">    <span class="comment">// 设置回复链表复制函数</span></span><br><span class="line">    listSetDupMethod(c-&gt;reply,dupClientReplyValue);</span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    c-&gt;btype = BLOCKED_NONE;</span><br><span class="line">    <span class="comment">// 阻塞状态超时</span></span><br><span class="line">    c-&gt;bpop.timeout = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 造成阻塞的键字典</span></span><br><span class="line">    c-&gt;bpop.keys = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 存储解除阻塞的键，保存PUSH的键</span></span><br><span class="line">    c-&gt;bpop.target = <span class="literal">NULL</span>;</span><br><span class="line">    c-&gt;bpop.numreplicas = <span class="number">0</span>;</span><br><span class="line">    c-&gt;bpop.reploffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 全局复制偏移量</span></span><br><span class="line">    c-&gt;woff = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 监控的键链表</span></span><br><span class="line">    c-&gt;watched_keys = listCreate();</span><br><span class="line">    <span class="comment">// 订阅频道</span></span><br><span class="line">    c-&gt;pubsub_channels = dictCreate(&amp;objectKeyPointerValueDictType,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 订阅模式</span></span><br><span class="line">    c-&gt;pubsub_patterns = listCreate();</span><br><span class="line">    <span class="comment">// 缓存的同辈</span></span><br><span class="line">    c-&gt;peerid = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 订阅发布模式的释放和比较函数</span></span><br><span class="line">    listSetFreeMethod(c-&gt;pubsub_patterns,decrRefCountVoid);</span><br><span class="line">    listSetMatchMethod(c-&gt;pubsub_patterns,listMatchObjects);</span><br><span class="line">    <span class="comment">// 客户端存储在服务器客户端链表中</span></span><br><span class="line">    <span class="keyword">if</span> (fd != <span class="number">-1</span>) listAddNodeTail(server.clients,c);</span><br><span class="line">    <span class="comment">// 初始化客户端事务状态</span></span><br><span class="line">    initClientMultiState(c);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>释放客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeClient</span><span class="params">(client *c)</span> </span>&#123;</span><br><span class="line">    listNode *ln;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If it is our master that's beging disconnected we should make sure</span></span><br><span class="line"><span class="comment">     * to cache the state to try a partial resynchronization later.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Note that before doing this we make sure that the client is not in</span></span><br><span class="line"><span class="comment">     * some unexpected state, by checking its flags. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是主节点，那么释放客户端需要进行备份，以方便重新启用</span></span><br><span class="line">    <span class="keyword">if</span> (server.master &amp;&amp; c-&gt;flags &amp; CLIENT_MASTER) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Connection with master lost."</span>);</span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; (CLIENT_CLOSE_AFTER_REPLY|</span><br><span class="line">                          CLIENT_CLOSE_ASAP|</span><br><span class="line">                          CLIENT_BLOCKED|</span><br><span class="line">                          CLIENT_UNBLOCKED)))</span><br><span class="line">        &#123;</span><br><span class="line">            replicationCacheMaster(c);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Log link disconnection with slave */</span></span><br><span class="line">    <span class="keyword">if</span> ((c-&gt;flags &amp; CLIENT_SLAVE) &amp;&amp; !(c-&gt;flags &amp; CLIENT_MONITOR)) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Connection with slave %s lost."</span>,</span><br><span class="line">            replicationGetSlaveName(c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free the query buffer */</span></span><br><span class="line">    <span class="comment">// 清空查询缓存</span></span><br><span class="line">    sdsfree(c-&gt;querybuf);</span><br><span class="line">    sdsfree(c-&gt;pending_querybuf);</span><br><span class="line">    c-&gt;querybuf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Deallocate structures used to block on blocking ops. */</span></span><br><span class="line">    <span class="comment">// 阻塞客户端需要解除阻塞</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_BLOCKED) unblockClient(c);</span><br><span class="line">    <span class="comment">// 释放阻塞键字典</span></span><br><span class="line">    dictRelease(c-&gt;bpop.keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* UNWATCH all the keys */</span></span><br><span class="line">    <span class="comment">// 清空监视的键</span></span><br><span class="line">    unwatchAllKeys(c);</span><br><span class="line">    listRelease(c-&gt;watched_keys);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unsubscribe from all the pubsub channels */</span></span><br><span class="line">    <span class="comment">// 退订所有频道</span></span><br><span class="line">    pubsubUnsubscribeAllChannels(c,<span class="number">0</span>);</span><br><span class="line">    pubsubUnsubscribeAllPatterns(c,<span class="number">0</span>);</span><br><span class="line">    dictRelease(c-&gt;pubsub_channels);</span><br><span class="line">    listRelease(c-&gt;pubsub_patterns);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Free data structures. */</span></span><br><span class="line">    <span class="comment">// 释放回复链表</span></span><br><span class="line">    listRelease(c-&gt;reply);</span><br><span class="line">    <span class="comment">// 释放参数列表</span></span><br><span class="line">    freeClientArgv(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Unlink the client: this will close the socket, remove the I/O</span></span><br><span class="line"><span class="comment">     * handlers, and remove references of the client from different</span></span><br><span class="line"><span class="comment">     * places where active clients may be referenced. */</span></span><br><span class="line">    <span class="comment">// 删除客户端，关闭socket，移除事件循环处理</span></span><br><span class="line">    unlinkClient(c);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Master/slave cleanup Case 1:</span></span><br><span class="line"><span class="comment">     * we lost the connection with a slave. */</span></span><br><span class="line">    <span class="comment">// 从节点客户端</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;replstate == SLAVE_STATE_SEND_BULK) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;repldbfd != <span class="number">-1</span>) close(c-&gt;repldbfd);</span><br><span class="line">            <span class="keyword">if</span> (c-&gt;replpreamble) sdsfree(c-&gt;replpreamble);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span> *l = (c-&gt;flags &amp; CLIENT_MONITOR) ? server.monitors : server.slaves;</span><br><span class="line">        ln = listSearchKey(l,c);</span><br><span class="line">        serverAssert(ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(l,ln);</span><br><span class="line">        <span class="comment">/* We need to remember the time when we started to have zero</span></span><br><span class="line"><span class="comment">         * attached slaves, as after some time we'll free the replication</span></span><br><span class="line"><span class="comment">         * backlog. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_SLAVE &amp;&amp; listLength(server.slaves) == <span class="number">0</span>)</span><br><span class="line">            server.repl_no_slaves_since = server.unixtime;</span><br><span class="line">        refreshGoodSlavesCount();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Master/slave cleanup Case 2:</span></span><br><span class="line"><span class="comment">     * we lost the connection with the master. */</span></span><br><span class="line">    <span class="comment">// 如果是主节点客户端，处理主从的断开</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_MASTER) replicationHandleMasterDisconnection();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If this client was scheduled for async freeing we need to remove it</span></span><br><span class="line"><span class="comment">     * from the queue. */</span></span><br><span class="line">    <span class="comment">// 如果客户端被设置为异步释放，我们将其从列表中删除</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_ASAP) &#123;</span><br><span class="line">        ln = listSearchKey(server.clients_to_close,c);</span><br><span class="line">        serverAssert(ln != <span class="literal">NULL</span>);</span><br><span class="line">        listDelNode(server.clients_to_close,ln);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Release other dynamically allocated client structure fields,</span></span><br><span class="line"><span class="comment">     * and finally release the client structure itself. */</span></span><br><span class="line">    <span class="comment">// 名字释放</span></span><br><span class="line">    <span class="keyword">if</span> (c-&gt;name) decrRefCount(c-&gt;name);</span><br><span class="line">    <span class="comment">// 释放列表参数</span></span><br><span class="line">    zfree(c-&gt;argv);</span><br><span class="line">    <span class="comment">// 释放事务状态</span></span><br><span class="line">    freeClientMultiState(c);</span><br><span class="line">    sdsfree(c-&gt;peerid);</span><br><span class="line">    zfree(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出缓冲区写给客户端</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">writeToClient</span><span class="params">(<span class="keyword">int</span> fd, client *c, <span class="keyword">int</span> handler_installed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten = <span class="number">0</span>, totwritten = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> objlen;</span><br><span class="line">    sds o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复缓冲区中有数据</span></span><br><span class="line">    <span class="keyword">while</span>(clientHasPendingReplies(c)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c-&gt;bufpos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 缓冲区数据写到fd</span></span><br><span class="line">            nwritten = write(fd,c-&gt;buf+c-&gt;sentlen,c-&gt;bufpos-c-&gt;sentlen);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If the buffer was sent, set bufpos to zero to continue with</span></span><br><span class="line"><span class="comment">             * the remainder of the reply. */</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">int</span>)c-&gt;sentlen == c-&gt;bufpos) &#123;</span><br><span class="line">                c-&gt;bufpos = <span class="number">0</span>;</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 固定缓冲区发送完成，则发送回复链表中的内容</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 获取回复链表第一条回复</span></span><br><span class="line">            o = listNodeValue(listFirst(c-&gt;reply));</span><br><span class="line">            objlen = sdslen(o);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 空对象跳过，并删除</span></span><br><span class="line">            <span class="keyword">if</span> (objlen == <span class="number">0</span>) &#123;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 写入到fd</span></span><br><span class="line">            nwritten = write(fd, o + c-&gt;sentlen, objlen - c-&gt;sentlen);</span><br><span class="line">            <span class="keyword">if</span> (nwritten &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            c-&gt;sentlen += nwritten;</span><br><span class="line">            totwritten += nwritten;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we fully sent the object on head go to the next one */</span></span><br><span class="line">            <span class="comment">// 发送完成，删除该结点</span></span><br><span class="line">            <span class="keyword">if</span> (c-&gt;sentlen == objlen) &#123;</span><br><span class="line">                listDelNode(c-&gt;reply,listFirst(c-&gt;reply));</span><br><span class="line">                c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">                c-&gt;reply_bytes -= objlen;</span><br><span class="line">                <span class="comment">/* If there are no longer objects in the list, we expect</span></span><br><span class="line"><span class="comment">                 * the count of reply bytes to be exactly zero. */</span></span><br><span class="line">                <span class="keyword">if</span> (listLength(c-&gt;reply) == <span class="number">0</span>)</span><br><span class="line">                    serverAssert(c-&gt;reply_bytes == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Note that we avoid to send more than NET_MAX_WRITES_PER_EVENT</span></span><br><span class="line"><span class="comment">         * bytes, in a single threaded server it's a good idea to serve</span></span><br><span class="line"><span class="comment">         * other clients as well, even if a very large request comes from</span></span><br><span class="line"><span class="comment">         * super fast link that is always able to accept data (in real world</span></span><br><span class="line"><span class="comment">         * scenario think about 'KEYS *' against the loopback interface).</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * However if we are over the maxmemory limit we ignore that and</span></span><br><span class="line"><span class="comment">         * just deliver as much data as it is possible to deliver.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Moreover, we also send as much as possible if the client is</span></span><br><span class="line"><span class="comment">         * a slave (otherwise, on high-speed traffic, the replication</span></span><br><span class="line"><span class="comment">         * buffer will grow indefinitely) */</span></span><br><span class="line">        <span class="comment">// 避免发送字节数大于NET_MAX_WRITES_PER_EVENT</span></span><br><span class="line">        <span class="comment">// 但是如果当前服务器的内存数超过maxmemory,则尽快执行写操作</span></span><br><span class="line">        <span class="keyword">if</span> (totwritten &gt; NET_MAX_WRITES_PER_EVENT &amp;&amp;</span><br><span class="line">            (server.maxmemory == <span class="number">0</span> ||</span><br><span class="line">             zmalloc_used_memory() &lt; server.maxmemory) &amp;&amp;</span><br><span class="line">            !(c-&gt;flags &amp; CLIENT_SLAVE)) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录字节数</span></span><br><span class="line">    server.stat_net_output_bytes += totwritten;</span><br><span class="line">    <span class="comment">// 写入失败</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">            nwritten = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_VERBOSE,</span><br><span class="line">                <span class="string">"Error writing to client: %s"</span>, strerror(errno));</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写入成功</span></span><br><span class="line">    <span class="keyword">if</span> (totwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* For clients representing masters we don't count sending data</span></span><br><span class="line"><span class="comment">         * as an interaction, since we always send REPLCONF ACK commands</span></span><br><span class="line"><span class="comment">         * that take some time to just fill the socket output buffer.</span></span><br><span class="line"><span class="comment">         * We just rely on data / pings received for timeout detection. */</span></span><br><span class="line">        <span class="keyword">if</span> (!(c-&gt;flags &amp; CLIENT_MASTER)) c-&gt;lastinteraction = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果客户端回复缓冲区已经没有数据，则发送完成</span></span><br><span class="line">    <span class="keyword">if</span> (!clientHasPendingReplies(c)) &#123;</span><br><span class="line">        c-&gt;sentlen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (handler_installed) aeDeleteFileEvent(server.el,c-&gt;fd,AE_WRITABLE);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Close connection after entire reply has been sent. */</span></span><br><span class="line">        <span class="keyword">if</span> (c-&gt;flags &amp; CLIENT_CLOSE_AFTER_REPLY) &#123;</span><br><span class="line">            freeClient(c);</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/10/redis/18_事件模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/10/redis/18_事件模型/" itemprop="url">
                  Redis源码阅读(十八) 事件模型
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-10 17:23:44 / 修改时间：17:24:08" itemprop="dateCreated datePublished" datetime="2018-09-10T17:23:44+08:00">2018-09-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis服务器是一个事件驱动程序，有两类事件需要处理：</p>
<ul>
<li>文件事件：网络客户端通过socket与服务器进行通信。</li>
<li>时间事件：服务器定时任务的执行。</li>
</ul>
<h3 id="1-事件循环"><a href="#1-事件循环" class="headerlink" title="1. 事件循环"></a>1. 事件循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line">    <span class="comment">// 目前注册的最大文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前追踪的最大文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于生成时间事件id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次执行时间事件的时间，用于检测系统时钟偏差</span></span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已注册的文件事件</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已就绪的文件事件</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件循环开关</span></span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理之前要执行的函数</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line">    <span class="comment">// 事件处理之后要执行的函数</span></span><br><span class="line">    aeBeforeSleepProc *aftersleep;</span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>
<p>Redis通过事件循环处理，实现了与客户端的交互和定时任务。</p>
<h3 id="2-文件事件"><a href="#2-文件事件" class="headerlink" title="2. 文件事件"></a>2. 文件事件</h3><p>Redis的文件事件处理基于Reactor模式。</p>
<h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeFileEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">// 文件事件类型</span></span><br><span class="line">    <span class="keyword">int</span> mask; <span class="comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读事件处理函数</span></span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写事件处理函数</span></span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line">&#125; aeFileEvent;</span><br></pre></td></tr></table></figure>
<p>服务器通过多路IO复用库来监听客户端的多个套接字，并根据不同的事件类型关联不同的处理函数，当事件就绪时，调用相应的处理函数。</p>
<h4 id="2-2-I-O多路复用库"><a href="#2-2-I-O多路复用库" class="headerlink" title="2.2 I/O多路复用库"></a>2.2 I/O多路复用库</h4><p>Redis中I/O多路复用由evport,kqueue,epoll和select实现，它们的性能从高到低依次排列。</p>
<ul>
<li>evport：Solaris 10 的新增加的特性，高效的事件处理库。</li>
<li>kqueue: FreeBSD系列的库。</li>
<li>epoll：Linux 2.6增加的特性。</li>
<li>select：通用的事件处理库。</li>
</ul>
<h3 id="3-时间事件"><a href="#3-时间事件" class="headerlink" title="3. 时间事件"></a>3. 时间事件</h3><h4 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> &#123;</span></span><br><span class="line">    <span class="comment">// 时间事件识别id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id; <span class="comment">/* time event identifier. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件到达时间</span></span><br><span class="line">    <span class="keyword">long</span> when_sec; <span class="comment">/* seconds */</span></span><br><span class="line">    <span class="keyword">long</span> when_ms; <span class="comment">/* milliseconds */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件处理函数</span></span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件释放函数</span></span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上个时间事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="comment">// 下个时间事件</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">aeTimeEvent</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; aeTimeEvent;</span><br></pre></td></tr></table></figure>
<p>Redis中，时间事件全部存储在一个无序链表timeEventHead中，每当时间事件执行时，服务器就遍历整个链表，查找所有已到达事件，并进行处理。</p>
<h4 id="3-2-serverCron函数"><a href="#3-2-serverCron函数" class="headerlink" title="3.2 serverCron函数"></a>3.2 serverCron函数</h4><p>Redis服务器需要定期对自身进行数据处理和状态检查，从而确保服务稳定运行。要执行的任务有：</p>
<ul>
<li>定期检查使用情况，进行rehash操作</li>
<li>清理过期键</li>
<li>关闭和清理无效客户端</li>
<li>AOF和RDB持久化</li>
<li>集群模式，主从数据同步</li>
</ul>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>初始化事件循环处理器</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件循环状态结构</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件事件数组</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化已就绪文件事件数组</span></span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 文件事件数组为空或者就绪事件数组为空返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化事件循环状态</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;aftersleep = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个epoll实例</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let's initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="comment">// 初始化监听事件 mask = AE_NONE, 表示为设置事件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>事件处理程序</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Process every pending time event, then every pending file event</span></span><br><span class="line"><span class="comment"> * (that may be registered by time event callbacks just processed).</span></span><br><span class="line"><span class="comment"> * Without special flags the function sleeps until some file event</span></span><br><span class="line"><span class="comment"> * fires, or when the next time event occurs (if any).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理所有已到达的时间事件和已就绪文件事件。</span></span><br><span class="line"><span class="comment"> * 如果不传入特殊falgs，那么函数睡眠直到文件事件就绪或时间事件到达。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If flags is 0, the function does nothing and returns.</span></span><br><span class="line"><span class="comment"> * flags = 0, 函数直接返回</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</span></span><br><span class="line"><span class="comment"> * flags == AE_ALL_EVENTS, 所有类型事件都会被处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_FILE_EVENTS set, file events are processed.</span></span><br><span class="line"><span class="comment"> * flags == AE_FILE_EVENTS, 所有文件事件会被处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_TIME_EVENTS set, time events are processed.</span></span><br><span class="line"><span class="comment"> * flags == AE_TIME_EVENTS, 所有时间事件会被处理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</span></span><br><span class="line"><span class="comment"> * the events that's possible to process without to wait are processed.</span></span><br><span class="line"><span class="comment"> * flags == AE_DONT_WAIT, 处理完事件后直接返回，不阻塞等待 </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_CALL_AFTER_SLEEP set, the aftersleep callback is called.</span></span><br><span class="line"><span class="comment"> * flags == AE_CALL_AFTER_SLEEP, 处理会调用回调函数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the number of events processed. */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件处理程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire. */</span></span><br><span class="line">    <span class="comment">// 注意：我们需要调用select函数, 虽然没有文件事件, 但是我们需要处理时间事件,</span></span><br><span class="line">    <span class="comment">// 用来在下一次事件前进行sleep</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果没有要处理的文件事件，或者设置了时间事件但未设置阻塞标识</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间事件，并且不阻塞</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            <span class="comment">// 获取最近到达的时间事件</span></span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123; <span class="comment">// 获取到时间事件</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取当前时间</span></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* How many milliseconds we need to wait for the next</span></span><br><span class="line"><span class="comment">             * time event to fire? */</span></span><br><span class="line">            <span class="comment">// 计算下一个时间时间到达要等待的时间</span></span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> ms =</span><br><span class="line">                (shortest-&gt;when_sec - now_sec)*<span class="number">1000</span> +</span><br><span class="line">                shortest-&gt;when_ms - now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                tvp-&gt;tv_sec = ms/<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_usec = (ms % <span class="number">1000</span>)*<span class="number">1000</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">                tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 未获取到时间事件</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// tvp时间设置为0，就不会阻塞</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 阻塞</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Call the multiplexing API, will return only on timeout or when</span></span><br><span class="line"><span class="comment">         * some event fires. */</span></span><br><span class="line">        <span class="comment">// 调用多路复用API，等待事件到达</span></span><br><span class="line">        <span class="comment">// 如果tvp为NULL，则阻塞，否则等待tvp设置的阻塞时间</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* After sleep callback. */</span></span><br><span class="line">        <span class="comment">// sleep等待事件后回调</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;aftersleep != <span class="literal">NULL</span> &amp;&amp; flags &amp; AE_CALL_AFTER_SLEEP)</span><br><span class="line">            eventLoop-&gt;aftersleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历就绪文件事件</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 获取当前就绪文件事件</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> fired = <span class="number">0</span>; <span class="comment">/* Number of events fired for current fd. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Normally we execute the readable event first, and the writable</span></span><br><span class="line"><span class="comment">             * event laster. This is useful as sometimes we may be able</span></span><br><span class="line"><span class="comment">             * to serve the reply of a query immediately after processing the</span></span><br><span class="line"><span class="comment">             * query.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 通常我们首先执行可读事件, 然后执行可写事件。</span></span><br><span class="line"><span class="comment">             * 这种方式很好, 因为有时候我们会在执行查询后立即回复</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * 但是，如果掩码中设置了AE_BARRIER，则是让我们做相反的事：</span></span><br><span class="line"><span class="comment">             * 绝对不要在可读之后进行可写事件。</span></span><br><span class="line"><span class="comment">             * 这种情况下，我们反转调用。</span></span><br><span class="line"><span class="comment">             * 例如，当我们想在beforeSlee()中做一些事情，就像同步文件到磁盘一样</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * However if AE_BARRIER is set in the mask, our application is</span></span><br><span class="line"><span class="comment">             * asking us to do the reverse: never fire the writable event</span></span><br><span class="line"><span class="comment">             * after the readable. In such a case, we invert the calls.</span></span><br><span class="line"><span class="comment">             * This is useful when, for instance, we want to do things</span></span><br><span class="line"><span class="comment">             * in the beforeSleep() hook, like fsynching a file to disk,</span></span><br><span class="line"><span class="comment">             * before replying to a client. */</span></span><br><span class="line">            <span class="keyword">int</span> invert = fe-&gt;mask &amp; AE_BARRIER;</span><br><span class="line"></span><br><span class="line">	    <span class="comment">/* Note the "fe-&gt;mask &amp; mask &amp; ..." code: maybe an already</span></span><br><span class="line"><span class="comment">             * processed event removed an element that fired and we still</span></span><br><span class="line"><span class="comment">             * didn't processed, so we check if the event is still valid.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * Fire the readable event if the call sequence is not</span></span><br><span class="line"><span class="comment">             * inverted. */</span></span><br><span class="line">            <span class="keyword">if</span> (!invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                fired++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Fire the writable event. */</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to invert the call, fire the readable event now</span></span><br><span class="line"><span class="comment">             * after the writable one. */</span></span><br><span class="line">            <span class="keyword">if</span> (invert &amp;&amp; fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!fired || fe-&gt;wfileProc != fe-&gt;rfileProc) &#123;</span><br><span class="line">                    fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">                    fired++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="comment">// 时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行时间事件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the system clock is moved to the future, and then set back to the</span></span><br><span class="line"><span class="comment">     * right value, time events may be delayed in a random way. Often this</span></span><br><span class="line"><span class="comment">     * means that scheduled operations will not be performed soon enough.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we try to detect system clock skews, and force all the time</span></span><br><span class="line"><span class="comment">     * events to be processed ASAP when this happens: the idea is that</span></span><br><span class="line"><span class="comment">     * processing events earlier is less dangerous than delaying them</span></span><br><span class="line"><span class="comment">     * indefinitely, and practice suggests it is. */</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新最后一次处理时间事件的时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件链表头结点</span></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    <span class="comment">// 最大的时间事件id</span></span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 遍历时间事件</span></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Remove events scheduled for deletion. */</span></span><br><span class="line">        <span class="comment">// 如果事件时间已经删除, 释放该事件，并移动指针</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == AE_DELETED_EVENT_ID) &#123;</span><br><span class="line">            aeTimeEvent *next = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;prev)</span><br><span class="line">                te-&gt;prev-&gt;next = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;next)</span><br><span class="line">                te-&gt;next-&gt;prev = te-&gt;prev;</span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line">            zfree(te);</span><br><span class="line">            te = next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Make sure we don't process time events created by time events in</span></span><br><span class="line"><span class="comment">         * this iteration. Note that this check is currently useless: we always</span></span><br><span class="line"><span class="comment">         * add new timers on the head, however if we change the implementation</span></span><br><span class="line"><span class="comment">         * detail, this check may be useful again: we keep it here for future</span></span><br><span class="line"><span class="comment">         * defense. */</span></span><br><span class="line">        <span class="comment">// 如果时间事件id大于最大时间事件id，该事件不执行</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">        <span class="comment">// 如果当前时间大于或等于事件的执行时间，说明需要执行该事件</span></span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">// 执行事件</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            <span class="comment">// 时间事件处理次数+1</span></span><br><span class="line">            processed++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 该事件是否需要进行执行</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                <span class="comment">// 需要继续执行，则retval毫秒后进执行</span></span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 标记该事件需要删除</span></span><br><span class="line">                te-&gt;id = AE_DELETED_EVENT_ID;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/05/redis/17_AOF持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/05/redis/17_AOF持久化/" itemprop="url">
                  Redis源码阅读(十七) AOF持久化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-05 15:53:22 / 修改时间：15:53:24" itemprop="dateCreated datePublished" datetime="2018-09-05T15:53:22+08:00">2018-09-05</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis除了RDB持久化外，还提供了AOF持久化，AOF持久化通过保存Redis服务端执行的命令来记录数据库状态。</p>
<h3 id="1-AOF文件"><a href="#1-AOF文件" class="headerlink" title="1. AOF文件"></a>1. AOF文件</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AOF内容格式</span></span><br><span class="line">命令个数: *&lt;count&gt;\r\n</span><br><span class="line">命令内容: $&lt;length&gt;\r\n&lt;content&gt;\r\n</span><br><span class="line"></span><br><span class="line">如 <span class="string">"SET hello world"</span> 指令, count表示命令个数为<span class="number">3</span>，length表示当前命令的长度</span><br><span class="line"><span class="string">"*3\r\n$3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n"</span></span><br><span class="line">这样一条SET指令就如上面一样存储。</span><br></pre></td></tr></table></figure>
<p>Redis服务端存储着AOF相关的一些信息:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">     <span class="comment">/* AOF persistence */</span></span><br><span class="line">    <span class="comment">// 服务器AOF状态</span></span><br><span class="line">    <span class="keyword">int</span> aof_state;                  <span class="comment">/* AOF_(ON|OFF|WAIT_REWRITE) */</span></span><br><span class="line">    <span class="comment">// 服务器AOF的fsync策略</span></span><br><span class="line">    <span class="keyword">int</span> aof_fsync;                  <span class="comment">/* Kind of fsync() policy */</span></span><br><span class="line">    <span class="comment">// 服务器AOF文件名</span></span><br><span class="line">    <span class="keyword">char</span> *aof_filename;             <span class="comment">/* Name of the AOF file */</span></span><br><span class="line">    <span class="comment">// 如果有aof执行，则不进行fsync</span></span><br><span class="line">    <span class="keyword">int</span> aof_no_fsync_on_rewrite;    <span class="comment">/* Don't fsync if a rewrite is in prog. */</span></span><br><span class="line">    <span class="comment">// AOF增长比率，默认100</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_perc;           <span class="comment">/* Rewrite AOF if % growth is &gt; M and... */</span></span><br><span class="line">    <span class="comment">// AOF最小字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> aof_rewrite_min_size;     <span class="comment">/* the AOF file is at least N bytes. */</span></span><br><span class="line">    <span class="comment">// AOF初始字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> aof_rewrite_base_size;    <span class="comment">/* AOF size on latest startup or rewrite. */</span></span><br><span class="line">    <span class="comment">// AOF当前字节数</span></span><br><span class="line">    <span class="keyword">off_t</span> aof_current_size;         <span class="comment">/* AOF current size. */</span></span><br><span class="line">    <span class="comment">// AOF重写提上日程，BGSAVE完成立即执行</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_scheduled;      <span class="comment">/* Rewrite once BGSAVE terminates. */</span></span><br><span class="line">    <span class="comment">// AOF子进程pid</span></span><br><span class="line">    <span class="keyword">pid_t</span> aof_child_pid;            <span class="comment">/* PID if rewriting process */</span></span><br><span class="line">    <span class="comment">// AOF缓冲区链表</span></span><br><span class="line">    <span class="built_in">list</span> *aof_rewrite_buf_blocks;   <span class="comment">/* Hold changes during an AOF rewrite. */</span></span><br><span class="line">    <span class="comment">// AOF缓冲区</span></span><br><span class="line">    sds aof_buf;      <span class="comment">/* AOF buffer, written before entering the event loop */</span></span><br><span class="line">    <span class="comment">// AOF文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> aof_fd;       <span class="comment">/* File descriptor of currently selected AOF file */</span></span><br><span class="line">    <span class="comment">// AOF选中的db</span></span><br><span class="line">    <span class="keyword">int</span> aof_selected_db; <span class="comment">/* Currently selected DB in AOF */</span></span><br><span class="line">    <span class="comment">// 延迟执行flush操作的开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_flush_postponed_start; <span class="comment">/* UNIX time of postponed AOF flush */</span></span><br><span class="line">    <span class="comment">// 最后一次fsync的直接</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_last_fsync;            <span class="comment">/* UNIX time of last fsync() */</span></span><br><span class="line">    <span class="comment">// AOF执行最后时间</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_rewrite_time_last;   <span class="comment">/* Time used by last AOF rewrite run. */</span></span><br><span class="line">    <span class="comment">// AOF执行开始时间</span></span><br><span class="line">    <span class="keyword">time_t</span> aof_rewrite_time_start;  <span class="comment">/* Current AOF rewrite start time. */</span></span><br><span class="line">    <span class="comment">// AOF执行的状态</span></span><br><span class="line">    <span class="keyword">int</span> aof_lastbgrewrite_status;   <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line">    <span class="comment">// 延迟fsync的次数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> aof_delayed_fsync;  <span class="comment">/* delayed AOF fsync() counter */</span></span><br><span class="line">    <span class="comment">// 重写时是否开启增量式同步，每次写入AOF_AUTOSYNC_BYTES个字节，就执行一次同步</span></span><br><span class="line">    <span class="keyword">int</span> aof_rewrite_incremental_fsync;<span class="comment">/* fsync incrementally while rewriting? */</span></span><br><span class="line">    <span class="comment">// 上一次AOF操作状态</span></span><br><span class="line">    <span class="keyword">int</span> aof_last_write_status;      <span class="comment">/* C_OK or C_ERR */</span></span><br><span class="line">    <span class="comment">// 删一次AOF操作错误</span></span><br><span class="line">    <span class="keyword">int</span> aof_last_write_errno;       <span class="comment">/* Valid if aof_last_write_status is ERR */</span></span><br><span class="line">    <span class="keyword">int</span> aof_load_truncated;         <span class="comment">/* Don't stop on unexpected AOF EOF. */</span></span><br><span class="line">    <span class="keyword">int</span> aof_use_rdb_preamble;       <span class="comment">/* Use RDB preamble on AOF rewrites. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* AOF pipes used to communicate between parent and child during rewrite. */</span></span><br><span class="line">    <span class="comment">// 进程通信文件描述描述符，管道</span></span><br><span class="line">    <span class="keyword">int</span> aof_pipe_write_data_to_child;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_read_data_from_parent;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_write_ack_to_parent;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_read_ack_from_child;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_write_ack_to_child;</span><br><span class="line">    <span class="keyword">int</span> aof_pipe_read_ack_from_parent;</span><br><span class="line">    <span class="keyword">int</span> aof_stop_sending_diff;     <span class="comment">/* If true stop sending accumulated diffs</span></span><br><span class="line"><span class="comment">                                      to child process. */</span></span><br><span class="line">    <span class="comment">// 保存子进程AOF时累积数据的sds</span></span><br><span class="line">    sds aof_child_diff;             <span class="comment">/* AOF diff accumulator child side. */</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-AOF持久化"><a href="#2-AOF持久化" class="headerlink" title="2. AOF持久化"></a>2. AOF持久化</h3><p>AOF持久化功能分为追加、写入文件、同步磁盘三个步骤。</p>
<h4 id="2-1-命令追加"><a href="#2-1-命令追加" class="headerlink" title="2.1 命令追加"></a>2.1 命令追加</h4><p>当Redis服务器AOF功能开启情况下，服务器执行完一条写命令之后，会将该条命令以AOF格式追加到服务器的AOF缓冲区中。</p>
<ol>
<li>判断追加命令是否为当前选中数据库，如果不是，则追加SELECT指令</li>
<li>根据不同命令类型分别进行处理，生成AOF格式内容</li>
<li>AOF开启状态，将追加到server.aof_buf服务器AOF缓冲区中</li>
<li>如果有AOF子进程正在进行，那么也追加到AOF重写缓冲区中</li>
</ol>
<h4 id="2-2-写入文件和同步磁盘"><a href="#2-2-写入文件和同步磁盘" class="headerlink" title="2.2 写入文件和同步磁盘"></a>2.2 写入文件和同步磁盘</h4><p>Redis服务器进程是一个事件循环，文件事件负责接收客户端的命令请求，以及回复客户端，而时间事件负责执行定时任务，服务器在每次结束事件循环之前，会调用flushAppendOnlyFile函数，判断是否将AOF缓冲区内容写入到AOF文件中。</p>
<p>AOF缓冲区内容写入到文件后是否进行AOF同步有三种策略：</p>
<table>
<thead>
<tr>
<th>aof_fsync选项</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>AOF_FSYNC_NO</td>
<td>目前为未使用，表示不手动执行fsync，等待操作系统执行</td>
</tr>
<tr>
<td>AOF_FSYNC_ALWAYS</td>
<td>立即同步到磁盘。</td>
</tr>
<tr>
<td>AOF_FSYNC_EVERYSEC</td>
<td>每秒同步一次，该策略下如果后台后fsync执行，那么我们延迟flush操作，最多延迟2秒钟。因为linux上的write(2)操作会被后台的fsync阻塞。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>为了提高文件写入效率，用于调用write函数写入文件时，会将数据写入到内存缓冲区，等待缓冲区被填满或手动执行同步时，才会将内容中同步到磁盘中。</p>
</blockquote>
<h3 id="3-AOF载入"><a href="#3-AOF载入" class="headerlink" title="3. AOF载入"></a>3. AOF载入</h3><p>AOF文件中保存了服务端执行的命令，所以只要执行这些命令，那么服务器的状态就可以被还原。</p>
<ol>
<li>创建一个不带网络连接的伪客户端，因为Redis命令只能在客户端中执行</li>
<li>循环从AOF文件中读取并解析指令，并在伪客户端中执行</li>
</ol>
<p>执行完AOF命令，服务器就还原到了之前的状态。</p>
<blockquote>
<p>服务器在AOF载入阶段，会间歇性处理网络客户端发送的请求，能执行的只有PUBSUB等指令</p>
</blockquote>
<h3 id="4-AOF重写"><a href="#4-AOF重写" class="headerlink" title="4. AOF重写"></a>4. AOF重写</h3><p>AOF持久化是通过保存命令来记录数据库状态，但随着运行时间的延迟，指令的数量会越来越大，而AOF文件体积随着也会变得很大，所以我们通过AOF重写，来减小AOF文件的大小。AOF重写是检查当前数据状态，然后生成新的指令，写入到AOF文件，以这种方式来减少命令数量。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端执行以下命令</span></span><br><span class="line">redis&gt; RPUSH list 1 2</span><br><span class="line">redis&gt; RPUSH list 3 4</span><br><span class="line">redis&gt; RPUSH list 5 6</span><br><span class="line">redis&gt; RPUSH list 7 8	<span class="comment"># 1, 2, 3, 4, 5, 6, 7, 8</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># AOF重写生成指令</span></span><br><span class="line">RPUSH list 1 2 3 4 5 6 7 8</span><br></pre></td></tr></table></figure>
<p>如果按照普通AOF保存，那么需要保存4条指令，而读取数据库状态后生产新的则只需要一条指令。</p>
<p>AOF重写会进行大量的写操作，所以调用这个函数会阻塞当前线程，而Redis使用单线程处理命令请求，所以AOF重写任务由创建新的子进程执行，这样子进程AOF重写期间，父进程仍然可以处理客户端请求。但这样也会存在一个问题，子进程执行AOF重写期间，父进程会处理请求，这会导致数据库不一致情况发生。</p>
<p>为了解决这种不一致，Redis服务器设置了一个AOF重写缓冲区，当redis服务器执行完命令后，会将这条命令写入AOF缓冲区和AOF重写缓冲区。当子进程AOF重写完成后，向父进程发送一个信号，父进程接收到该信号会调用信号处理函数，将AOF重写缓冲区中的所有内容写入到子进程处理的AOF文件中，这时新AOF文件保存的数据库状态与当前服务器一致。</p>
<ol>
<li><p>用户调用BGREWRITEAOF</p>
</li>
<li><p>Redis调用rewriteAppendOnlyFileBackground()函数fork子进程</p>
<p>a. 子进程在临时文件中进行AOF重写</p>
<p>b. 父进程累积计算差异，追加到AOF重写缓冲区server.aof_rewrite_buf</p>
</li>
<li><p>2a完成后，子进程退出</p>
</li>
<li><p>父进程捕捉子进程信号，将AOF重新缓冲区中记录的差异追加到临时文件，临时文件改名替换真正的AOF文件。</p>
</li>
</ol>
<h3 id="5-源码剖析"><a href="#5-源码剖析" class="headerlink" title="5. 源码剖析"></a>5. 源码剖析</h3><ul>
<li>加载AOF文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">loadAppendOnlyFile</span><span class="params">(<span class="keyword">char</span> *filename)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">client</span> *<span class="title">fakeClient</span>;</span></span><br><span class="line">    FILE *fp = fopen(filename,<span class="string">"r"</span>);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redis_stat</span> <span class="title">sb</span>;</span></span><br><span class="line">    <span class="keyword">int</span> old_aof_state = server.aof_state;</span><br><span class="line">    <span class="keyword">long</span> loops = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">off_t</span> valid_up_to = <span class="number">0</span>; <span class="comment">/* Offset of latest well-formed command loaded. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Fatal error: can't open the append log file for reading: %s"</span>,strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Handle a zero-length AOF file as a special case. An emtpy AOF file</span></span><br><span class="line"><span class="comment">     * is a valid AOF because an empty server with AOF enabled will create</span></span><br><span class="line"><span class="comment">     * a zero length file at startup, that will remain like that if no write</span></span><br><span class="line"><span class="comment">     * operation is received. */</span></span><br><span class="line">    <span class="comment">// 检查文件正确性</span></span><br><span class="line">    <span class="keyword">if</span> (fp &amp;&amp; redis_fstat(fileno(fp),&amp;sb) != <span class="number">-1</span> &amp;&amp; sb.st_size == <span class="number">0</span>) &#123;</span><br><span class="line">        server.aof_current_size = <span class="number">0</span>;</span><br><span class="line">        fclose(fp);</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Temporarily disable AOF, to prevent EXEC from feeding a MULTI</span></span><br><span class="line"><span class="comment">     * to the same file we're about to read. */</span></span><br><span class="line">    <span class="comment">// 临时关闭AOF，防止执行MULTI时，EXEC命令被同步到AOF文件中</span></span><br><span class="line">    server.aof_state = AOF_OFF;</span><br><span class="line"></span><br><span class="line">    fakeClient = createFakeClient();</span><br><span class="line">    <span class="comment">// 设置服务器状态</span></span><br><span class="line">    startLoading(fp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if this AOF file has an RDB preamble. In that case we need to</span></span><br><span class="line"><span class="comment">     * load the RDB file and later continue loading the AOF tail. */</span></span><br><span class="line">    <span class="keyword">char</span> sig[<span class="number">5</span>]; <span class="comment">/* "REDIS" */</span></span><br><span class="line">    <span class="keyword">if</span> (fread(sig,<span class="number">1</span>,<span class="number">5</span>,fp) != <span class="number">5</span> || <span class="built_in">memcmp</span>(sig,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* No RDB preamble, seek back at 0 offset. */</span></span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* RDB preamble. Pass loading the RDB functions. */</span></span><br><span class="line">        rio rdb;</span><br><span class="line"></span><br><span class="line">        serverLog(LL_NOTICE,<span class="string">"Reading RDB preamble from AOF file..."</span>);</span><br><span class="line">        <span class="keyword">if</span> (fseek(fp,<span class="number">0</span>,SEEK_SET) == <span class="number">-1</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        rioInitWithFile(&amp;rdb,fp);</span><br><span class="line">        <span class="keyword">if</span> (rdbLoadRio(&amp;rdb,<span class="literal">NULL</span>,<span class="number">1</span>) != C_OK) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Error reading the RDB preamble of the AOF file, AOF loading aborted"</span>);</span><br><span class="line">            <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Reading the remaining AOF tail..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Read the actual AOF file, in REPL format, command by command. */</span></span><br><span class="line">    <span class="comment">// 读取AOF文件，并执行命令</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> argc, j;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">        robj **argv;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">128</span>];</span><br><span class="line">        sds argsds;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Serve the clients from time to time */</span></span><br><span class="line">        <span class="comment">// 间隔性处理客户端发送的请求</span></span><br><span class="line">        <span class="comment">// 服务器处于载入状态，能执行的只有PUBSUB</span></span><br><span class="line">        <span class="keyword">if</span> (!(loops++ % <span class="number">1000</span>)) &#123;</span><br><span class="line">            loadingProgress(ftello(fp));</span><br><span class="line">            processEventsWhileBlocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读入文件到缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (feof(fp))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 解析文件</span></span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'*'</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">        <span class="keyword">if</span> (buf[<span class="number">1</span>] == <span class="string">'\0'</span>) <span class="keyword">goto</span> readerr;</span><br><span class="line">        argc = atoi(buf+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (argc &lt; <span class="number">1</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line"></span><br><span class="line">        argv = zmalloc(<span class="keyword">sizeof</span>(robj*)*argc);</span><br><span class="line">        fakeClient-&gt;argc = argc;</span><br><span class="line">        fakeClient-&gt;argv = argv;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 挨个解析命令</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (fgets(buf,<span class="keyword">sizeof</span>(buf),fp) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (buf[<span class="number">0</span>] != <span class="string">'$'</span>) <span class="keyword">goto</span> fmterr;</span><br><span class="line">            len = strtol(buf+<span class="number">1</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            argsds = sdsnewlen(<span class="literal">NULL</span>,len);</span><br><span class="line">            <span class="keyword">if</span> (len &amp;&amp; fread(argsds,len,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                sdsfree(argsds);</span><br><span class="line">                fakeClient-&gt;argc = j; <span class="comment">/* Free up to j-1. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr;</span><br><span class="line">            &#125;</span><br><span class="line">            argv[j] = createObject(OBJ_STRING,argsds);</span><br><span class="line">            <span class="keyword">if</span> (fread(buf,<span class="number">2</span>,<span class="number">1</span>,fp) == <span class="number">0</span>) &#123;</span><br><span class="line">                fakeClient-&gt;argc = j+<span class="number">1</span>; <span class="comment">/* Free up to j. */</span></span><br><span class="line">                freeFakeClientArgv(fakeClient);</span><br><span class="line">                <span class="keyword">goto</span> readerr; <span class="comment">/* discard CRLF */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Command lookup */</span></span><br><span class="line">        cmd = lookupCommand(argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">        <span class="keyword">if</span> (!cmd) &#123;</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Unknown command '%s' reading the append only file"</span>, (<span class="keyword">char</span>*)argv[<span class="number">0</span>]-&gt;ptr);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Run the command in the context of a fake client */</span></span><br><span class="line">        <span class="comment">// 执行命令</span></span><br><span class="line">        fakeClient-&gt;cmd = cmd;</span><br><span class="line">        cmd-&gt;proc(fakeClient);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* The fake client should not have a reply */</span></span><br><span class="line">        serverAssert(fakeClient-&gt;bufpos == <span class="number">0</span> &amp;&amp; listLength(fakeClient-&gt;reply) == <span class="number">0</span>);</span><br><span class="line">        <span class="comment">/* The fake client should never get blocked */</span></span><br><span class="line">        serverAssert((fakeClient-&gt;flags &amp; CLIENT_BLOCKED) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Clean up. Command code may have changed argv/argc so we use the</span></span><br><span class="line"><span class="comment">         * argv/argc of the client instead of the local variables. */</span></span><br><span class="line">        <span class="comment">// 释放命令和参数</span></span><br><span class="line">        freeFakeClientArgv(fakeClient);</span><br><span class="line">        fakeClient-&gt;cmd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (server.aof_load_truncated) valid_up_to = ftello(fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* This point can only be reached when EOF is reached without errors.</span></span><br><span class="line"><span class="comment">     * If the client is in the middle of a MULTI/EXEC, log error and quit. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient-&gt;flags &amp; CLIENT_MULTI) <span class="keyword">goto</span> uxeof;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过AOF加载完成</span></span><br><span class="line">loaded_ok: <span class="comment">/* DB loaded, cleanup and return C_OK to the caller. */</span></span><br><span class="line">    fclose(fp);</span><br><span class="line">    freeFakeClient(fakeClient);</span><br><span class="line">    server.aof_state = old_aof_state;</span><br><span class="line">    stopLoading();</span><br><span class="line">    aofUpdateCurrentSize();</span><br><span class="line">    server.aof_rewrite_base_size = server.aof_current_size;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 各种错误处理</span></span><br><span class="line"></span><br><span class="line">readerr: <span class="comment">/* Read error. If feof(fp) is true, fall through to unexpected EOF. */</span></span><br><span class="line">    <span class="keyword">if</span> (!feof(fp)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Unrecoverable error reading the append only file: %s"</span>, strerror(errno));</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">uxeof: <span class="comment">/* Unexpected AOF end of file. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_load_truncated) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"!!! Warning: short read while loading the AOF file !!!"</span>);</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"!!! Truncating the AOF at offset %llu !!!"</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>) valid_up_to);</span><br><span class="line">        <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span> || truncate(filename,valid_up_to) == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid_up_to == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Last valid command offset is invalid"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Error truncating the AOF file: %s"</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Make sure the AOF file descriptor points to the end of the</span></span><br><span class="line"><span class="comment">             * file after the truncate call. */</span></span><br><span class="line">            <span class="keyword">if</span> (server.aof_fd != <span class="number">-1</span> &amp;&amp; lseek(server.aof_fd,<span class="number">0</span>,SEEK_END) == <span class="number">-1</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Can't seek the end of the AOF file: %s"</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"AOF loaded anyway because aof-load-truncated is enabled"</span>);</span><br><span class="line">                <span class="keyword">goto</span> loaded_ok;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Unexpected end of file reading the append only file. You can: 1) Make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;. 2) Alternatively you can set the 'aof-load-truncated' configuration option to yes and restart the server."</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fmterr: <span class="comment">/* Format error. */</span></span><br><span class="line">    <span class="keyword">if</span> (fakeClient) freeFakeClient(fakeClient); <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Bad file format reading the append only file: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename&gt;"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AOF指令追加</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">feedAppendOnlyFile</span><span class="params">(struct redisCommand *cmd, <span class="keyword">int</span> dictid, robj **argv, <span class="keyword">int</span> argc)</span> </span>&#123;</span><br><span class="line">    sds buf = sdsempty();</span><br><span class="line">    robj *tmpargv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The DB this command was targeting is not the same as the last command</span></span><br><span class="line"><span class="comment">     * we appended. To issue a SELECT command is needed. */</span></span><br><span class="line">    <span class="comment">// SELECT 命令，确保数据库正确</span></span><br><span class="line">    <span class="keyword">if</span> (dictid != server.aof_selected_db) &#123;</span><br><span class="line">        <span class="keyword">char</span> seldb[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">snprintf</span>(seldb,<span class="keyword">sizeof</span>(seldb),<span class="string">"%d"</span>,dictid);</span><br><span class="line">        buf = sdscatprintf(buf,<span class="string">"*2\r\n$6\r\nSELECT\r\n$%lu\r\n%s\r\n"</span>,</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)<span class="built_in">strlen</span>(seldb),seldb);</span><br><span class="line">        server.aof_selected_db = dictid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EXPIRE, PEXPIRE, EXPIREAT命令</span></span><br><span class="line">    <span class="keyword">if</span> (cmd-&gt;proc == expireCommand || cmd-&gt;proc == pexpireCommand ||</span><br><span class="line">        cmd-&gt;proc == expireatCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate EXPIRE/PEXPIRE/EXPIREAT into PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SETEX 和 PSETEX命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setexCommand || cmd-&gt;proc == psetexCommand) &#123;</span><br><span class="line">        <span class="comment">/* Translate SETEX/PSETEX to SET and PEXPIREAT */</span></span><br><span class="line">        tmpargv[<span class="number">0</span>] = createStringObject(<span class="string">"SET"</span>,<span class="number">3</span>);</span><br><span class="line">        tmpargv[<span class="number">1</span>] = argv[<span class="number">1</span>];</span><br><span class="line">        tmpargv[<span class="number">2</span>] = argv[<span class="number">3</span>];</span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,tmpargv);</span><br><span class="line">        decrRefCount(tmpargv[<span class="number">0</span>]);</span><br><span class="line">        buf = catAppendOnlyExpireAtCommand(buf,cmd,argv[<span class="number">1</span>],argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// SET 命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd-&gt;proc == setCommand &amp;&amp; argc &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        robj *exarg = <span class="literal">NULL</span>, *pxarg = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Translate SET [EX seconds][PX milliseconds] to SET and PEXPIREAT */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,<span class="number">3</span>,argv);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">3</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"ex"</span>)) exarg = argv[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (!strcasecmp(argv[i]-&gt;ptr, <span class="string">"px"</span>)) pxarg = argv[i+<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        serverAssert(!(exarg &amp;&amp; pxarg));</span><br><span class="line">        <span class="keyword">if</span> (exarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.expireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               exarg);</span><br><span class="line">        <span class="keyword">if</span> (pxarg)</span><br><span class="line">            buf = catAppendOnlyExpireAtCommand(buf,server.pexpireCommand,argv[<span class="number">1</span>],</span><br><span class="line">                                               pxarg);</span><br><span class="line">        <span class="comment">// 其他命令</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* All the other commands don't need translation or need the</span></span><br><span class="line"><span class="comment">         * same translation already operated in the command vector</span></span><br><span class="line"><span class="comment">         * for the replication itself. */</span></span><br><span class="line">        buf = catAppendOnlyGenericCommand(buf,argc,argv);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Append to the AOF buffer. This will be flushed on disk just before</span></span><br><span class="line"><span class="comment">     * of re-entering the event loop, so before the client will get a</span></span><br><span class="line"><span class="comment">     * positive reply about the operation performed. */</span></span><br><span class="line">    <span class="comment">// 命令追加到AOF缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_state == AOF_ON)</span><br><span class="line">        server.aof_buf = sdscatlen(server.aof_buf,buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If a background append only file rewriting is in progress we want to</span></span><br><span class="line"><span class="comment">     * accumulate the differences between the child DB and the current one</span></span><br><span class="line"><span class="comment">     * in a buffer, so that when the child process will do its work we</span></span><br><span class="line"><span class="comment">     * can append the differences to the new append only file. */</span></span><br><span class="line">    <span class="comment">// 如果有AOF正在进行</span></span><br><span class="line">    <span class="comment">// 则追加到AOF重写缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span>)</span><br><span class="line">        aofRewriteBufferAppend((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)buf,sdslen(buf));</span><br><span class="line"></span><br><span class="line">    sdsfree(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>同步AOF到文件</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flushAppendOnlyFile</span><span class="params">(<span class="keyword">int</span> force)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> nwritten;</span><br><span class="line">    <span class="keyword">int</span> sync_in_progress = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">mstime_t</span> latency;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓冲区没有内容，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (sdslen(server.aof_buf) == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fsync策略为每秒进行</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC)</span><br><span class="line">        <span class="comment">// 是否有后台fsync正在执行</span></span><br><span class="line">        sync_in_progress = bioPendingJobsOfType(BIO_AOF_FSYNC) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每秒fsync，但不强制写入</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp; !force) &#123;</span><br><span class="line">        <span class="comment">/* With this append fsync policy we do background fsyncing.</span></span><br><span class="line"><span class="comment">         * If the fsync is still in progress we can try to delay</span></span><br><span class="line"><span class="comment">         * the write for a couple of seconds. */</span></span><br><span class="line">        <span class="comment">// 后台有在执行的fsync，我们可以延迟一两秒</span></span><br><span class="line">        <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">            <span class="keyword">if</span> (server.aof_flush_postponed_start == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/* No previous write postponing, remember that we are</span></span><br><span class="line"><span class="comment">                 * postponing the flush and return. */</span></span><br><span class="line">                <span class="comment">// 之前没有推迟过，则记录推迟时间</span></span><br><span class="line">                server.aof_flush_postponed_start = server.unixtime;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.unixtime - server.aof_flush_postponed_start &lt; <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">// 已经推迟过， 但未超过2秒，直接返回</span></span><br><span class="line">                <span class="comment">/* We were already waiting for fsync to finish, but for less</span></span><br><span class="line"><span class="comment">                 * than two seconds this is still ok. Postpone again. */</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* Otherwise fall trough, and go write since we can't wait</span></span><br><span class="line"><span class="comment">             * over two seconds. */</span></span><br><span class="line">            <span class="comment">// 有后台fsync执行，并且已经推迟了超过2秒，则执行写操作</span></span><br><span class="line">            server.aof_delayed_fsync++;</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            serverLog(LL_NOTICE,<span class="string">"Asynchronous AOF fsync is taking too long (disk is busy?). Writing the AOF buffer without waiting for fsync to complete, this may slow down Redis."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* We want to perform a single write. This should be guaranteed atomic</span></span><br><span class="line"><span class="comment">     * at least if the filesystem we are writing is a real physical one.</span></span><br><span class="line"><span class="comment">     * While this will save us against the server being killed I don't think</span></span><br><span class="line"><span class="comment">     * there is much to do about the whole server stopping for power problems</span></span><br><span class="line"><span class="comment">     * or alike */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行单个write操作，如果写入物理设备，那么操作应该是原子的</span></span><br><span class="line">    <span class="comment">// 但如果出现类似断电这样的故障，AOF文件也可能出现问题</span></span><br><span class="line">    <span class="comment">// 这是需要redis-check-aof来修复</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    latencyStartMonitor(latency);</span><br><span class="line">    <span class="comment">// AOF缓冲区写到AOF文件描述符</span></span><br><span class="line">    nwritten = aofWrite(server.aof_fd,server.aof_buf,sdslen(server.aof_buf));</span><br><span class="line">    <span class="comment">// 记录结束时间</span></span><br><span class="line">    latencyEndMonitor(latency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We want to capture different events for delayed writes:</span></span><br><span class="line"><span class="comment">     * when the delay happens with a pending fsync, or with a saving child</span></span><br><span class="line"><span class="comment">     * active, and when the above two conditions are missing.</span></span><br><span class="line"><span class="comment">     * We also use an additional event name to save all samples which is</span></span><br><span class="line"><span class="comment">     * useful for graphing / monitoring purposes. */</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sync_in_progress) &#123;</span><br><span class="line">        <span class="comment">// 后台fsync正在执行</span></span><br><span class="line">        <span class="comment">// 添加采样aof-write-pending-fsync</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-pending-fsync"</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// aof或rdb子进程在执行</span></span><br><span class="line">        <span class="comment">// 添加采样aof-write-active-child</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-active-child"</span>,latency);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则添加aof-write-alone采样</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-write-alone"</span>,latency);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 记录aof-write</span></span><br><span class="line">    latencyAddSampleIfNeeded(<span class="string">"aof-write"</span>,latency);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* We performed the write so reset the postponed flush sentinel to zero. */</span></span><br><span class="line">    <span class="comment">// 清除延迟write标识</span></span><br><span class="line">    server.aof_flush_postponed_start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入大小不相等</span></span><br><span class="line">    <span class="keyword">if</span> (nwritten != (<span class="keyword">ssize_t</span>)sdslen(server.aof_buf)) &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">time_t</span> last_write_error_log = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> can_log = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Limit logging rate to 1 line per AOF_WRITE_LOG_ERROR_RATE seconds. */</span></span><br><span class="line">        <span class="comment">// 日志记录频率限制在每行AOF_WRITE_LOG_ERROR_RATE秒</span></span><br><span class="line">        <span class="keyword">if</span> ((server.unixtime - last_write_error_log) &gt; AOF_WRITE_LOG_ERROR_RATE) &#123;</span><br><span class="line">            can_log = <span class="number">1</span>;</span><br><span class="line">            last_write_error_log = server.unixtime;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Log the AOF write error and record the error code. */</span></span><br><span class="line">        <span class="comment">// 记录AOF写入出错</span></span><br><span class="line">        <span class="keyword">if</span> (nwritten == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Error writing to the AOF file: %s"</span>,</span><br><span class="line">                    strerror(errno));</span><br><span class="line">                server.aof_last_write_errno = errno;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Short write while writing to "</span></span><br><span class="line">                                       <span class="string">"the AOF file: (nwritten=%lld, "</span></span><br><span class="line">                                       <span class="string">"expected=%lld)"</span>,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)nwritten,</span><br><span class="line">                                       (<span class="keyword">long</span> <span class="keyword">long</span>)sdslen(server.aof_buf));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ftruncate(server.aof_fd, server.aof_current_size) == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (can_log) &#123;</span><br><span class="line">                    serverLog(LL_WARNING, <span class="string">"Could not remove short write "</span></span><br><span class="line">                             <span class="string">"from the append-only file.  Redis may refuse "</span></span><br><span class="line">                             <span class="string">"to load the AOF the next time it starts.  "</span></span><br><span class="line">                             <span class="string">"ftruncate: %s"</span>, strerror(errno));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* If the ftruncate() succeeded we can set nwritten to</span></span><br><span class="line"><span class="comment">                 * -1 since there is no longer partial data into the AOF. */</span></span><br><span class="line">                nwritten = <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            server.aof_last_write_errno = ENOSPC;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle the AOF write error. */</span></span><br><span class="line">        <span class="comment">// 处理AOF写入错误</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">            <span class="comment">/* We can't recover when the fsync policy is ALWAYS since the</span></span><br><span class="line"><span class="comment">             * reply for the client is already in the output buffers, and we</span></span><br><span class="line"><span class="comment">             * have the contract with the user that on acknowledged write data</span></span><br><span class="line"><span class="comment">             * is synced on disk. */</span></span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"Can't recover from AOF write error when the AOF fsync policy is 'always'. Exiting..."</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/* Recover from failed write leaving data into the buffer. However</span></span><br><span class="line"><span class="comment">             * set an error to stop accepting writes as long as the error</span></span><br><span class="line"><span class="comment">             * condition is not cleared. */</span></span><br><span class="line">            server.aof_last_write_status = C_ERR;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Trim the sds buffer if there was a partial write, and there</span></span><br><span class="line"><span class="comment">             * was no way to undo it with ftruncate(2). */</span></span><br><span class="line">            <span class="keyword">if</span> (nwritten &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                server.aof_current_size += nwritten;</span><br><span class="line">                sdsrange(server.aof_buf,nwritten,<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">/* We'll try again on the next call... */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Successful write(2). If AOF was in error state, restore the</span></span><br><span class="line"><span class="comment">         * OK state and log the event. */</span></span><br><span class="line">        <span class="comment">// 写入成功，更新状态</span></span><br><span class="line">        <span class="keyword">if</span> (server.aof_last_write_status == C_ERR) &#123;</span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"AOF write error looks solved, Redis can write again."</span>);</span><br><span class="line">            server.aof_last_write_status = C_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新AOF文件大小</span></span><br><span class="line">    server.aof_current_size += nwritten;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Re-use AOF buffer when it is small enough. The maximum comes from the</span></span><br><span class="line"><span class="comment">     * arena size of 4k minus some overhead (but is otherwise arbitrary). */</span></span><br><span class="line">    <span class="comment">// 是否重用缓冲区，AOF缓存小于4K即可重用</span></span><br><span class="line">    <span class="keyword">if</span> ((sdslen(server.aof_buf)+sdsavail(server.aof_buf)) &lt; <span class="number">4000</span>) &#123;</span><br><span class="line">        <span class="comment">// 清楚缓冲区内容</span></span><br><span class="line">        sdsclear(server.aof_buf);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 释放缓冲区</span></span><br><span class="line">        sdsfree(server.aof_buf);</span><br><span class="line">        server.aof_buf = sdsempty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't fsync if no-appendfsync-on-rewrite is set to yes and there are</span></span><br><span class="line"><span class="comment">     * children doing I/O in the background. */</span></span><br><span class="line">    <span class="comment">// no-appendfsync-on-rewrite开启或者有AOF，RDB子进程执行，则直接返回，不执行fsync</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_no_fsync_on_rewrite &amp;&amp;</span><br><span class="line">        (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Perform the fsync if needed. */</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_fsync == AOF_FSYNC_ALWAYS) &#123;</span><br><span class="line">        <span class="comment">/* aof_fsync is defined as fdatasync() for Linux in order to avoid</span></span><br><span class="line"><span class="comment">         * flushing metadata. */</span></span><br><span class="line">        latencyStartMonitor(latency);</span><br><span class="line">        <span class="comment">// 写入到磁盘中</span></span><br><span class="line">        aof_fsync(server.aof_fd); <span class="comment">/* Let's try to get this data on the disk */</span></span><br><span class="line">        latencyEndMonitor(latency);</span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"aof-fsync-always"</span>,latency);</span><br><span class="line">        <span class="comment">// 更新写入时间</span></span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((server.aof_fsync == AOF_FSYNC_EVERYSEC &amp;&amp;</span><br><span class="line">                server.unixtime &gt; server.aof_last_fsync)) &#123;</span><br><span class="line">        <span class="comment">// 放到后台执行</span></span><br><span class="line">        <span class="keyword">if</span> (!sync_in_progress) aof_background_fsync(server.aof_fd);</span><br><span class="line">        server.aof_last_fsync = server.unixtime;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编码命令内容, 按照一定协议记录指令</span></span><br><span class="line"><span class="comment"> * 命令个数：格式: *&lt;count&gt;\r\n</span></span><br><span class="line"><span class="comment"> * 命令内容：格式：$&lt;length&gt;\r\n&lt;content&gt;\r\n</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">sds <span class="title">catAppendOnlyGenericCommand</span><span class="params">(sds dst, <span class="keyword">int</span> argc, robj **argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">int</span> len, j;</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令个数，格式: *&lt;count&gt;\r\n</span></span><br><span class="line">    buf[<span class="number">0</span>] = <span class="string">'*'</span>;</span><br><span class="line">    len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,argc);</span><br><span class="line">    buf[len++] = <span class="string">'\r'</span>;</span><br><span class="line">    buf[len++] = <span class="string">'\n'</span>;</span><br><span class="line">    dst = sdscatlen(dst,buf,len);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令内容，格式: $&lt;length&gt;\r\n&lt;content&gt;\r\n</span></span><br><span class="line">    <span class="comment">// 如 $3\r\nSET\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; argc; j++) &#123;</span><br><span class="line">        o = getDecodedObject(argv[j]);</span><br><span class="line">        buf[<span class="number">0</span>] = <span class="string">'$'</span>;</span><br><span class="line">        len = <span class="number">1</span>+ll2string(buf+<span class="number">1</span>,<span class="keyword">sizeof</span>(buf)<span class="number">-1</span>,sdslen(o-&gt;ptr));</span><br><span class="line">        buf[len++] = <span class="string">'\r'</span>;</span><br><span class="line">        buf[len++] = <span class="string">'\n'</span>;</span><br><span class="line">        dst = sdscatlen(dst,buf,len);</span><br><span class="line">        dst = sdscatlen(dst,o-&gt;ptr,sdslen(o-&gt;ptr));</span><br><span class="line">        dst = sdscatlen(dst,<span class="string">"\r\n"</span>,<span class="number">2</span>);</span><br><span class="line">        decrRefCount(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AOF后台重写</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rewriteAppendOnlyFileBackground</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> childpid;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经有AOF或RDB，返回错误</span></span><br><span class="line">    <span class="keyword">if</span> (server.aof_child_pid != <span class="number">-1</span> || server.rdb_child_pid != <span class="number">-1</span>) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建进程间通信管道</span></span><br><span class="line">    <span class="keyword">if</span> (aofCreatePipes() != C_OK) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开启子进程到父进程通信的管道</span></span><br><span class="line">    openChildInfoPipe();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    start = ustime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="keyword">if</span> ((childpid = fork()) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> tmpfile[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Child */</span></span><br><span class="line">        <span class="comment">// 关闭socket文件</span></span><br><span class="line">        closeListeningSockets(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 设置进程名</span></span><br><span class="line">        redisSetProcTitle(<span class="string">"redis-aof-rewrite"</span>);</span><br><span class="line">        <span class="comment">// 临时文件名</span></span><br><span class="line">        <span class="built_in">snprintf</span>(tmpfile,<span class="number">256</span>,<span class="string">"temp-rewriteaof-bg-%d.aof"</span>, (<span class="keyword">int</span>) getpid());</span><br><span class="line">        <span class="comment">// AOF重写到临时文件</span></span><br><span class="line">        <span class="keyword">if</span> (rewriteAppendOnlyFile(tmpfile) == C_OK) &#123;</span><br><span class="line">            <span class="comment">// 获取子进程使用内存空间大小</span></span><br><span class="line">            <span class="keyword">size_t</span> private_dirty = zmalloc_get_private_dirty(<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            <span class="keyword">if</span> (private_dirty) &#123;</span><br><span class="line">                serverLog(LL_NOTICE,</span><br><span class="line">                    <span class="string">"AOF rewrite: %zu MB of memory used by copy-on-write"</span>,</span><br><span class="line">                    private_dirty/(<span class="number">1024</span>*<span class="number">1024</span>));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录子进程使用内存空间</span></span><br><span class="line">            server.child_info_data.cow_size = private_dirty;</span><br><span class="line">            <span class="comment">// 发送数据给父进程</span></span><br><span class="line">            sendChildInfo(CHILD_INFO_TYPE_AOF);</span><br><span class="line">            <span class="comment">// 子进程退出</span></span><br><span class="line">            exitFromChild(<span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            exitFromChild(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Parent */</span></span><br><span class="line">        <span class="comment">// 记录创建子进程使用时间</span></span><br><span class="line">        server.stat_fork_time = ustime()-start;</span><br><span class="line">        <span class="comment">// 记录创建子进程的速率</span></span><br><span class="line">        server.stat_fork_rate = (<span class="keyword">double</span>) zmalloc_used_memory() * <span class="number">1000000</span> / server.stat_fork_time / (<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>); <span class="comment">/* GB per second. */</span></span><br><span class="line">        <span class="comment">// 记录fork使用时间</span></span><br><span class="line">        latencyAddSampleIfNeeded(<span class="string">"fork"</span>,server.stat_fork_time/<span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// 创建子进程失败，则返回错误</span></span><br><span class="line">        <span class="keyword">if</span> (childpid == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="comment">// 关闭子进程管道</span></span><br><span class="line">            closeChildInfoPipe();</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">            serverLog(LL_WARNING,</span><br><span class="line">                <span class="string">"Can't rewrite append only file in background: fork: %s"</span>,</span><br><span class="line">                strerror(errno));</span><br><span class="line">            <span class="comment">// 关闭通信管道</span></span><br><span class="line">            aofClosePipes();</span><br><span class="line">            <span class="keyword">return</span> C_ERR;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">        serverLog(LL_NOTICE,</span><br><span class="line">            <span class="string">"Background append only file rewriting started by pid %d"</span>,childpid);</span><br><span class="line">        <span class="comment">// 关闭AOF重写计划</span></span><br><span class="line">        server.aof_rewrite_scheduled = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 开始时间</span></span><br><span class="line">        server.aof_rewrite_time_start = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 子进程pid</span></span><br><span class="line">        server.aof_child_pid = childpid;</span><br><span class="line">        <span class="comment">// AOF或RDB期间，不能进行resize</span></span><br><span class="line">        updateDictResizePolicy();</span><br><span class="line">        <span class="comment">/* We set appendseldb to -1 in order to force the next call to the</span></span><br><span class="line"><span class="comment">         * feedAppendOnlyFile() to issue a SELECT command, so the differences</span></span><br><span class="line"><span class="comment">         * accumulated by the parent into server.aof_rewrite_buf will start</span></span><br><span class="line"><span class="comment">         * with a SELECT statement and it will be safe to merge. */</span></span><br><span class="line">        server.aof_selected_db = <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 情况脚本缓存</span></span><br><span class="line">        replicationScriptCacheFlush();</span><br><span class="line">        <span class="keyword">return</span> C_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK; <span class="comment">/* unreached */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://gxcbuf.github.io/2018/09/03/redis/16_RDB持久化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="郭欣成">
      <meta itemprop="description" content="Persion & Developer">
      <meta itemprop="image" content="/images/gxcbuf.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="孰能生巧">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/redis/16_RDB持久化/" itemprop="url">
                  Redis源码阅读(十六) RDB持久化
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-09-03 17:01:12 / 修改时间：17:02:10" itemprop="dateCreated datePublished" datetime="2018-09-03T17:01:12+08:00">2018-09-03</time>
            

            
              

              
            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/源码阅读/" itemprop="url" rel="index"><span itemprop="name">源码阅读</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Redis是一个内存数据库，数据库的状态都存储在内存中，如果服务器进程退出，那么所有的服务器状态都会丢失。Redis提供了RDB持久化功能，可以将内存中数据库的状态保存到磁盘中，避免因为意外进程退出导致的数据库状态丢失。</p>
<h3 id="1-RDB文件"><a href="#1-RDB文件" class="headerlink" title="1. RDB文件"></a>1. RDB文件</h3><ul>
<li>RDB存储对象长度定义，用来表示存储当前对象需要多少字节</li>
</ul>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDB_6BITLEN</td>
<td>0</td>
<td style="text-align:left">00XXXXXX，长度存储在后8bits中</td>
</tr>
<tr>
<td>RDB_14BITLEN</td>
<td>1</td>
<td style="text-align:left">01XXXXXX XXXXXXXX 长度存储在后14bits中</td>
</tr>
<tr>
<td>RDB_32BITLEN</td>
<td>0x80</td>
<td style="text-align:left">10000000 [32 bit] 长度存储在后32bits中</td>
</tr>
<tr>
<td>RDB_64BITLEN</td>
<td>0x81</td>
<td style="text-align:left">10000001 [64 bit] 长度存储在后64bits中</td>
</tr>
<tr>
<td>RDB_ENCVAL</td>
<td>3</td>
<td style="text-align:left">11OBKIND 表示一个特殊编码对象，用REDIS_RDS_ENC_*指定</td>
</tr>
<tr>
<td>RDB_LENERR</td>
<td>UINT64_MAX</td>
<td style="text-align:left">表示长度错误</td>
</tr>
</tbody>
</table>
<ul>
<li>RDB对象编码类型，RDB_ENCVAL定义长度情况下， 用该编码类型表示</li>
</ul>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDB_ENC_INT8</td>
<td>0</td>
<td>8位有符号整数</td>
</tr>
<tr>
<td>RDB_ENC_INT16</td>
<td>1</td>
<td>16位有符号整数</td>
</tr>
<tr>
<td>RDB_ENC_INT32</td>
<td>2</td>
<td>32位有符号整数</td>
</tr>
<tr>
<td>RDB_ENC_LZF</td>
<td>3</td>
<td>LZF压缩字符串</td>
</tr>
</tbody>
</table>
<ul>
<li>RDB对象存储类型，将Redis中的对象存储到RDB文件中保存的类型</li>
</ul>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDB_TYPE_STRING</td>
<td>0</td>
<td>字符串对象</td>
</tr>
<tr>
<td>RDB_TYPE_LIST</td>
<td>1</td>
<td>列表对象</td>
</tr>
<tr>
<td>RDB_TYPE_SET</td>
<td>2</td>
<td>集合对象</td>
</tr>
<tr>
<td>RDB_TYPE_ZSET</td>
<td>3</td>
<td>有序集合对象</td>
</tr>
<tr>
<td>RDB_TYPE_HASH</td>
<td>4</td>
<td>哈希对象</td>
</tr>
<tr>
<td>RDB_TYPE_ZSET_2</td>
<td>5</td>
<td>有序集合对象版本2，score用二进制存储</td>
</tr>
<tr>
<td>RDB_TYPE_MODULE</td>
<td>6</td>
<td>模块对象</td>
</tr>
<tr>
<td>RDB_TYPE_MODULE_2</td>
<td>7</td>
<td>带有注释的模块对象，用于解析而不生成</td>
</tr>
</tbody>
</table>
<ul>
<li>RDB对象存储类型的编码方式</li>
</ul>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDB_TYPE_HASH_ZIPMAP</td>
<td>9</td>
<td>ZIPMAP编码的哈希对象，已不再使用</td>
</tr>
<tr>
<td>RDB_TYPE_LIST_ZIPLIST</td>
<td>10</td>
<td>ZIPLIST编码的列表对象</td>
</tr>
<tr>
<td>RDB_TYPE_SET_INTSET</td>
<td>11</td>
<td>INTSET编码的集合对象</td>
</tr>
<tr>
<td>RDB_TYPE_ZSET_ZIPLIST</td>
<td>12</td>
<td>ZIPLIST编码的有序集合对象</td>
</tr>
<tr>
<td>RDB_TYPE_HASH_ZIPLIST</td>
<td>13</td>
<td>ZIPLIST编码的哈希对象</td>
</tr>
<tr>
<td>RDB_TYPE_LIST_QUICKLIST</td>
<td>14</td>
<td>QUICKLIST编码的列表对象</td>
</tr>
</tbody>
</table>
<ul>
<li>RDB操作码，保存和加载类型时使用</li>
</ul>
<table>
<thead>
<tr>
<th>宏定义</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>RDB_OPCODE_AUX</td>
<td>250</td>
<td>AUX操作</td>
</tr>
<tr>
<td>RDB_OPCODE_RESIZEDB</td>
<td>251</td>
<td>需要resize操作</td>
</tr>
<tr>
<td>RDB_OPCODE_EXPIRETIME_MS</td>
<td>252</td>
<td>过期毫秒数</td>
</tr>
<tr>
<td>RDB_OPCODE_EXPIRETIME</td>
<td>253</td>
<td>过期秒数</td>
</tr>
<tr>
<td>RDB_OPCODE_SELECTDB</td>
<td>254</td>
<td>选择db操作</td>
</tr>
<tr>
<td>RDB_OPCODE_EOF</td>
<td>255</td>
<td>结束操作</td>
</tr>
</tbody>
</table>
<h4 id="1-1-RDB文件结构"><a href="#1-1-RDB文件结构" class="headerlink" title="1.1 RDB文件结构"></a>1.1 RDB文件结构</h4><table>
<thead>
<tr>
<th>REDIS</th>
<th>VERSION</th>
<th>DATABASE</th>
<th>EOF</th>
<th>CHECKNUM</th>
</tr>
</thead>
<tbody>
<tr>
<td>“REDIS”</td>
<td>版本号</td>
<td>数据区域</td>
<td>结束标识</td>
<td>校验和</td>
</tr>
</tbody>
</table>
<p>RDB文件以“REDIS”开头，后紧接着4字节的版本号。</p>
<p>database数据区域存储着一个或多个特定格式编码的数据库。</p>
<p>EOF是RDB正文结束。</p>
<p>check_num是校验和，通过前4部分计算得出。</p>
<h4 id="1-2-database数据区域部分"><a href="#1-2-database数据区域部分" class="headerlink" title="1.2 database数据区域部分"></a>1.2 database数据区域部分</h4><p>一个RDB文件可能存在多个非空数据库，通过OPCODE_SELECTDB操作码可以选择数据库对象，格式</p>
<table>
<thead>
<tr>
<th>RDB_OPCODE_SELECTDB</th>
<th>db_number</th>
<th>key_value_pairs</th>
</tr>
</thead>
<tbody>
<tr>
<td>选择数据库操作码 254</td>
<td>数据库编号</td>
<td>所有的键值对数据</td>
</tr>
</tbody>
</table>
<h4 id="1-3-键值对数据区域"><a href="#1-3-键值对数据区域" class="headerlink" title="1.3 键值对数据区域"></a>1.3 键值对数据区域</h4><p>RDB文件中每个键值对数据区域都保存着一个或多个键值对，如果带有过期时间，那么过期时间也会被保存。</p>
<table>
<thead>
<tr>
<th>RDB_OPCODE_EXPIRETIME</th>
<th>ms</th>
<th>TYPE</th>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>过期时间操作码</td>
<td>过期时间</td>
<td>键类型</td>
<td>键</td>
<td>值</td>
</tr>
</tbody>
</table>
<h3 id="2-RDB文件的创建"><a href="#2-RDB文件的创建" class="headerlink" title="2. RDB文件的创建"></a>2. RDB文件的创建</h3><p>SAVE命令和BGSAVE命令可以创建RDB文件。由于Redis是单进程的，所以SAVE命令创建RDB文件会阻塞Redis服务器，这种情况下，服务器不能处理任何命令请求。BGSAVE则会生成一个子进程用于创建RDB文件，父进程则进行处理命令请求。</p>
<blockquote>
<p>注：在同一时间内，只能存在一个BGSAVE子进程。</p>
</blockquote>
<p>RDB文件创建由rdb.c/rdbSave函数实现：</p>
<ol>
<li><p>创建临时文件temp-pid.rdb，用于保存RDB内容</p>
</li>
<li><p>将数据库内容按照一定编码格式写入文件</p>
<p>1）计算校验和</p>
<p>2）存储redis版本</p>
<p>3）遍历服务器数据库并写入到文件，内存内容到RDB需要按照一定的编码格式和规则</p>
<p>4）存在lua脚本也需要备份脚本</p>
<p>5）存储EOF操作码</p>
<p>6）存储校验和</p>
</li>
<li><p>修改临时文件名为RDB文件名</p>
</li>
<li><p>记录服务端操作信息</p>
</li>
</ol>
<p>BGSAVE命令同样会调用rdbSave函数，区别是在fork出的子进程中执行该函数。</p>
<h3 id="3-RDB文件的加载"><a href="#3-RDB文件的加载" class="headerlink" title="3. RDB文件的加载"></a>3. RDB文件的加载</h3><p>在Redis服务器启动时，会根据配置的选项进行初始化，若开启了RDB功能，且未开启AOF功能，则会从RDB文件中加载数据到内存中。加载过程中，Redis也是处于阻塞状态，不能处理其他服务指令。</p>
<blockquote>
<p>AOF文件更新频率通常高于RDB，所以如果开启了AOF功能，服务器会首先使用AOF文件还原数据库状态。</p>
</blockquote>
<p>RDB文件的加载由rdb.c/rdbLoad函数实现：</p>
<ol>
<li><p>打开RDB文件</p>
</li>
<li><p>开始加载</p>
</li>
<li><p>初始化Redis输入输出缓存对象</p>
</li>
<li><p>读取RDB文件中的数据到内存</p>
<p>1）设置计算校验和函数</p>
<p>2）设置加载读或写的最大字节数</p>
<p>3）读取9字节，这9字节存储着redis的版本信息，并判断版本是否正确</p>
<p>4）循环读取RDB文件，按照写入RDB文件的编码方式进行读取</p>
<p>5）Redis版本大于5则需要进行校验计算</p>
</li>
<li><p>关闭文件</p>
</li>
<li><p>加载完成</p>
</li>
</ol>
<h3 id="4-源码剖析"><a href="#4-源码剖析" class="headerlink" title="4. 源码剖析"></a>4. 源码剖析</h3><ul>
<li>RDB创建实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbSaveRio</span><span class="params">(rio *rdb, <span class="keyword">int</span> *error, <span class="keyword">int</span> flags, rdbSaveInfo *rsi)</span> </span>&#123;</span><br><span class="line">    dictIterator *di = <span class="literal">NULL</span>;</span><br><span class="line">    dictEntry *de;</span><br><span class="line">    <span class="keyword">char</span> magic[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">uint64_t</span> cksum;</span><br><span class="line">    <span class="keyword">size_t</span> processed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验和选项</span></span><br><span class="line">    <span class="keyword">if</span> (server.rdb_checksum)</span><br><span class="line">        rdb-&gt;update_cksum = rioGenericUpdateChecksum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储redis版本到magic</span></span><br><span class="line">    <span class="built_in">snprintf</span>(magic,<span class="keyword">sizeof</span>(magic),<span class="string">"REDIS%04d"</span>,RDB_VERSION);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mgaic写入到RDB</span></span><br><span class="line">    <span class="keyword">if</span> (rdbWriteRaw(rdb,magic,<span class="number">9</span>) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将RDB文件的默认信息写入</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveInfoAuxFields(rdb,flags,rsi) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历服务端数据库</span></span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; server.dbnum; j++) &#123;</span><br><span class="line">        <span class="comment">// 当前数据库指针</span></span><br><span class="line">        redisDb *db = server.db+j;</span><br><span class="line">        <span class="comment">// 数据库的键值对字典</span></span><br><span class="line">        dict *d = db-&gt;dict;</span><br><span class="line">        <span class="comment">// 字典大小为0下个数据库</span></span><br><span class="line">        <span class="keyword">if</span> (dictSize(d) == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取字典安全迭代器</span></span><br><span class="line">        di = dictGetSafeIterator(d);</span><br><span class="line">        <span class="keyword">if</span> (!di) <span class="keyword">return</span> C_ERR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the SELECT DB opcode */</span></span><br><span class="line">        <span class="comment">// 写入数据库的选择标识码RDB_OPCODE_SELECTDB为254</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_SELECTDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 写入数据库id，占用一字节长度</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,j) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the RESIZE DB opcode. We trim the size to UINT32_MAX, which</span></span><br><span class="line"><span class="comment">         * is currently the largest type we are able to represent in RDB sizes.</span></span><br><span class="line"><span class="comment">         * However this does not limit the actual size of the DB to load since</span></span><br><span class="line"><span class="comment">         * these sizes are just hints to resize the hash tables. */</span></span><br><span class="line">        <span class="keyword">uint32_t</span> db_size, expires_size;</span><br><span class="line">        <span class="comment">// 我们将大小限制在UNIT32_MAX，但不代表实际大小，只是用于提示重新调整哈希表大小</span></span><br><span class="line">        <span class="comment">// 计算键值对字典大小</span></span><br><span class="line">        db_size = (dictSize(db-&gt;dict) &lt;= UINT32_MAX) ?</span><br><span class="line">                                dictSize(db-&gt;dict) :</span><br><span class="line">                                UINT32_MAX;</span><br><span class="line">        <span class="comment">// 计算过期字典大小</span></span><br><span class="line">        expires_size = (dictSize(db-&gt;expires) &lt;= UINT32_MAX) ?</span><br><span class="line">                                dictSize(db-&gt;expires) :</span><br><span class="line">                                UINT32_MAX;</span><br><span class="line">        <span class="comment">// 写入哈希表调整嘛RDB_OPCODE_RESIZEDB=251</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_RESIZEDB) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 写入键值对字典大小</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,db_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">        <span class="comment">// 写入过期字典大小</span></span><br><span class="line">        <span class="keyword">if</span> (rdbSaveLen(rdb,expires_size) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Iterate this DB writing every entry */</span></span><br><span class="line">        <span class="comment">// 遍历键值对字典</span></span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="comment">// 键</span></span><br><span class="line">            sds keystr = dictGetKey(de);</span><br><span class="line">            <span class="comment">// 值</span></span><br><span class="line">            robj key, *o = dictGetVal(de);</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> expire;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 栈空间中创建一个键对象</span></span><br><span class="line">            initStaticStringObject(key,keystr);</span><br><span class="line">            <span class="comment">// 获取当前键的过期时间</span></span><br><span class="line">            expire = getExpire(db,&amp;key);</span><br><span class="line">            <span class="comment">// 保存键值对和过期时间到RDB</span></span><br><span class="line">            <span class="keyword">if</span> (rdbSaveKeyValuePair(rdb,&amp;key,o,expire) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* When this RDB is produced as part of an AOF rewrite, move</span></span><br><span class="line"><span class="comment">             * accumulated diff from parent to child while rewriting in</span></span><br><span class="line"><span class="comment">             * order to have a smaller final write. */</span></span><br><span class="line">            <span class="comment">// 当这个RDB作为AOF重写的一部分生成时，</span></span><br><span class="line">            <span class="comment">// 在重写时移动父进程到子进程的累积差异,</span></span><br><span class="line">            <span class="comment">// 是为了获取更小的写入大小</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; RDB_SAVE_AOF_PREAMBLE &amp;&amp;</span><br><span class="line">                rdb-&gt;processed_bytes &gt; processed+AOF_READ_DIFF_INTERVAL_BYTES)</span><br><span class="line">            &#123;</span><br><span class="line">                processed = rdb-&gt;processed_bytes;</span><br><span class="line">                aofReadDiffFromParent();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 释放迭代器</span></span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line">    di = <span class="literal">NULL</span>; <span class="comment">/* So that we don't release it again on error. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are storing the replication information on disk, persist</span></span><br><span class="line"><span class="comment">     * the script cache as well: on successful PSYNC after a restart, we need</span></span><br><span class="line"><span class="comment">     * to be able to process any EVALSHA inside the replication backlog the</span></span><br><span class="line"><span class="comment">     * master will send us. */</span></span><br><span class="line">    <span class="comment">// 备份服务器的lua脚本</span></span><br><span class="line">    <span class="keyword">if</span> (rsi &amp;&amp; dictSize(server.lua_scripts)) &#123;</span><br><span class="line">        di = dictGetIterator(server.lua_scripts);</span><br><span class="line">        <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            robj *body = dictGetVal(de);</span><br><span class="line">            <span class="keyword">if</span> (rdbSaveAuxField(rdb,<span class="string">"lua"</span>,<span class="number">3</span>,body-&gt;ptr,sdslen(body-&gt;ptr)) == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">goto</span> werr;</span><br><span class="line">        &#125;</span><br><span class="line">        dictReleaseIterator(di);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF opcode */</span></span><br><span class="line">    <span class="comment">// 结束标识符RDB_OPCODE_EOF=255</span></span><br><span class="line">    <span class="keyword">if</span> (rdbSaveType(rdb,RDB_OPCODE_EOF) == <span class="number">-1</span>) <span class="keyword">goto</span> werr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* CRC64 checksum. It will be zero if checksum computation is disabled, the</span></span><br><span class="line"><span class="comment">     * loading code skips the check in this case. */</span></span><br><span class="line">    <span class="comment">// CRC64校验和. 校验和计算未开启时为0，加载RDB文件时会跳过</span></span><br><span class="line">    cksum = rdb-&gt;cksum;</span><br><span class="line">    memrev64ifbe(&amp;cksum);</span><br><span class="line">    <span class="keyword">if</span> (rioWrite(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> werr;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">werr:</span><br><span class="line">    <span class="keyword">if</span> (error) *error = errno;</span><br><span class="line">    <span class="keyword">if</span> (di) dictReleaseIterator(di);</span><br><span class="line">    <span class="keyword">return</span> C_ERR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RDB读取实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rdbLoadRio</span><span class="params">(rio *rdb, rdbSaveInfo *rsi, <span class="keyword">int</span> loading_aof)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> dbid;</span><br><span class="line">    <span class="keyword">int</span> type, rdbver;</span><br><span class="line">    redisDb *db = server.db+<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> expiretime, now = mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置计算校验和函数</span></span><br><span class="line">    rdb-&gt;update_cksum = rdbLoadProgressCallback;</span><br><span class="line">    <span class="comment">// 设置加载读或写的最大字节数</span></span><br><span class="line">    rdb-&gt;max_processing_chunk = server.loading_process_events_interval_bytes;</span><br><span class="line">    <span class="comment">// 读取9字节，buf中保存redis版本信息"redis0001"</span></span><br><span class="line">    <span class="keyword">if</span> (rioRead(rdb,buf,<span class="number">9</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">    buf[<span class="number">9</span>] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">memcmp</span>(buf,<span class="string">"REDIS"</span>,<span class="number">5</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Wrong signature trying to load DB from file"</span>);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// redis版本</span></span><br><span class="line">    rdbver = atoi(buf+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">if</span> (rdbver &lt; <span class="number">1</span> || rdbver &gt; RDB_VERSION) &#123;</span><br><span class="line">        serverLog(LL_WARNING,<span class="string">"Can't handle RDB format version %d"</span>,rdbver);</span><br><span class="line">        errno = EINVAL;</span><br><span class="line">        <span class="keyword">return</span> C_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取RDB文件</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        robj *key, *val;</span><br><span class="line">        expiretime = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read type. */</span></span><br><span class="line">        <span class="comment">// 读取类型</span></span><br><span class="line">        <span class="keyword">if</span> ((type = rdbLoadType(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Handle special types. */</span></span><br><span class="line">        <span class="comment">// 处理特殊类型</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 过期时间类型</span></span><br><span class="line">        <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME: load an expire associated with the next key</span></span><br><span class="line"><span class="comment">             * to load. Note that after loading an expire we need to</span></span><br><span class="line"><span class="comment">             * load the actual type, and continue. */</span></span><br><span class="line">            <span class="comment">// 读取过期时间</span></span><br><span class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadTime(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="comment">/* We read the time so we need to read the object type again. */</span></span><br><span class="line">            <span class="comment">// 读取下一个键值对类型</span></span><br><span class="line">            <span class="keyword">if</span> ((type = rdbLoadType(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="comment">/* the EXPIRETIME opcode specifies time in seconds, so convert</span></span><br><span class="line"><span class="comment">             * into milliseconds. */</span></span><br><span class="line">            <span class="comment">// 转换为毫秒</span></span><br><span class="line">            expiretime *= <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 过期时间毫秒类型</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EXPIRETIME_MS) &#123;</span><br><span class="line">            <span class="comment">/* EXPIRETIME_MS: milliseconds precision expire times introduced</span></span><br><span class="line"><span class="comment">             * with RDB v3. Like EXPIRETIME but no with more precision. */</span></span><br><span class="line">            <span class="comment">// 读取过期时间</span></span><br><span class="line">            <span class="keyword">if</span> ((expiretime = rdbLoadMillisecondTime(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="comment">/* We read the time so we need to read the object type again. */</span></span><br><span class="line">            <span class="comment">// 读取下一个键值对类型</span></span><br><span class="line">            <span class="keyword">if</span> ((type = rdbLoadType(rdb)) == <span class="number">-1</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 终止EOF, 读取到则终止循环，表示加载完成</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_EOF) &#123;</span><br><span class="line">            <span class="comment">/* EOF: End of file, exit the main loop. */</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取切换数据库操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_SELECTDB) &#123;</span><br><span class="line">            <span class="comment">/* SELECTDB: Select the specified database. */</span></span><br><span class="line">            <span class="comment">// 读取数据库id</span></span><br><span class="line">            <span class="keyword">if</span> ((dbid = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="comment">// 检查数据库id的合法性</span></span><br><span class="line">            <span class="keyword">if</span> (dbid &gt;= (<span class="keyword">unsigned</span>)server.dbnum) &#123;</span><br><span class="line">                serverLog(LL_WARNING,</span><br><span class="line">                    <span class="string">"FATAL: Data file was created with a Redis "</span></span><br><span class="line">                    <span class="string">"server configured to handle more than %d "</span></span><br><span class="line">                    <span class="string">"databases. Exiting\n"</span>, server.dbnum);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更换数据库</span></span><br><span class="line">            db = server.db+dbid;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read type again. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取RESIZEDB操作，重新调整哈希表大小</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_RESIZEDB) &#123;</span><br><span class="line">            <span class="comment">/* RESIZEDB: Hint about the size of the keys in the currently</span></span><br><span class="line"><span class="comment">             * selected data base, in order to avoid useless rehashing. */</span></span><br><span class="line">            <span class="keyword">uint64_t</span> db_size, expires_size;</span><br><span class="line">            <span class="comment">// 读取键值对字典的大小</span></span><br><span class="line">            <span class="keyword">if</span> ((db_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="comment">// 读取过期字典的大小</span></span><br><span class="line">            <span class="keyword">if</span> ((expires_size = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR)</span><br><span class="line">                <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="comment">// 字典扩展</span></span><br><span class="line">            dictExpand(db-&gt;dict,db_size);</span><br><span class="line">            dictExpand(db-&gt;expires,expires_size);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read type again. */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取AUX，辅助信息</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == RDB_OPCODE_AUX) &#123;</span><br><span class="line">            <span class="comment">/* AUX: generic string-string fields. Use to add state to RDB</span></span><br><span class="line"><span class="comment">             * which is backward compatible. Implementations of RDB loading</span></span><br><span class="line"><span class="comment">             * are requierd to skip AUX fields they don't understand.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * An AUX field is composed of two strings: key and value. */</span></span><br><span class="line">            robj *auxkey, *auxval;</span><br><span class="line">            <span class="comment">// 读取辅助字典</span></span><br><span class="line">            <span class="keyword">if</span> ((auxkey = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">            <span class="keyword">if</span> ((auxval = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (((<span class="keyword">char</span>*)auxkey-&gt;ptr)[<span class="number">0</span>] == <span class="string">'%'</span>) &#123;</span><br><span class="line">                <span class="comment">/* All the fields with a name staring with '%' are considered</span></span><br><span class="line"><span class="comment">                 * information fields and are logged at startup with a log</span></span><br><span class="line"><span class="comment">                 * level of NOTICE. */</span></span><br><span class="line">                serverLog(LL_NOTICE,<span class="string">"RDB '%s': %s"</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">"repl-stream-db"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_stream_db = atoi(auxval-&gt;ptr);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">"repl-id"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi &amp;&amp; sdslen(auxval-&gt;ptr) == CONFIG_RUN_ID_SIZE) &#123;</span><br><span class="line">                    <span class="built_in">memcpy</span>(rsi-&gt;repl_id,auxval-&gt;ptr,CONFIG_RUN_ID_SIZE+<span class="number">1</span>);</span><br><span class="line">                    rsi-&gt;repl_id_is_set = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">"repl-offset"</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rsi) rsi-&gt;repl_offset = strtoll(auxval-&gt;ptr,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!strcasecmp(auxkey-&gt;ptr,<span class="string">"lua"</span>)) &#123;</span><br><span class="line">                <span class="comment">/* Load the script back in memory. */</span></span><br><span class="line">                <span class="keyword">if</span> (luaCreateFunction(<span class="literal">NULL</span>,server.lua,auxval) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    rdbExitReportCorruptRDB(</span><br><span class="line">                        <span class="string">"Can't load Lua script from RDB file! "</span></span><br><span class="line">                        <span class="string">"BODY: %s"</span>, auxval-&gt;ptr);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* We ignore fields we don't understand, as by AUX field</span></span><br><span class="line"><span class="comment">                 * contract. */</span></span><br><span class="line">                serverLog(LL_DEBUG,<span class="string">"Unrecognized RDB AUX field: '%s'"</span>,</span><br><span class="line">                    (<span class="keyword">char</span>*)auxkey-&gt;ptr);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            decrRefCount(auxkey);</span><br><span class="line">            decrRefCount(auxval);</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">/* Read type again. */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Read key */</span></span><br><span class="line">        <span class="comment">// 读取键对象</span></span><br><span class="line">        <span class="keyword">if</span> ((key = rdbLoadStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="comment">/* Read value */</span></span><br><span class="line">        <span class="comment">// 读取值对象</span></span><br><span class="line">        <span class="keyword">if</span> ((val = rdbLoadObject(type,rdb)) == <span class="literal">NULL</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="comment">/* Check if the key already expired. This function is used when loading</span></span><br><span class="line"><span class="comment">         * an RDB file from disk, either at startup, or when an RDB was</span></span><br><span class="line"><span class="comment">         * received from the master. In the latter case, the master is</span></span><br><span class="line"><span class="comment">         * responsible for key expiry. If we would expire keys here, the</span></span><br><span class="line"><span class="comment">         * snapshot taken by the master may not be reflected on the slave. */</span></span><br><span class="line">        <span class="comment">// 如果是master节点，且已经过期，则释放该键值对</span></span><br><span class="line">        <span class="keyword">if</span> (server.masterhost == <span class="literal">NULL</span> &amp;&amp; !loading_aof &amp;&amp; expiretime != <span class="number">-1</span> &amp;&amp; expiretime &lt; now) &#123;</span><br><span class="line">            decrRefCount(key);</span><br><span class="line">            decrRefCount(val);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Add the new object in the hash table */</span></span><br><span class="line">        <span class="comment">// 添加键值对数据库</span></span><br><span class="line">        dbAdd(db,key,val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set the expire time if needed */</span></span><br><span class="line">        <span class="comment">// 设置过期时间</span></span><br><span class="line">        <span class="keyword">if</span> (expiretime != <span class="number">-1</span>) setExpire(<span class="literal">NULL</span>,db,key,expiretime);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放临时对象key</span></span><br><span class="line">        decrRefCount(key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Verify the checksum if RDB version is &gt;= 5 */</span></span><br><span class="line">    <span class="comment">// redis版本大于5，需要进行校验</span></span><br><span class="line">    <span class="keyword">if</span> (rdbver &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> cksum, expected = rdb-&gt;cksum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rioRead(rdb,&amp;cksum,<span class="number">8</span>) == <span class="number">0</span>) <span class="keyword">goto</span> eoferr;</span><br><span class="line">        <span class="keyword">if</span> (server.rdb_checksum) &#123;</span><br><span class="line">            memrev64ifbe(&amp;cksum);</span><br><span class="line">            <span class="keyword">if</span> (cksum == <span class="number">0</span>) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"RDB file was saved with checksum disabled: no check performed."</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cksum != expected) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"Wrong RDB checksum. Aborting now."</span>);</span><br><span class="line">                rdbExitReportCorruptRDB(<span class="string">"RDB CRC error"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> C_OK;</span><br><span class="line"></span><br><span class="line">eoferr: <span class="comment">/* unexpected end of file is handled here with a fatal exit */</span></span><br><span class="line">    serverLog(LL_WARNING,<span class="string">"Short read or OOM loading DB. Unrecoverable error, aborting now."</span>);</span><br><span class="line">    rdbExitReportCorruptRDB(<span class="string">"Unexpected EOF reading RDB file"</span>);</span><br><span class="line">    <span class="keyword">return</span> C_ERR; <span class="comment">/* Just to avoid warning */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RDB创建一个对象</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> rdbSaveObject(rio *rdb, robj *o) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n = <span class="number">0</span>, nwritten = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串对象</span></span><br><span class="line">    <span class="keyword">if</span> (o-&gt;type == OBJ_STRING) &#123;</span><br><span class="line">        <span class="comment">/* Save a string value */</span></span><br><span class="line">        <span class="comment">// 保存字符串对象</span></span><br><span class="line">        <span class="keyword">if</span> ((n = rdbSaveStringObject(rdb,o)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        nwritten += n;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_LIST) &#123;</span><br><span class="line">        <span class="comment">/* Save a list value */</span></span><br><span class="line">        <span class="comment">// quicklist编码</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_QUICKLIST) &#123;</span><br><span class="line">            quicklist *ql = o-&gt;ptr;</span><br><span class="line">            quicklistNode *node = ql-&gt;head;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 先保存长度</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveLen(rdb,ql-&gt;len)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 然后遍历quicklist中的结点</span></span><br><span class="line">            <span class="keyword">while</span>(node) &#123;</span><br><span class="line">                <span class="comment">// 根据是否压缩分别存储</span></span><br><span class="line">                <span class="keyword">if</span> (quicklistNodeIsCompressed(node)) &#123;</span><br><span class="line">                    <span class="keyword">void</span> *data;</span><br><span class="line">                    <span class="keyword">size_t</span> compress_len = quicklistGetLzf(node, &amp;data);</span><br><span class="line">                    <span class="comment">// 压缩过，则解压后保存二进制数据到rdb</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = rdbSaveLzfBlob(rdb,data,compress_len,node-&gt;sz)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    nwritten += n;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 未压缩过，则直接保存原始的字符串数据</span></span><br><span class="line">                    <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,node-&gt;zl,node-&gt;sz)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                    nwritten += n;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 下一个结点</span></span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown list encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_SET) &#123;</span><br><span class="line">        <span class="comment">/* Save a set value */</span></span><br><span class="line">        <span class="comment">// 哈希表编码</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">            dict *<span class="built_in">set</span> = o-&gt;ptr;</span><br><span class="line">            <span class="comment">// 获取集合对象迭代器</span></span><br><span class="line">            dictIterator *di = dictGetIterator(<span class="built_in">set</span>);</span><br><span class="line">            dictEntry *de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存字典长度到RDB</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveLen(rdb,dictSize(<span class="built_in">set</span>))) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历字典</span></span><br><span class="line">            <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取sds字符串对象</span></span><br><span class="line">                sds ele = dictGetKey(de);</span><br><span class="line">                <span class="comment">// 保存到RDB中</span></span><br><span class="line">                <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)ele,sdslen(ele)))</span><br><span class="line">                    == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                nwritten += n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放迭代器</span></span><br><span class="line">            dictReleaseIterator(di);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 整数集合编码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">            <span class="comment">// 获取整数集合长度</span></span><br><span class="line">            <span class="keyword">size_t</span> l = intsetBlobLen((intset*)o-&gt;ptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存原始字符串到RDB</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,o-&gt;ptr,l)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown set encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有序集合对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_ZSET) &#123;</span><br><span class="line">        <span class="comment">/* Save a sorted set value */</span></span><br><span class="line">        <span class="comment">// 压缩列表编码</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">            <span class="comment">// 压缩列表长度</span></span><br><span class="line">            <span class="keyword">size_t</span> l = ziplistBlobLen((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)o-&gt;ptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储到rdb</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,o-&gt;ptr,l)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 跳跃表编码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_SKIPLIST) &#123;</span><br><span class="line">            zset *zs = o-&gt;ptr;</span><br><span class="line">            zskiplist *zsl = zs-&gt;zsl;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储跳跃表长度到RDB</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveLen(rdb,zsl-&gt;length)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* We save the skiplist elements from the greatest to the smallest</span></span><br><span class="line"><span class="comment">             * (that's trivial since the elements are already ordered in the</span></span><br><span class="line"><span class="comment">             * skiplist): this improves the load process, since the next loaded</span></span><br><span class="line"><span class="comment">             * element will always be the smaller, so adding to the skiplist</span></span><br><span class="line"><span class="comment">             * will always immediately stop at the head, making the insertion</span></span><br><span class="line"><span class="comment">             * O(1) instead of O(log(N)). */</span></span><br><span class="line">            zskiplistNode *zn = zsl-&gt;tail;</span><br><span class="line">            <span class="comment">// 遍历跳跃表</span></span><br><span class="line">            <span class="keyword">while</span> (zn != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 成员ele存储原始字符串到RDB</span></span><br><span class="line">                <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,</span><br><span class="line">                    (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)zn-&gt;ele,sdslen(zn-&gt;ele))) == <span class="number">-1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                nwritten += n;</span><br><span class="line">                <span class="comment">// 分数score存储二进制double到rdb</span></span><br><span class="line">                <span class="keyword">if</span> ((n = rdbSaveBinaryDoubleValue(rdb,zn-&gt;score)) == <span class="number">-1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                nwritten += n;</span><br><span class="line">                zn = zn-&gt;backward;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown sorted set encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_HASH) &#123;</span><br><span class="line">        <span class="comment">/* Save a hash value */</span></span><br><span class="line">        <span class="comment">// 压缩列表编码</span></span><br><span class="line">        <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST) &#123;</span><br><span class="line">            <span class="comment">// 长度</span></span><br><span class="line">            <span class="keyword">size_t</span> l = ziplistBlobLen((<span class="keyword">unsigned</span> <span class="keyword">char</span>*)o-&gt;ptr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 存储到RDB</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,o-&gt;ptr,l)) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 哈希表编码</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">            <span class="comment">// 迭代器</span></span><br><span class="line">            dictIterator *di = dictGetIterator(o-&gt;ptr);</span><br><span class="line">            dictEntry *de;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 保存字典长度到RDB</span></span><br><span class="line">            <span class="keyword">if</span> ((n = rdbSaveLen(rdb,dictSize((dict*)o-&gt;ptr))) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            nwritten += n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历字典</span></span><br><span class="line">            <span class="keyword">while</span>((de = dictNext(di)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="comment">// 获取成员field</span></span><br><span class="line">                sds field = dictGetKey(de);</span><br><span class="line">                <span class="comment">// 获取值value</span></span><br><span class="line">                sds value = dictGetVal(de);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 存储field</span></span><br><span class="line">                <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field,</span><br><span class="line">                        sdslen(field))) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                nwritten += n;</span><br><span class="line">                <span class="comment">// 存储value</span></span><br><span class="line">                <span class="keyword">if</span> ((n = rdbSaveRawString(rdb,(<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</span><br><span class="line">                        sdslen(value))) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">                nwritten += n;</span><br><span class="line">            &#125;</span><br><span class="line">            dictReleaseIterator(di);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            serverPanic(<span class="string">"Unknown hash encoding"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 模块对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (o-&gt;type == OBJ_MODULE) &#123;</span><br><span class="line">        <span class="comment">/* Save a module-specific value. */</span></span><br><span class="line">        RedisModuleIO io;</span><br><span class="line">        moduleValue *mv = o-&gt;ptr;</span><br><span class="line">        moduleType *mt = mv-&gt;type;</span><br><span class="line">        moduleInitIOContext(io,mt,rdb);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Write the "module" identifier as prefix, so that we'll be able</span></span><br><span class="line"><span class="comment">         * to call the right module during loading. */</span></span><br><span class="line">        <span class="keyword">int</span> retval = rdbSaveLen(rdb,mt-&gt;id);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        io.bytes += retval;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Then write the module-specific representation + EOF marker. */</span></span><br><span class="line">        mt-&gt;rdb_save(&amp;io,mv-&gt;value);</span><br><span class="line">        retval = rdbSaveLen(rdb,RDB_MODULE_OPCODE_EOF);</span><br><span class="line">        <span class="keyword">if</span> (retval == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        io.bytes += retval;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (io.ctx) &#123;</span><br><span class="line">            moduleFreeContext(io.ctx);</span><br><span class="line">            zfree(io.ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> io.error ? <span class="number">-1</span> : (<span class="keyword">ssize_t</span>)io.bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serverPanic(<span class="string">"Unknown object type"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nwritten;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>RDB读取一个读写</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">rdbLoadObject</span><span class="params">(<span class="keyword">int</span> rdbtype, rio *rdb)</span> </span>&#123;</span><br><span class="line">    robj *o = <span class="literal">NULL</span>, *ele, *dec;</span><br><span class="line">    <span class="keyword">uint64_t</span> len;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串对象</span></span><br><span class="line">    <span class="keyword">if</span> (rdbtype == RDB_TYPE_STRING) &#123;</span><br><span class="line">        <span class="comment">/* Read string value */</span></span><br><span class="line">        <span class="comment">// 读取编码的字符串对象</span></span><br><span class="line">        <span class="keyword">if</span> ((o = rdbLoadEncodedStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 优化编码</span></span><br><span class="line">        o = tryObjectEncoding(o);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 列表对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_LIST) &#123;</span><br><span class="line">        <span class="comment">/* Read list value */</span></span><br><span class="line">        <span class="comment">// 读取列表对象元素个数</span></span><br><span class="line">        <span class="keyword">if</span> ((len = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建快速列表</span></span><br><span class="line">        o = createQuicklistObject();</span><br><span class="line">        <span class="comment">// 设置压缩程度和ziplist最大长度</span></span><br><span class="line">        quicklistSetOptions(o-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                            server.list_compress_depth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Load every single element of the list */</span></span><br><span class="line">        <span class="comment">// 读取len个元素</span></span><br><span class="line">        <span class="keyword">while</span>(len--) &#123;</span><br><span class="line">            <span class="comment">// 读取编码的字符串对象</span></span><br><span class="line">            <span class="keyword">if</span> ((ele = rdbLoadEncodedStringObject(rdb)) == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 解码字符串对象</span></span><br><span class="line">            dec = getDecodedObject(ele);</span><br><span class="line">            <span class="comment">// 获取字符串的长度</span></span><br><span class="line">            <span class="keyword">size_t</span> len = sdslen(dec-&gt;ptr);</span><br><span class="line">            <span class="comment">// 添加读取的字符串对象到quicklist</span></span><br><span class="line">            quicklistPushTail(o-&gt;ptr, dec-&gt;ptr, len);</span><br><span class="line">            <span class="comment">// 释放临时变量</span></span><br><span class="line">            decrRefCount(dec);</span><br><span class="line">            decrRefCount(ele);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 集合对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_SET) &#123;</span><br><span class="line">        <span class="comment">/* Read Set value */</span></span><br><span class="line">        <span class="comment">// 读取集合对象中元素的个数</span></span><br><span class="line">        <span class="keyword">if</span> ((len = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Use a regular set when there are too many entries. */</span></span><br><span class="line">        <span class="comment">// 如果超过最多intset节点数，则创建一个HT编码的集合对象</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; server.set_max_intset_entries) &#123;</span><br><span class="line">            o = createSetObject();</span><br><span class="line">            <span class="comment">/* It's faster to expand the dict to the right size asap in order</span></span><br><span class="line"><span class="comment">             * to avoid rehashing */</span></span><br><span class="line">            <span class="keyword">if</span> (len &gt; DICT_HT_INITIAL_SIZE)</span><br><span class="line">                dictExpand(o-&gt;ptr,len);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            o = createIntsetObject();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Load every single element of the set */</span></span><br><span class="line">        <span class="comment">// 遍历len个元素</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">long</span> <span class="keyword">long</span> llval;</span><br><span class="line">            sds sdsele;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取sds字符串</span></span><br><span class="line">            <span class="keyword">if</span> ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,<span class="literal">NULL</span>))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// INTSET编码</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_INTSET) &#123;</span><br><span class="line">                <span class="comment">/* Fetch integer value from element. */</span></span><br><span class="line">                <span class="comment">// 读取整数值，并添加到INTSET</span></span><br><span class="line">                <span class="keyword">if</span> (isSdsRepresentableAsLongLong(sdsele,&amp;llval) == C_OK) &#123;</span><br><span class="line">                    o-&gt;ptr = intsetAdd(o-&gt;ptr,llval,<span class="literal">NULL</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 转换成哈希表</span></span><br><span class="line">                    setTypeConvert(o,OBJ_ENCODING_HT);</span><br><span class="line">                    dictExpand(o-&gt;ptr,len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This will also be called when the set was just converted</span></span><br><span class="line"><span class="comment">             * to a regular hash table encoded set. */</span></span><br><span class="line">            <span class="comment">// HT编码则添加到字典中</span></span><br><span class="line">            <span class="keyword">if</span> (o-&gt;encoding == OBJ_ENCODING_HT) &#123;</span><br><span class="line">                dictAdd((dict*)o-&gt;ptr,sdsele,<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                sdsfree(sdsele);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有序集合对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_ZSET_2 || rdbtype == RDB_TYPE_ZSET) &#123;</span><br><span class="line">        <span class="comment">/* Read list/set value. */</span></span><br><span class="line">        <span class="keyword">uint64_t</span> zsetlen;</span><br><span class="line">        <span class="keyword">size_t</span> maxelelen = <span class="number">0</span>;</span><br><span class="line">        zset *zs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取有序集合对象的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> ((zsetlen = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 创建有序集合对象</span></span><br><span class="line">        o = createZsetObject();</span><br><span class="line">        zs = o-&gt;ptr;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Load every single element of the sorted set. */</span></span><br><span class="line">        <span class="comment">// 遍历len个元素</span></span><br><span class="line">        <span class="keyword">while</span>(zsetlen--) &#123;</span><br><span class="line">            sds sdsele;</span><br><span class="line">            <span class="keyword">double</span> score;</span><br><span class="line">            zskiplistNode *znode;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取元素的key</span></span><br><span class="line">            <span class="keyword">if</span> ((sdsele = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,<span class="literal">NULL</span>))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 读取元素的score</span></span><br><span class="line">            <span class="keyword">if</span> (rdbtype == RDB_TYPE_ZSET_2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (rdbLoadBinaryDoubleValue(rdb,&amp;score) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rdbLoadDoubleValue(rdb,&amp;score) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Don't care about integer-encoded strings. */</span></span><br><span class="line">            <span class="comment">// 保存成员最大长度</span></span><br><span class="line">            <span class="keyword">if</span> (sdslen(sdsele) &gt; maxelelen) maxelelen = sdslen(sdsele);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当前元素对象插入到跳跃表和字典中</span></span><br><span class="line">            znode = zslInsert(zs-&gt;zsl,score,sdsele);</span><br><span class="line">            dictAdd(zs-&gt;dict,sdsele,&amp;znode-&gt;score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Convert *after* loading, since sorted sets are not stored ordered. */</span></span><br><span class="line">        <span class="comment">// 尝试编码转换为ziplist，以节省内存空间</span></span><br><span class="line">        <span class="keyword">if</span> (zsetLength(o) &lt;= server.zset_max_ziplist_entries &amp;&amp;</span><br><span class="line">            maxelelen &lt;= server.zset_max_ziplist_value)</span><br><span class="line">                zsetConvert(o,OBJ_ENCODING_ZIPLIST);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希对象</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_HASH) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> len;</span><br><span class="line">        <span class="keyword">int</span> ret;</span><br><span class="line">        sds field, value;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取哈希对象元素个数</span></span><br><span class="line">        len = rdbLoadLen(rdb, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (len == RDB_LENERR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建redis哈希对象</span></span><br><span class="line">        o = createHashObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Too many entries? Use a hash table. */</span></span><br><span class="line">        <span class="comment">// 如果超过ziplist的最大限制，转换为HT编码</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; server.hash_max_ziplist_entries)</span><br><span class="line">            hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Load every field and value into the ziplist */</span></span><br><span class="line">        <span class="comment">// 读取元素的field和score存储到ziplist</span></span><br><span class="line">        <span class="keyword">while</span> (o-&gt;encoding == OBJ_ENCODING_ZIPLIST &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">            <span class="comment">/* Load raw strings */</span></span><br><span class="line">            <span class="comment">// 读取field</span></span><br><span class="line">            <span class="keyword">if</span> ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,<span class="literal">NULL</span>))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 读取score</span></span><br><span class="line">            <span class="keyword">if</span> ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,<span class="literal">NULL</span>))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Add pair to ziplist */</span></span><br><span class="line">            <span class="comment">// 存储field和score到ziplist</span></span><br><span class="line">            o-&gt;ptr = ziplistPush(o-&gt;ptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)field,</span><br><span class="line">                    sdslen(field), ZIPLIST_TAIL);</span><br><span class="line">            o-&gt;ptr = ziplistPush(o-&gt;ptr, (<span class="keyword">unsigned</span> <span class="keyword">char</span>*)value,</span><br><span class="line">                    sdslen(value), ZIPLIST_TAIL);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Convert to hash table if size threshold is exceeded */</span></span><br><span class="line">            <span class="comment">// 如果超过的ziplist的限制，转换为HT编码</span></span><br><span class="line">            <span class="keyword">if</span> (sdslen(field) &gt; server.hash_max_ziplist_value ||</span><br><span class="line">                sdslen(value) &gt; server.hash_max_ziplist_value)</span><br><span class="line">            &#123;</span><br><span class="line">                sdsfree(field);</span><br><span class="line">                sdsfree(value);</span><br><span class="line">                hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放field,value</span></span><br><span class="line">            sdsfree(field);</span><br><span class="line">            sdsfree(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Load remaining fields and values into the hash table */</span></span><br><span class="line">        <span class="comment">// HT编码，读取field和value存储到哈希表</span></span><br><span class="line">        <span class="keyword">while</span> (o-&gt;encoding == OBJ_ENCODING_HT &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            len--;</span><br><span class="line">            <span class="comment">/* Load encoded strings */</span></span><br><span class="line">            <span class="comment">// 读取field和score</span></span><br><span class="line">            <span class="keyword">if</span> ((field = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,<span class="literal">NULL</span>))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((value = rdbGenericLoadStringObject(rdb,RDB_LOAD_SDS,<span class="literal">NULL</span>))</span><br><span class="line">                == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Add pair to hash table */</span></span><br><span class="line">            <span class="comment">// 存储到字典中</span></span><br><span class="line">            ret = dictAdd((dict*)o-&gt;ptr, field, value);</span><br><span class="line">            <span class="keyword">if</span> (ret == DICT_ERR) &#123;</span><br><span class="line">                rdbExitReportCorruptRDB(<span class="string">"Duplicate keys detected"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* All pairs should be read by now */</span></span><br><span class="line">        serverAssert(len == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// QUICKLIST类型的列表</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_LIST_QUICKLIST) &#123;</span><br><span class="line">        <span class="comment">// 读取quicklist结点个数</span></span><br><span class="line">        <span class="keyword">if</span> ((len = rdbLoadLen(rdb,<span class="literal">NULL</span>)) == RDB_LENERR) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个quicklist编码的列表对象</span></span><br><span class="line">        o = createQuicklistObject();</span><br><span class="line">        <span class="comment">// 设置压缩程度和ziplist的最大长度</span></span><br><span class="line">        quicklistSetOptions(o-&gt;ptr, server.list_max_ziplist_size,</span><br><span class="line">                            server.list_compress_depth);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取len个元素结点</span></span><br><span class="line">        <span class="keyword">while</span> (len--) &#123;</span><br><span class="line">            <span class="comment">// 读取一个quicklistNode结点的ziplist地址</span></span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl =</span><br><span class="line">                rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (zl == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 添加ziplist到快速列表结点，然后将快速列表结点添加到quicklist中</span></span><br><span class="line">            quicklistAppendZiplist(o-&gt;ptr, zl);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 其他一些类型编码</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_HASH_ZIPMAP  ||</span><br><span class="line">               rdbtype == RDB_TYPE_LIST_ZIPLIST ||</span><br><span class="line">               rdbtype == RDB_TYPE_SET_INTSET   ||</span><br><span class="line">               rdbtype == RDB_TYPE_ZSET_ZIPLIST ||</span><br><span class="line">               rdbtype == RDB_TYPE_HASH_ZIPLIST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取字符串值</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">char</span> *encoded =</span><br><span class="line">            rdbGenericLoadStringObject(rdb,RDB_LOAD_PLAIN,<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (encoded == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建字符串对象</span></span><br><span class="line">        o = createObject(OBJ_STRING,encoded); <span class="comment">/* Obj type fixed below. */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Fix the object encoding, and make sure to convert the encoded</span></span><br><span class="line"><span class="comment">         * data type into the base type if accordingly to the current</span></span><br><span class="line"><span class="comment">         * configuration there are too many elements in the encoded data</span></span><br><span class="line"><span class="comment">         * type. Note that we only check the length and not max element</span></span><br><span class="line"><span class="comment">         * size as this is an O(N) scan. Eventually everything will get</span></span><br><span class="line"><span class="comment">         * converted. */</span></span><br><span class="line">        <span class="comment">// 更加读取编码类型，读取其value，并转化为原来的编码对象</span></span><br><span class="line">        <span class="keyword">switch</span>(rdbtype) &#123;</span><br><span class="line">            <span class="keyword">case</span> RDB_TYPE_HASH_ZIPMAP: <span class="comment">// 压缩字典，已经不再使用</span></span><br><span class="line">                <span class="comment">/* Convert to ziplist encoded hash. This must be deprecated</span></span><br><span class="line"><span class="comment">                 * when loading dumps created by Redis 2.4 gets deprecated. */</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zi = zipmapRewind(o-&gt;ptr);</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">char</span> *fstr, *vstr;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> flen, vlen;</span><br><span class="line">                    <span class="keyword">unsigned</span> <span class="keyword">int</span> maxlen = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">while</span> ((zi = zipmapNext(zi, &amp;fstr, &amp;flen, &amp;vstr, &amp;vlen)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (flen &gt; maxlen) maxlen = flen;</span><br><span class="line">                        <span class="keyword">if</span> (vlen &gt; maxlen) maxlen = vlen;</span><br><span class="line">                        zl = ziplistPush(zl, fstr, flen, ZIPLIST_TAIL);</span><br><span class="line">                        zl = ziplistPush(zl, vstr, vlen, ZIPLIST_TAIL);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    zfree(o-&gt;ptr);</span><br><span class="line">                    o-&gt;ptr = zl;</span><br><span class="line">                    o-&gt;type = OBJ_HASH;</span><br><span class="line">                    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries ||</span><br><span class="line">                        maxlen &gt; server.hash_max_ziplist_value)</span><br><span class="line">                    &#123;</span><br><span class="line">                        hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RDB_TYPE_LIST_ZIPLIST: <span class="comment">// ZIPLIST编码的列表对象</span></span><br><span class="line">                o-&gt;type = OBJ_LIST;</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">                listTypeConvert(o,OBJ_ENCODING_QUICKLIST);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RDB_TYPE_SET_INTSET: <span class="comment">// INTSET编码的集合对象</span></span><br><span class="line">                o-&gt;type = OBJ_SET;</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">                <span class="keyword">if</span> (intsetLen(o-&gt;ptr) &gt; server.set_max_intset_entries)</span><br><span class="line">                    setTypeConvert(o,OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RDB_TYPE_ZSET_ZIPLIST: <span class="comment">// ZIPLIST编码的有序集合对象</span></span><br><span class="line">                o-&gt;type = OBJ_ZSET;</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">                <span class="keyword">if</span> (zsetLength(o) &gt; server.zset_max_ziplist_entries)</span><br><span class="line">                    zsetConvert(o,OBJ_ENCODING_SKIPLIST);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RDB_TYPE_HASH_ZIPLIST: <span class="comment">// ZIPLIST编码的哈希对象</span></span><br><span class="line">                o-&gt;type = OBJ_HASH;</span><br><span class="line">                o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">                <span class="keyword">if</span> (hashTypeLength(o) &gt; server.hash_max_ziplist_entries)</span><br><span class="line">                    hashTypeConvert(o, OBJ_ENCODING_HT);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                rdbExitReportCorruptRDB(<span class="string">"Unknown RDB encoding type %d"</span>,rdbtype);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// MODULE类型</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rdbtype == RDB_TYPE_MODULE || rdbtype == RDB_TYPE_MODULE_2) &#123;</span><br><span class="line">        <span class="keyword">uint64_t</span> moduleid = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">        moduleType *mt = moduleTypeLookupModuleByID(moduleid);</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rdbCheckMode &amp;&amp; rdbtype == RDB_TYPE_MODULE_2)</span><br><span class="line">            <span class="keyword">return</span> rdbLoadCheckModuleValue(rdb,name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mt == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"The RDB file contains module data I can't load: no matching module '%s'"</span>, name);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisModuleIO io;</span><br><span class="line">        moduleInitIOContext(io,mt,rdb);</span><br><span class="line">        io.ver = (rdbtype == RDB_TYPE_MODULE) ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="comment">/* Call the rdb_load method of the module providing the 10 bit</span></span><br><span class="line"><span class="comment">         * encoding version in the lower 10 bits of the module ID. */</span></span><br><span class="line">        <span class="keyword">void</span> *ptr = mt-&gt;rdb_load(&amp;io,moduleid&amp;<span class="number">1023</span>);</span><br><span class="line">        <span class="keyword">if</span> (io.ctx) &#123;</span><br><span class="line">            moduleFreeContext(io.ctx);</span><br><span class="line">            zfree(io.ctx);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Module v2 serialization has an EOF mark at the end. */</span></span><br><span class="line">        <span class="keyword">if</span> (io.ver == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> eof = rdbLoadLen(rdb,<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (eof != RDB_MODULE_OPCODE_EOF) &#123;</span><br><span class="line">                serverLog(LL_WARNING,<span class="string">"The RDB file contains module data for the module '%s' that is not terminated by the proper module value EOF marker"</span>, name);</span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ptr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            moduleTypeNameByID(name,moduleid);</span><br><span class="line">            serverLog(LL_WARNING,<span class="string">"The RDB file contains module data for the module type '%s', that the responsible module is not able to load. Check for modules log above for additional clues."</span>, name);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        o = createModuleObject(mt,ptr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rdbExitReportCorruptRDB(<span class="string">"Unknown RDB encoding type %d"</span>,rdbtype);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/gxcbuf.jpg"
                alt="郭欣成" />
            
              <p class="site-author-name" itemprop="name">郭欣成</p>
              <p class="site-description motion-element" itemprop="description">Persion & Developer</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">26</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                    <span class="site-state-item-count">1</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/gxcbuf" target="_blank" title="GitHub"><i class="fa fa-fw fa-github"></i>GitHub</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">郭欣成</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动 v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  





  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
